/*
API Documentation

Source of truth and network automation platform

API version: 1.3.7 (1.2)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// IpamApiService IpamApi service
type IpamApiService service

type ApiIpamAggregatesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamAggregatesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesBulkDestroyExecute(r)
}

/*
IpamAggregatesBulkDestroy Method for IpamAggregatesBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkDestroyRequest
*/
func (a *IpamApiService) IpamAggregatesBulkDestroy(ctx context.Context) ApiIpamAggregatesBulkDestroyRequest {
	return ApiIpamAggregatesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamAggregatesBulkDestroyExecute(r ApiIpamAggregatesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedWritableAggregate *PatchedWritableAggregate
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) PatchedWritableAggregate(patchedWritableAggregate PatchedWritableAggregate) ApiIpamAggregatesBulkPartialUpdateRequest {
	r.patchedWritableAggregate = &patchedWritableAggregate
	return r
}

func (r ApiIpamAggregatesBulkPartialUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkPartialUpdateExecute(r)
}

/*
IpamAggregatesBulkPartialUpdate Method for IpamAggregatesBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesBulkPartialUpdate(ctx context.Context) ApiIpamAggregatesBulkPartialUpdateRequest {
	return ApiIpamAggregatesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesBulkPartialUpdateExecute(r ApiIpamAggregatesBulkPartialUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableAggregate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableAggregate *WritableAggregate
}

func (r ApiIpamAggregatesBulkUpdateRequest) WritableAggregate(writableAggregate WritableAggregate) ApiIpamAggregatesBulkUpdateRequest {
	r.writableAggregate = &writableAggregate
	return r
}

func (r ApiIpamAggregatesBulkUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesBulkUpdateExecute(r)
}

/*
IpamAggregatesBulkUpdate Method for IpamAggregatesBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesBulkUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesBulkUpdate(ctx context.Context) ApiIpamAggregatesBulkUpdateRequest {
	return ApiIpamAggregatesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesBulkUpdateExecute(r ApiIpamAggregatesBulkUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableAggregate == nil {
		return localVarReturnValue, nil, reportError("writableAggregate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableAggregate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableAggregate *WritableAggregate
}

func (r ApiIpamAggregatesCreateRequest) WritableAggregate(writableAggregate WritableAggregate) ApiIpamAggregatesCreateRequest {
	r.writableAggregate = &writableAggregate
	return r
}

func (r ApiIpamAggregatesCreateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesCreateExecute(r)
}

/*
IpamAggregatesCreate Method for IpamAggregatesCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesCreateRequest
*/
func (a *IpamApiService) IpamAggregatesCreate(ctx context.Context) ApiIpamAggregatesCreateRequest {
	return ApiIpamAggregatesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesCreateExecute(r ApiIpamAggregatesCreateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableAggregate == nil {
		return localVarReturnValue, nil, reportError("writableAggregate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableAggregate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamAggregatesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamAggregatesDestroyExecute(r)
}

/*
IpamAggregatesDestroy Method for IpamAggregatesDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this aggregate.
 @return ApiIpamAggregatesDestroyRequest
*/
func (a *IpamApiService) IpamAggregatesDestroy(ctx context.Context, id string) ApiIpamAggregatesDestroyRequest {
	return ApiIpamAggregatesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamAggregatesDestroyExecute(r ApiIpamAggregatesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamAggregatesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	dateAdded *[]string
	dateAddedGt *[]string
	dateAddedGte *[]string
	dateAddedLt *[]string
	dateAddedLte *[]string
	dateAddedN *[]string
	family *float32
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	offset *int32
	prefix *string
	q *string
	rir *[]string
	rirN *[]string
	rirId *[]string
	rirIdN *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
}

func (r ApiIpamAggregatesListRequest) Created(created string) ApiIpamAggregatesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedGte(createdGte string) ApiIpamAggregatesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamAggregatesListRequest) CreatedLte(createdLte string) ApiIpamAggregatesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAdded(dateAdded []string) ApiIpamAggregatesListRequest {
	r.dateAdded = &dateAdded
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGt(dateAddedGt []string) ApiIpamAggregatesListRequest {
	r.dateAddedGt = &dateAddedGt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedGte(dateAddedGte []string) ApiIpamAggregatesListRequest {
	r.dateAddedGte = &dateAddedGte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLt(dateAddedLt []string) ApiIpamAggregatesListRequest {
	r.dateAddedLt = &dateAddedLt
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedLte(dateAddedLte []string) ApiIpamAggregatesListRequest {
	r.dateAddedLte = &dateAddedLte
	return r
}

func (r ApiIpamAggregatesListRequest) DateAddedN(dateAddedN []string) ApiIpamAggregatesListRequest {
	r.dateAddedN = &dateAddedN
	return r
}

// Family
func (r ApiIpamAggregatesListRequest) Family(family float32) ApiIpamAggregatesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamAggregatesListRequest) Id(id []string) ApiIpamAggregatesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamAggregatesListRequest) IdIc(idIc []string) ApiIpamAggregatesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamAggregatesListRequest) IdIe(idIe []string) ApiIpamAggregatesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamAggregatesListRequest) IdIew(idIew []string) ApiIpamAggregatesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamAggregatesListRequest) IdIre(idIre []string) ApiIpamAggregatesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamAggregatesListRequest) IdIsw(idIsw []string) ApiIpamAggregatesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamAggregatesListRequest) IdN(idN []string) ApiIpamAggregatesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamAggregatesListRequest) IdNic(idNic []string) ApiIpamAggregatesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamAggregatesListRequest) IdNie(idNie []string) ApiIpamAggregatesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamAggregatesListRequest) IdNiew(idNiew []string) ApiIpamAggregatesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamAggregatesListRequest) IdNire(idNire []string) ApiIpamAggregatesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamAggregatesListRequest) IdNisw(idNisw []string) ApiIpamAggregatesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamAggregatesListRequest) IdNre(idNre []string) ApiIpamAggregatesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamAggregatesListRequest) IdRe(idRe []string) ApiIpamAggregatesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdated(lastUpdated time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamAggregatesListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamAggregatesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamAggregatesListRequest) Limit(limit int32) ApiIpamAggregatesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamAggregatesListRequest) Offset(offset int32) ApiIpamAggregatesListRequest {
	r.offset = &offset
	return r
}

// Prefix
func (r ApiIpamAggregatesListRequest) Prefix(prefix string) ApiIpamAggregatesListRequest {
	r.prefix = &prefix
	return r
}

// Search
func (r ApiIpamAggregatesListRequest) Q(q string) ApiIpamAggregatesListRequest {
	r.q = &q
	return r
}

// RIR (slug)
func (r ApiIpamAggregatesListRequest) Rir(rir []string) ApiIpamAggregatesListRequest {
	r.rir = &rir
	return r
}

// RIR (slug)
func (r ApiIpamAggregatesListRequest) RirN(rirN []string) ApiIpamAggregatesListRequest {
	r.rirN = &rirN
	return r
}

// RIR (ID)
func (r ApiIpamAggregatesListRequest) RirId(rirId []string) ApiIpamAggregatesListRequest {
	r.rirId = &rirId
	return r
}

// RIR (ID)
func (r ApiIpamAggregatesListRequest) RirIdN(rirIdN []string) ApiIpamAggregatesListRequest {
	r.rirIdN = &rirIdN
	return r
}

func (r ApiIpamAggregatesListRequest) Tag(tag []string) ApiIpamAggregatesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamAggregatesListRequest) TagN(tagN []string) ApiIpamAggregatesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamAggregatesListRequest) Tenant(tenant []string) ApiIpamAggregatesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamAggregatesListRequest) TenantN(tenantN []string) ApiIpamAggregatesListRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamAggregatesListRequest) TenantGroup(tenantGroup []string) ApiIpamAggregatesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamAggregatesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamAggregatesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamAggregatesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamAggregatesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamAggregatesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamAggregatesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamAggregatesListRequest) TenantId(tenantId []*string) ApiIpamAggregatesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamAggregatesListRequest) TenantIdN(tenantIdN []*string) ApiIpamAggregatesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamAggregatesListRequest) Execute() (*PaginatedAggregateList, *http.Response, error) {
	return r.ApiService.IpamAggregatesListExecute(r)
}

/*
IpamAggregatesList Method for IpamAggregatesList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamAggregatesListRequest
*/
func (a *IpamApiService) IpamAggregatesList(ctx context.Context) ApiIpamAggregatesListRequest {
	return ApiIpamAggregatesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedAggregateList
func (a *IpamApiService) IpamAggregatesListExecute(r ApiIpamAggregatesListRequest) (*PaginatedAggregateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAggregateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.dateAdded != nil {
		t := *r.dateAdded
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("date_added", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("date_added", parameterToString(t, "multi"))
		}
	}
	if r.dateAddedGt != nil {
		t := *r.dateAddedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("date_added__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("date_added__gt", parameterToString(t, "multi"))
		}
	}
	if r.dateAddedGte != nil {
		t := *r.dateAddedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("date_added__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("date_added__gte", parameterToString(t, "multi"))
		}
	}
	if r.dateAddedLt != nil {
		t := *r.dateAddedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("date_added__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("date_added__lt", parameterToString(t, "multi"))
		}
	}
	if r.dateAddedLte != nil {
		t := *r.dateAddedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("date_added__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("date_added__lte", parameterToString(t, "multi"))
		}
	}
	if r.dateAddedN != nil {
		t := *r.dateAddedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("date_added__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("date_added__n", parameterToString(t, "multi"))
		}
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.rir != nil {
		t := *r.rir
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rir", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rir", parameterToString(t, "multi"))
		}
	}
	if r.rirN != nil {
		t := *r.rirN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rir__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rir__n", parameterToString(t, "multi"))
		}
	}
	if r.rirId != nil {
		t := *r.rirId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rir_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rir_id", parameterToString(t, "multi"))
		}
	}
	if r.rirIdN != nil {
		t := *r.rirIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rir_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rir_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritableAggregate *PatchedWritableAggregate
}

func (r ApiIpamAggregatesPartialUpdateRequest) PatchedWritableAggregate(patchedWritableAggregate PatchedWritableAggregate) ApiIpamAggregatesPartialUpdateRequest {
	r.patchedWritableAggregate = &patchedWritableAggregate
	return r
}

func (r ApiIpamAggregatesPartialUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesPartialUpdateExecute(r)
}

/*
IpamAggregatesPartialUpdate Method for IpamAggregatesPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this aggregate.
 @return ApiIpamAggregatesPartialUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesPartialUpdate(ctx context.Context, id string) ApiIpamAggregatesPartialUpdateRequest {
	return ApiIpamAggregatesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesPartialUpdateExecute(r ApiIpamAggregatesPartialUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableAggregate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamAggregatesRetrieveRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesRetrieveExecute(r)
}

/*
IpamAggregatesRetrieve Method for IpamAggregatesRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this aggregate.
 @return ApiIpamAggregatesRetrieveRequest
*/
func (a *IpamApiService) IpamAggregatesRetrieve(ctx context.Context, id string) ApiIpamAggregatesRetrieveRequest {
	return ApiIpamAggregatesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesRetrieveExecute(r ApiIpamAggregatesRetrieveRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamAggregatesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writableAggregate *WritableAggregate
}

func (r ApiIpamAggregatesUpdateRequest) WritableAggregate(writableAggregate WritableAggregate) ApiIpamAggregatesUpdateRequest {
	r.writableAggregate = &writableAggregate
	return r
}

func (r ApiIpamAggregatesUpdateRequest) Execute() (*Aggregate, *http.Response, error) {
	return r.ApiService.IpamAggregatesUpdateExecute(r)
}

/*
IpamAggregatesUpdate Method for IpamAggregatesUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this aggregate.
 @return ApiIpamAggregatesUpdateRequest
*/
func (a *IpamApiService) IpamAggregatesUpdate(ctx context.Context, id string) ApiIpamAggregatesUpdateRequest {
	return ApiIpamAggregatesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Aggregate
func (a *IpamApiService) IpamAggregatesUpdateExecute(r ApiIpamAggregatesUpdateRequest) (*Aggregate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aggregate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamAggregatesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/aggregates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableAggregate == nil {
		return localVarReturnValue, nil, reportError("writableAggregate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableAggregate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamIpAddressesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkDestroyExecute(r)
}

/*
IpamIpAddressesBulkDestroy Method for IpamIpAddressesBulkDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkDestroyRequest
*/
func (a *IpamApiService) IpamIpAddressesBulkDestroy(ctx context.Context) ApiIpamIpAddressesBulkDestroyRequest {
	return ApiIpamIpAddressesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamIpAddressesBulkDestroyExecute(r ApiIpamIpAddressesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	address *[]string
	assignedToInterface *bool
	created *string
	createdGte *string
	createdLte *string
	device *[]string
	deviceId *[]string
	dnsName *[]string
	dnsNameIc *[]string
	dnsNameIe *[]string
	dnsNameIew *[]string
	dnsNameIre *[]string
	dnsNameIsw *[]string
	dnsNameN *[]string
	dnsNameNic *[]string
	dnsNameNie *[]string
	dnsNameNiew *[]string
	dnsNameNire *[]string
	dnsNameNisw *[]string
	dnsNameNre *[]string
	dnsNameRe *[]string
	family *float32
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interface_ *[]string
	interfaceN *[]string
	interfaceId *[]string
	interfaceIdN *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	maskLength *float32
	offset *int32
	parent *string
	presentInVrf *string
	presentInVrfId *string
	q *string
	role *[]string
	roleN *[]string
	status *[]string
	statusN *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
	virtualMachine *[]string
	virtualMachineId *[]string
	vminterface *[]string
	vminterfaceN *[]string
	vminterfaceId *[]string
	vminterfaceIdN *[]string
	vrf *[]*string
	vrfN *[]*string
	vrfId *[]*string
	vrfIdN *[]*string
	patchedWritableIPAddress *PatchedWritableIPAddress
}

// Address
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Address(address []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.address = &address
	return r
}

// Is assigned to an interface
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) AssignedToInterface(assignedToInterface bool) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.assignedToInterface = &assignedToInterface
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Created(created string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) CreatedGte(createdGte string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) CreatedLte(createdLte string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.createdLte = &createdLte
	return r
}

// Device (name)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Device(device []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DeviceId(deviceId []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsName(dnsName []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsName = &dnsName
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameIc(dnsNameIc []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameIc = &dnsNameIc
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameIe(dnsNameIe []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameIe = &dnsNameIe
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameIew(dnsNameIew []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameIew = &dnsNameIew
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameIre(dnsNameIre []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameIre = &dnsNameIre
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameIsw(dnsNameIsw []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameIsw = &dnsNameIsw
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameN(dnsNameN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameN = &dnsNameN
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameNic(dnsNameNic []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameNic = &dnsNameNic
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameNie(dnsNameNie []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameNie = &dnsNameNie
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameNiew(dnsNameNiew []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameNiew = &dnsNameNiew
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameNire(dnsNameNire []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameNire = &dnsNameNire
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameNisw(dnsNameNisw []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameNisw = &dnsNameNisw
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameNre(dnsNameNre []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameNre = &dnsNameNre
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) DnsNameRe(dnsNameRe []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.dnsNameRe = &dnsNameRe
	return r
}

// Family
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Family(family float32) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.family = &family
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Id(id []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdIc(idIc []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdIe(idIe []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdIew(idIew []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdIre(idIre []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdIsw(idIsw []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdN(idN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdNic(idNic []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdNie(idNie []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdNiew(idNiew []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdNire(idNire []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdNisw(idNisw []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdNre(idNre []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) IdRe(idRe []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.idRe = &idRe
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Interface_(interface_ []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) InterfaceN(interfaceN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.interfaceN = &interfaceN
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) InterfaceId(interfaceId []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.interfaceId = &interfaceId
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) InterfaceIdN(interfaceIdN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) LastUpdated(lastUpdated time.Time) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Limit(limit int32) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.limit = &limit
	return r
}

// Mask length
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) MaskLength(maskLength float32) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.maskLength = &maskLength
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Offset(offset int32) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.offset = &offset
	return r
}

// Parent prefix
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Parent(parent string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.parent = &parent
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) PresentInVrf(presentInVrf string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.presentInVrf = &presentInVrf
	return r
}

// VRF
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) PresentInVrfId(presentInVrfId string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Q(q string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.q = &q
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Role(role []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.role = &role
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) RoleN(roleN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.roleN = &roleN
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Status(status []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.status = &status
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) StatusN(statusN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Tag(tag []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TagN(tagN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Tenant(tenant []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TenantN(tenantN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TenantGroup(tenantGroup []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TenantGroupId(tenantGroupId []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TenantId(tenantId []*string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) TenantIdN(tenantIdN []*string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Virtual machine (name)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VirtualMachine(virtualMachine []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VirtualMachineId(virtualMachineId []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Vminterface(vminterface []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vminterface = &vminterface
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VminterfaceN(vminterfaceN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VminterfaceId(vminterfaceId []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VminterfaceIdN(vminterfaceIdN []string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Vrf(vrf []*string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VrfN(vrfN []*string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VrfId(vrfId []*string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamIpAddressesBulkPartialUpdateRequest) VrfIdN(vrfIdN []*string) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) PatchedWritableIPAddress(patchedWritableIPAddress PatchedWritableIPAddress) ApiIpamIpAddressesBulkPartialUpdateRequest {
	r.patchedWritableIPAddress = &patchedWritableIPAddress
	return r
}

func (r ApiIpamIpAddressesBulkPartialUpdateRequest) Execute() (*PaginatedIPAddressSerializerLegacyList, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkPartialUpdateExecute(r)
}

/*
IpamIpAddressesBulkPartialUpdate Method for IpamIpAddressesBulkPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesBulkPartialUpdate(ctx context.Context) ApiIpamIpAddressesBulkPartialUpdateRequest {
	return ApiIpamIpAddressesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPAddressSerializerLegacyList
func (a *IpamApiService) IpamIpAddressesBulkPartialUpdateExecute(r ApiIpamIpAddressesBulkPartialUpdateRequest) (*PaginatedIPAddressSerializerLegacyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPAddressSerializerLegacyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		t := *r.address
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("address", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("address", parameterToString(t, "multi"))
		}
	}
	if r.assignedToInterface != nil {
		localVarQueryParams.Add("assigned_to_interface", parameterToString(*r.assignedToInterface, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device_id", parameterToString(t, "multi"))
		}
	}
	if r.dnsName != nil {
		t := *r.dnsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIc != nil {
		t := *r.dnsNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ic", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIe != nil {
		t := *r.dnsNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ie", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIew != nil {
		t := *r.dnsNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__iew", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIre != nil {
		t := *r.dnsNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ire", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIsw != nil {
		t := *r.dnsNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__isw", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameN != nil {
		t := *r.dnsNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__n", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNic != nil {
		t := *r.dnsNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nic", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNie != nil {
		t := *r.dnsNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nie", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNiew != nil {
		t := *r.dnsNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__niew", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNire != nil {
		t := *r.dnsNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nire", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNisw != nil {
		t := *r.dnsNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNre != nil {
		t := *r.dnsNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nre", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameRe != nil {
		t := *r.dnsNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__re", parameterToString(t, "multi"))
		}
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface", parameterToString(t, "multi"))
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface__n", parameterToString(t, "multi"))
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface_id", parameterToString(t, "multi"))
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface_id__n", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.maskLength != nil {
		localVarQueryParams.Add("mask_length", parameterToString(*r.maskLength, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.presentInVrf != nil {
		localVarQueryParams.Add("present_in_vrf", parameterToString(*r.presentInVrf, ""))
	}
	if r.presentInVrfId != nil {
		localVarQueryParams.Add("present_in_vrf_id", parameterToString(*r.presentInVrfId, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role", parameterToString(t, "multi"))
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role__n", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status__n", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine_id", parameterToString(t, "multi"))
		}
	}
	if r.vminterface != nil {
		t := *r.vminterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceN != nil {
		t := *r.vminterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface__n", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceId != nil {
		t := *r.vminterfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface_id", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceIdN != nil {
		t := *r.vminterfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface_id__n", parameterToString(t, "multi"))
		}
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf", parameterToString(t, "multi"))
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf__n", parameterToString(t, "multi"))
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id", parameterToString(t, "multi"))
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPAddress
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableIPAddress *WritableIPAddress
	address *[]string
	assignedToInterface *bool
	created *string
	createdGte *string
	createdLte *string
	device *[]string
	deviceId *[]string
	dnsName *[]string
	dnsNameIc *[]string
	dnsNameIe *[]string
	dnsNameIew *[]string
	dnsNameIre *[]string
	dnsNameIsw *[]string
	dnsNameN *[]string
	dnsNameNic *[]string
	dnsNameNie *[]string
	dnsNameNiew *[]string
	dnsNameNire *[]string
	dnsNameNisw *[]string
	dnsNameNre *[]string
	dnsNameRe *[]string
	family *float32
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interface_ *[]string
	interfaceN *[]string
	interfaceId *[]string
	interfaceIdN *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	maskLength *float32
	offset *int32
	parent *string
	presentInVrf *string
	presentInVrfId *string
	q *string
	role *[]string
	roleN *[]string
	status *[]string
	statusN *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
	virtualMachine *[]string
	virtualMachineId *[]string
	vminterface *[]string
	vminterfaceN *[]string
	vminterfaceId *[]string
	vminterfaceIdN *[]string
	vrf *[]*string
	vrfN *[]*string
	vrfId *[]*string
	vrfIdN *[]*string
}

func (r ApiIpamIpAddressesBulkUpdateRequest) WritableIPAddress(writableIPAddress WritableIPAddress) ApiIpamIpAddressesBulkUpdateRequest {
	r.writableIPAddress = &writableIPAddress
	return r
}

// Address
func (r ApiIpamIpAddressesBulkUpdateRequest) Address(address []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.address = &address
	return r
}

// Is assigned to an interface
func (r ApiIpamIpAddressesBulkUpdateRequest) AssignedToInterface(assignedToInterface bool) ApiIpamIpAddressesBulkUpdateRequest {
	r.assignedToInterface = &assignedToInterface
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Created(created string) ApiIpamIpAddressesBulkUpdateRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) CreatedGte(createdGte string) ApiIpamIpAddressesBulkUpdateRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) CreatedLte(createdLte string) ApiIpamIpAddressesBulkUpdateRequest {
	r.createdLte = &createdLte
	return r
}

// Device (name)
func (r ApiIpamIpAddressesBulkUpdateRequest) Device(device []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) DeviceId(deviceId []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsName(dnsName []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsName = &dnsName
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameIc(dnsNameIc []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameIc = &dnsNameIc
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameIe(dnsNameIe []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameIe = &dnsNameIe
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameIew(dnsNameIew []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameIew = &dnsNameIew
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameIre(dnsNameIre []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameIre = &dnsNameIre
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameIsw(dnsNameIsw []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameIsw = &dnsNameIsw
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameN(dnsNameN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameN = &dnsNameN
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameNic(dnsNameNic []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameNic = &dnsNameNic
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameNie(dnsNameNie []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameNie = &dnsNameNie
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameNiew(dnsNameNiew []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameNiew = &dnsNameNiew
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameNire(dnsNameNire []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameNire = &dnsNameNire
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameNisw(dnsNameNisw []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameNisw = &dnsNameNisw
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameNre(dnsNameNre []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameNre = &dnsNameNre
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) DnsNameRe(dnsNameRe []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.dnsNameRe = &dnsNameRe
	return r
}

// Family
func (r ApiIpamIpAddressesBulkUpdateRequest) Family(family float32) ApiIpamIpAddressesBulkUpdateRequest {
	r.family = &family
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Id(id []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdIc(idIc []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdIe(idIe []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdIew(idIew []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdIre(idIre []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdIsw(idIsw []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdN(idN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdNic(idNic []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdNie(idNie []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdNiew(idNiew []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdNire(idNire []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdNisw(idNisw []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdNre(idNre []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) IdRe(idRe []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.idRe = &idRe
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesBulkUpdateRequest) Interface_(interface_ []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesBulkUpdateRequest) InterfaceN(interfaceN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.interfaceN = &interfaceN
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) InterfaceId(interfaceId []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.interfaceId = &interfaceId
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) InterfaceIdN(interfaceIdN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) LastUpdated(lastUpdated time.Time) ApiIpamIpAddressesBulkUpdateRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamIpAddressesBulkUpdateRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamIpAddressesBulkUpdateRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesBulkUpdateRequest) Limit(limit int32) ApiIpamIpAddressesBulkUpdateRequest {
	r.limit = &limit
	return r
}

// Mask length
func (r ApiIpamIpAddressesBulkUpdateRequest) MaskLength(maskLength float32) ApiIpamIpAddressesBulkUpdateRequest {
	r.maskLength = &maskLength
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesBulkUpdateRequest) Offset(offset int32) ApiIpamIpAddressesBulkUpdateRequest {
	r.offset = &offset
	return r
}

// Parent prefix
func (r ApiIpamIpAddressesBulkUpdateRequest) Parent(parent string) ApiIpamIpAddressesBulkUpdateRequest {
	r.parent = &parent
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesBulkUpdateRequest) PresentInVrf(presentInVrf string) ApiIpamIpAddressesBulkUpdateRequest {
	r.presentInVrf = &presentInVrf
	return r
}

// VRF
func (r ApiIpamIpAddressesBulkUpdateRequest) PresentInVrfId(presentInVrfId string) ApiIpamIpAddressesBulkUpdateRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamIpAddressesBulkUpdateRequest) Q(q string) ApiIpamIpAddressesBulkUpdateRequest {
	r.q = &q
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesBulkUpdateRequest) Role(role []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.role = &role
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesBulkUpdateRequest) RoleN(roleN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.roleN = &roleN
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Status(status []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.status = &status
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) StatusN(statusN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Tag(tag []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) TagN(tagN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesBulkUpdateRequest) Tenant(tenant []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesBulkUpdateRequest) TenantN(tenantN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamIpAddressesBulkUpdateRequest) TenantGroup(tenantGroup []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamIpAddressesBulkUpdateRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) TenantGroupId(tenantGroupId []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) TenantId(tenantId []*string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) TenantIdN(tenantIdN []*string) ApiIpamIpAddressesBulkUpdateRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Virtual machine (name)
func (r ApiIpamIpAddressesBulkUpdateRequest) VirtualMachine(virtualMachine []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) VirtualMachineId(virtualMachineId []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesBulkUpdateRequest) Vminterface(vminterface []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vminterface = &vminterface
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesBulkUpdateRequest) VminterfaceN(vminterfaceN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) VminterfaceId(vminterfaceId []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesBulkUpdateRequest) VminterfaceIdN(vminterfaceIdN []string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesBulkUpdateRequest) Vrf(vrf []*string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesBulkUpdateRequest) VrfN(vrfN []*string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamIpAddressesBulkUpdateRequest) VrfId(vrfId []*string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamIpAddressesBulkUpdateRequest) VrfIdN(vrfIdN []*string) ApiIpamIpAddressesBulkUpdateRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpAddressesBulkUpdateRequest) Execute() (*PaginatedIPAddressSerializerLegacyList, *http.Response, error) {
	return r.ApiService.IpamIpAddressesBulkUpdateExecute(r)
}

/*
IpamIpAddressesBulkUpdate Method for IpamIpAddressesBulkUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesBulkUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesBulkUpdate(ctx context.Context) ApiIpamIpAddressesBulkUpdateRequest {
	return ApiIpamIpAddressesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPAddressSerializerLegacyList
func (a *IpamApiService) IpamIpAddressesBulkUpdateExecute(r ApiIpamIpAddressesBulkUpdateRequest) (*PaginatedIPAddressSerializerLegacyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPAddressSerializerLegacyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPAddress == nil {
		return localVarReturnValue, nil, reportError("writableIPAddress is required and must be specified")
	}

	if r.address != nil {
		t := *r.address
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("address", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("address", parameterToString(t, "multi"))
		}
	}
	if r.assignedToInterface != nil {
		localVarQueryParams.Add("assigned_to_interface", parameterToString(*r.assignedToInterface, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device_id", parameterToString(t, "multi"))
		}
	}
	if r.dnsName != nil {
		t := *r.dnsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIc != nil {
		t := *r.dnsNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ic", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIe != nil {
		t := *r.dnsNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ie", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIew != nil {
		t := *r.dnsNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__iew", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIre != nil {
		t := *r.dnsNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ire", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIsw != nil {
		t := *r.dnsNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__isw", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameN != nil {
		t := *r.dnsNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__n", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNic != nil {
		t := *r.dnsNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nic", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNie != nil {
		t := *r.dnsNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nie", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNiew != nil {
		t := *r.dnsNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__niew", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNire != nil {
		t := *r.dnsNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nire", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNisw != nil {
		t := *r.dnsNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNre != nil {
		t := *r.dnsNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nre", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameRe != nil {
		t := *r.dnsNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__re", parameterToString(t, "multi"))
		}
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface", parameterToString(t, "multi"))
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface__n", parameterToString(t, "multi"))
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface_id", parameterToString(t, "multi"))
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface_id__n", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.maskLength != nil {
		localVarQueryParams.Add("mask_length", parameterToString(*r.maskLength, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.presentInVrf != nil {
		localVarQueryParams.Add("present_in_vrf", parameterToString(*r.presentInVrf, ""))
	}
	if r.presentInVrfId != nil {
		localVarQueryParams.Add("present_in_vrf_id", parameterToString(*r.presentInVrfId, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role", parameterToString(t, "multi"))
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role__n", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status__n", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine_id", parameterToString(t, "multi"))
		}
	}
	if r.vminterface != nil {
		t := *r.vminterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceN != nil {
		t := *r.vminterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface__n", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceId != nil {
		t := *r.vminterfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface_id", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceIdN != nil {
		t := *r.vminterfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface_id__n", parameterToString(t, "multi"))
		}
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf", parameterToString(t, "multi"))
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf__n", parameterToString(t, "multi"))
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id", parameterToString(t, "multi"))
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPAddress
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableIPAddress *WritableIPAddress
}

func (r ApiIpamIpAddressesCreateRequest) WritableIPAddress(writableIPAddress WritableIPAddress) ApiIpamIpAddressesCreateRequest {
	r.writableIPAddress = &writableIPAddress
	return r
}

func (r ApiIpamIpAddressesCreateRequest) Execute() (*IPAddressSerializerLegacy, *http.Response, error) {
	return r.ApiService.IpamIpAddressesCreateExecute(r)
}

/*
IpamIpAddressesCreate Method for IpamIpAddressesCreate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesCreateRequest
*/
func (a *IpamApiService) IpamIpAddressesCreate(ctx context.Context) ApiIpamIpAddressesCreateRequest {
	return ApiIpamIpAddressesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IPAddressSerializerLegacy
func (a *IpamApiService) IpamIpAddressesCreateExecute(r ApiIpamIpAddressesCreateRequest) (*IPAddressSerializerLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressSerializerLegacy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPAddress == nil {
		return localVarReturnValue, nil, reportError("writableIPAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPAddress
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamIpAddressesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamIpAddressesDestroyExecute(r)
}

/*
IpamIpAddressesDestroy Method for IpamIpAddressesDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesDestroyRequest
*/
func (a *IpamApiService) IpamIpAddressesDestroy(ctx context.Context, id string) ApiIpamIpAddressesDestroyRequest {
	return ApiIpamIpAddressesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamIpAddressesDestroyExecute(r ApiIpamIpAddressesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamIpAddressesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	address *[]string
	assignedToInterface *bool
	created *string
	createdGte *string
	createdLte *string
	device *[]string
	deviceId *[]string
	dnsName *[]string
	dnsNameIc *[]string
	dnsNameIe *[]string
	dnsNameIew *[]string
	dnsNameIre *[]string
	dnsNameIsw *[]string
	dnsNameN *[]string
	dnsNameNic *[]string
	dnsNameNie *[]string
	dnsNameNiew *[]string
	dnsNameNire *[]string
	dnsNameNisw *[]string
	dnsNameNre *[]string
	dnsNameRe *[]string
	family *float32
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	interface_ *[]string
	interfaceN *[]string
	interfaceId *[]string
	interfaceIdN *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	maskLength *float32
	offset *int32
	parent *string
	presentInVrf *string
	presentInVrfId *string
	q *string
	role *[]string
	roleN *[]string
	status *[]string
	statusN *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
	virtualMachine *[]string
	virtualMachineId *[]string
	vminterface *[]string
	vminterfaceN *[]string
	vminterfaceId *[]string
	vminterfaceIdN *[]string
	vrf *[]*string
	vrfN *[]*string
	vrfId *[]*string
	vrfIdN *[]*string
}

// Address
func (r ApiIpamIpAddressesListRequest) Address(address []string) ApiIpamIpAddressesListRequest {
	r.address = &address
	return r
}

// Is assigned to an interface
func (r ApiIpamIpAddressesListRequest) AssignedToInterface(assignedToInterface bool) ApiIpamIpAddressesListRequest {
	r.assignedToInterface = &assignedToInterface
	return r
}

func (r ApiIpamIpAddressesListRequest) Created(created string) ApiIpamIpAddressesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedGte(createdGte string) ApiIpamIpAddressesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamIpAddressesListRequest) CreatedLte(createdLte string) ApiIpamIpAddressesListRequest {
	r.createdLte = &createdLte
	return r
}

// Device (name)
func (r ApiIpamIpAddressesListRequest) Device(device []string) ApiIpamIpAddressesListRequest {
	r.device = &device
	return r
}

// Device (ID)
func (r ApiIpamIpAddressesListRequest) DeviceId(deviceId []string) ApiIpamIpAddressesListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsName(dnsName []string) ApiIpamIpAddressesListRequest {
	r.dnsName = &dnsName
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIc(dnsNameIc []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIc = &dnsNameIc
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIe(dnsNameIe []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIe = &dnsNameIe
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIew(dnsNameIew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIew = &dnsNameIew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIre(dnsNameIre []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIre = &dnsNameIre
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameIsw(dnsNameIsw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameIsw = &dnsNameIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameN(dnsNameN []string) ApiIpamIpAddressesListRequest {
	r.dnsNameN = &dnsNameN
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNic(dnsNameNic []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNic = &dnsNameNic
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNie(dnsNameNie []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNie = &dnsNameNie
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNiew(dnsNameNiew []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNiew = &dnsNameNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNire(dnsNameNire []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNire = &dnsNameNire
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNisw(dnsNameNisw []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNisw = &dnsNameNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameNre(dnsNameNre []string) ApiIpamIpAddressesListRequest {
	r.dnsNameNre = &dnsNameNre
	return r
}

func (r ApiIpamIpAddressesListRequest) DnsNameRe(dnsNameRe []string) ApiIpamIpAddressesListRequest {
	r.dnsNameRe = &dnsNameRe
	return r
}

// Family
func (r ApiIpamIpAddressesListRequest) Family(family float32) ApiIpamIpAddressesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamIpAddressesListRequest) Id(id []string) ApiIpamIpAddressesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIc(idIc []string) ApiIpamIpAddressesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIe(idIe []string) ApiIpamIpAddressesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIew(idIew []string) ApiIpamIpAddressesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIre(idIre []string) ApiIpamIpAddressesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamIpAddressesListRequest) IdIsw(idIsw []string) ApiIpamIpAddressesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamIpAddressesListRequest) IdN(idN []string) ApiIpamIpAddressesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNic(idNic []string) ApiIpamIpAddressesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNie(idNie []string) ApiIpamIpAddressesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNiew(idNiew []string) ApiIpamIpAddressesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNire(idNire []string) ApiIpamIpAddressesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNisw(idNisw []string) ApiIpamIpAddressesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamIpAddressesListRequest) IdNre(idNre []string) ApiIpamIpAddressesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamIpAddressesListRequest) IdRe(idRe []string) ApiIpamIpAddressesListRequest {
	r.idRe = &idRe
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesListRequest) Interface_(interface_ []string) ApiIpamIpAddressesListRequest {
	r.interface_ = &interface_
	return r
}

// Interface (name)
func (r ApiIpamIpAddressesListRequest) InterfaceN(interfaceN []string) ApiIpamIpAddressesListRequest {
	r.interfaceN = &interfaceN
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesListRequest) InterfaceId(interfaceId []string) ApiIpamIpAddressesListRequest {
	r.interfaceId = &interfaceId
	return r
}

// Interface (ID)
func (r ApiIpamIpAddressesListRequest) InterfaceIdN(interfaceIdN []string) ApiIpamIpAddressesListRequest {
	r.interfaceIdN = &interfaceIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdated(lastUpdated time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamIpAddressesListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamIpAddressesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamIpAddressesListRequest) Limit(limit int32) ApiIpamIpAddressesListRequest {
	r.limit = &limit
	return r
}

// Mask length
func (r ApiIpamIpAddressesListRequest) MaskLength(maskLength float32) ApiIpamIpAddressesListRequest {
	r.maskLength = &maskLength
	return r
}

// The initial index from which to return the results.
func (r ApiIpamIpAddressesListRequest) Offset(offset int32) ApiIpamIpAddressesListRequest {
	r.offset = &offset
	return r
}

// Parent prefix
func (r ApiIpamIpAddressesListRequest) Parent(parent string) ApiIpamIpAddressesListRequest {
	r.parent = &parent
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) PresentInVrf(presentInVrf string) ApiIpamIpAddressesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

// VRF
func (r ApiIpamIpAddressesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamIpAddressesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamIpAddressesListRequest) Q(q string) ApiIpamIpAddressesListRequest {
	r.q = &q
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) Role(role []string) ApiIpamIpAddressesListRequest {
	r.role = &role
	return r
}

// The functional role of this IP
func (r ApiIpamIpAddressesListRequest) RoleN(roleN []string) ApiIpamIpAddressesListRequest {
	r.roleN = &roleN
	return r
}

func (r ApiIpamIpAddressesListRequest) Status(status []string) ApiIpamIpAddressesListRequest {
	r.status = &status
	return r
}

func (r ApiIpamIpAddressesListRequest) StatusN(statusN []string) ApiIpamIpAddressesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamIpAddressesListRequest) Tag(tag []string) ApiIpamIpAddressesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamIpAddressesListRequest) TagN(tagN []string) ApiIpamIpAddressesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesListRequest) Tenant(tenant []string) ApiIpamIpAddressesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamIpAddressesListRequest) TenantN(tenantN []string) ApiIpamIpAddressesListRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamIpAddressesListRequest) TenantGroup(tenantGroup []string) ApiIpamIpAddressesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamIpAddressesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamIpAddressesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamIpAddressesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamIpAddressesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesListRequest) TenantId(tenantId []*string) ApiIpamIpAddressesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamIpAddressesListRequest) TenantIdN(tenantIdN []*string) ApiIpamIpAddressesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Virtual machine (name)
func (r ApiIpamIpAddressesListRequest) VirtualMachine(virtualMachine []string) ApiIpamIpAddressesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (ID)
func (r ApiIpamIpAddressesListRequest) VirtualMachineId(virtualMachineId []string) ApiIpamIpAddressesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesListRequest) Vminterface(vminterface []string) ApiIpamIpAddressesListRequest {
	r.vminterface = &vminterface
	return r
}

// VM interface (name)
func (r ApiIpamIpAddressesListRequest) VminterfaceN(vminterfaceN []string) ApiIpamIpAddressesListRequest {
	r.vminterfaceN = &vminterfaceN
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesListRequest) VminterfaceId(vminterfaceId []string) ApiIpamIpAddressesListRequest {
	r.vminterfaceId = &vminterfaceId
	return r
}

// VM interface (ID)
func (r ApiIpamIpAddressesListRequest) VminterfaceIdN(vminterfaceIdN []string) ApiIpamIpAddressesListRequest {
	r.vminterfaceIdN = &vminterfaceIdN
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) Vrf(vrf []*string) ApiIpamIpAddressesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamIpAddressesListRequest) VrfN(vrfN []*string) ApiIpamIpAddressesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamIpAddressesListRequest) VrfId(vrfId []*string) ApiIpamIpAddressesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamIpAddressesListRequest) VrfIdN(vrfIdN []*string) ApiIpamIpAddressesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

func (r ApiIpamIpAddressesListRequest) Execute() (*PaginatedIPAddressSerializerLegacyList, *http.Response, error) {
	return r.ApiService.IpamIpAddressesListExecute(r)
}

/*
IpamIpAddressesList Method for IpamIpAddressesList

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamIpAddressesListRequest
*/
func (a *IpamApiService) IpamIpAddressesList(ctx context.Context) ApiIpamIpAddressesListRequest {
	return ApiIpamIpAddressesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedIPAddressSerializerLegacyList
func (a *IpamApiService) IpamIpAddressesListExecute(r ApiIpamIpAddressesListRequest) (*PaginatedIPAddressSerializerLegacyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIPAddressSerializerLegacyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		t := *r.address
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("address", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("address", parameterToString(t, "multi"))
		}
	}
	if r.assignedToInterface != nil {
		localVarQueryParams.Add("assigned_to_interface", parameterToString(*r.assignedToInterface, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device_id", parameterToString(t, "multi"))
		}
	}
	if r.dnsName != nil {
		t := *r.dnsName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIc != nil {
		t := *r.dnsNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ic", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIe != nil {
		t := *r.dnsNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ie", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIew != nil {
		t := *r.dnsNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__iew", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIre != nil {
		t := *r.dnsNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__ire", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameIsw != nil {
		t := *r.dnsNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__isw", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameN != nil {
		t := *r.dnsNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__n", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNic != nil {
		t := *r.dnsNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nic", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNie != nil {
		t := *r.dnsNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nie", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNiew != nil {
		t := *r.dnsNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__niew", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNire != nil {
		t := *r.dnsNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nire", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNisw != nil {
		t := *r.dnsNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameNre != nil {
		t := *r.dnsNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__nre", parameterToString(t, "multi"))
		}
	}
	if r.dnsNameRe != nil {
		t := *r.dnsNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("dns_name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("dns_name__re", parameterToString(t, "multi"))
		}
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.interface_ != nil {
		t := *r.interface_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface", parameterToString(t, "multi"))
		}
	}
	if r.interfaceN != nil {
		t := *r.interfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface__n", parameterToString(t, "multi"))
		}
	}
	if r.interfaceId != nil {
		t := *r.interfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface_id", parameterToString(t, "multi"))
		}
	}
	if r.interfaceIdN != nil {
		t := *r.interfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("interface_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("interface_id__n", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.maskLength != nil {
		localVarQueryParams.Add("mask_length", parameterToString(*r.maskLength, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.parent != nil {
		localVarQueryParams.Add("parent", parameterToString(*r.parent, ""))
	}
	if r.presentInVrf != nil {
		localVarQueryParams.Add("present_in_vrf", parameterToString(*r.presentInVrf, ""))
	}
	if r.presentInVrfId != nil {
		localVarQueryParams.Add("present_in_vrf_id", parameterToString(*r.presentInVrfId, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role", parameterToString(t, "multi"))
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role__n", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status__n", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine_id", parameterToString(t, "multi"))
		}
	}
	if r.vminterface != nil {
		t := *r.vminterface
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceN != nil {
		t := *r.vminterfaceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface__n", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceId != nil {
		t := *r.vminterfaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface_id", parameterToString(t, "multi"))
		}
	}
	if r.vminterfaceIdN != nil {
		t := *r.vminterfaceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vminterface_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vminterface_id__n", parameterToString(t, "multi"))
		}
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf", parameterToString(t, "multi"))
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf__n", parameterToString(t, "multi"))
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id", parameterToString(t, "multi"))
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritableIPAddress *PatchedWritableIPAddress
}

func (r ApiIpamIpAddressesPartialUpdateRequest) PatchedWritableIPAddress(patchedWritableIPAddress PatchedWritableIPAddress) ApiIpamIpAddressesPartialUpdateRequest {
	r.patchedWritableIPAddress = &patchedWritableIPAddress
	return r
}

func (r ApiIpamIpAddressesPartialUpdateRequest) Execute() (*IPAddressSerializerLegacy, *http.Response, error) {
	return r.ApiService.IpamIpAddressesPartialUpdateExecute(r)
}

/*
IpamIpAddressesPartialUpdate Method for IpamIpAddressesPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesPartialUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesPartialUpdate(ctx context.Context, id string) ApiIpamIpAddressesPartialUpdateRequest {
	return ApiIpamIpAddressesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddressSerializerLegacy
func (a *IpamApiService) IpamIpAddressesPartialUpdateExecute(r ApiIpamIpAddressesPartialUpdateRequest) (*IPAddressSerializerLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressSerializerLegacy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableIPAddress
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamIpAddressesRetrieveRequest) Execute() (*IPAddressSerializerLegacy, *http.Response, error) {
	return r.ApiService.IpamIpAddressesRetrieveExecute(r)
}

/*
IpamIpAddressesRetrieve Method for IpamIpAddressesRetrieve

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesRetrieveRequest
*/
func (a *IpamApiService) IpamIpAddressesRetrieve(ctx context.Context, id string) ApiIpamIpAddressesRetrieveRequest {
	return ApiIpamIpAddressesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddressSerializerLegacy
func (a *IpamApiService) IpamIpAddressesRetrieveExecute(r ApiIpamIpAddressesRetrieveRequest) (*IPAddressSerializerLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressSerializerLegacy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamIpAddressesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writableIPAddress *WritableIPAddress
}

func (r ApiIpamIpAddressesUpdateRequest) WritableIPAddress(writableIPAddress WritableIPAddress) ApiIpamIpAddressesUpdateRequest {
	r.writableIPAddress = &writableIPAddress
	return r
}

func (r ApiIpamIpAddressesUpdateRequest) Execute() (*IPAddressSerializerLegacy, *http.Response, error) {
	return r.ApiService.IpamIpAddressesUpdateExecute(r)
}

/*
IpamIpAddressesUpdate Method for IpamIpAddressesUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamIpAddressesUpdateRequest
*/
func (a *IpamApiService) IpamIpAddressesUpdate(ctx context.Context, id string) ApiIpamIpAddressesUpdateRequest {
	return ApiIpamIpAddressesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IPAddressSerializerLegacy
func (a *IpamApiService) IpamIpAddressesUpdateExecute(r ApiIpamIpAddressesUpdateRequest) (*IPAddressSerializerLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IPAddressSerializerLegacy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamIpAddressesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/ip-addresses/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableIPAddress == nil {
		return localVarReturnValue, nil, reportError("writableIPAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableIPAddress
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	availableIP *[]AvailableIP
	limit *int32
	offset *int32
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) AvailableIP(availableIP []AvailableIP) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.availableIP = &availableIP
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesAvailableIpsCreateRequest) Limit(limit int32) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesAvailableIpsCreateRequest) Offset(offset int32) ApiIpamPrefixesAvailableIpsCreateRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamPrefixesAvailableIpsCreateRequest) Execute() (*PaginatedAvailableIPList, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsCreateExecute(r)
}

/*
IpamPrefixesAvailableIpsCreate Method for IpamPrefixesAvailableIpsCreate

A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
however results will not be paginated.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamPrefixesAvailableIpsCreateRequest
*/
func (a *IpamApiService) IpamPrefixesAvailableIpsCreate(ctx context.Context, id string) ApiIpamPrefixesAvailableIpsCreateRequest {
	return ApiIpamPrefixesAvailableIpsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedAvailableIPList
func (a *IpamApiService) IpamPrefixesAvailableIpsCreateExecute(r ApiIpamPrefixesAvailableIpsCreateRequest) (*PaginatedAvailableIPList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAvailableIPList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailableIpsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.availableIP == nil {
		return localVarReturnValue, nil, reportError("availableIP is required and must be specified")
	}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.availableIP
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailableIpsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiIpamPrefixesAvailableIpsListRequest) Limit(limit int32) ApiIpamPrefixesAvailableIpsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesAvailableIpsListRequest) Offset(offset int32) ApiIpamPrefixesAvailableIpsListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamPrefixesAvailableIpsListRequest) Execute() (*PaginatedAvailableIPList, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailableIpsListExecute(r)
}

/*
IpamPrefixesAvailableIpsList Method for IpamPrefixesAvailableIpsList

A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
however results will not be paginated.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this IP address.
 @return ApiIpamPrefixesAvailableIpsListRequest
*/
func (a *IpamApiService) IpamPrefixesAvailableIpsList(ctx context.Context, id string) ApiIpamPrefixesAvailableIpsListRequest {
	return ApiIpamPrefixesAvailableIpsListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedAvailableIPList
func (a *IpamApiService) IpamPrefixesAvailableIpsListExecute(r ApiIpamPrefixesAvailableIpsListRequest) (*PaginatedAvailableIPList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAvailableIPList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailableIpsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-ips/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	prefixLength *PrefixLength
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) PrefixLength(prefixLength PrefixLength) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	r.prefixLength = &prefixLength
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesCreateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesCreateExecute(r)
}

/*
IpamPrefixesAvailablePrefixesCreate Method for IpamPrefixesAvailablePrefixesCreate

A convenience method for returning available child prefixes within a parent.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesAvailablePrefixesCreateRequest
*/
func (a *IpamApiService) IpamPrefixesAvailablePrefixesCreate(ctx context.Context, id string) ApiIpamPrefixesAvailablePrefixesCreateRequest {
	return ApiIpamPrefixesAvailablePrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesAvailablePrefixesCreateExecute(r ApiIpamPrefixesAvailablePrefixesCreateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailablePrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.prefixLength == nil {
		return localVarReturnValue, nil, reportError("prefixLength is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.prefixLength
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesAvailablePrefixesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiIpamPrefixesAvailablePrefixesListRequest) Limit(limit int32) ApiIpamPrefixesAvailablePrefixesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesAvailablePrefixesListRequest) Offset(offset int32) ApiIpamPrefixesAvailablePrefixesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamPrefixesAvailablePrefixesListRequest) Execute() (*PaginatedAvailablePrefixList, *http.Response, error) {
	return r.ApiService.IpamPrefixesAvailablePrefixesListExecute(r)
}

/*
IpamPrefixesAvailablePrefixesList Method for IpamPrefixesAvailablePrefixesList

A convenience method for returning available child prefixes within a parent.

The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
invoked in parallel, which results in a race condition where multiple insertions can occur.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesAvailablePrefixesListRequest
*/
func (a *IpamApiService) IpamPrefixesAvailablePrefixesList(ctx context.Context, id string) ApiIpamPrefixesAvailablePrefixesListRequest {
	return ApiIpamPrefixesAvailablePrefixesListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedAvailablePrefixList
func (a *IpamApiService) IpamPrefixesAvailablePrefixesListExecute(r ApiIpamPrefixesAvailablePrefixesListRequest) (*PaginatedAvailablePrefixList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAvailablePrefixList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesAvailablePrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/available-prefixes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamPrefixesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesBulkDestroyExecute(r)
}

/*
IpamPrefixesBulkDestroy Method for IpamPrefixesBulkDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkDestroyRequest
*/
func (a *IpamApiService) IpamPrefixesBulkDestroy(ctx context.Context) ApiIpamPrefixesBulkDestroyRequest {
	return ApiIpamPrefixesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamPrefixesBulkDestroyExecute(r ApiIpamPrefixesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedWritablePrefix *PatchedWritablePrefix
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) PatchedWritablePrefix(patchedWritablePrefix PatchedWritablePrefix) ApiIpamPrefixesBulkPartialUpdateRequest {
	r.patchedWritablePrefix = &patchedWritablePrefix
	return r
}

func (r ApiIpamPrefixesBulkPartialUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkPartialUpdateExecute(r)
}

/*
IpamPrefixesBulkPartialUpdate Method for IpamPrefixesBulkPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesBulkPartialUpdate(ctx context.Context) ApiIpamPrefixesBulkPartialUpdateRequest {
	return ApiIpamPrefixesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesBulkPartialUpdateExecute(r ApiIpamPrefixesBulkPartialUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePrefix
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writablePrefix *WritablePrefix
}

func (r ApiIpamPrefixesBulkUpdateRequest) WritablePrefix(writablePrefix WritablePrefix) ApiIpamPrefixesBulkUpdateRequest {
	r.writablePrefix = &writablePrefix
	return r
}

func (r ApiIpamPrefixesBulkUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesBulkUpdateExecute(r)
}

/*
IpamPrefixesBulkUpdate Method for IpamPrefixesBulkUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesBulkUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesBulkUpdate(ctx context.Context) ApiIpamPrefixesBulkUpdateRequest {
	return ApiIpamPrefixesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesBulkUpdateExecute(r ApiIpamPrefixesBulkUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefix == nil {
		return localVarReturnValue, nil, reportError("writablePrefix is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefix
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writablePrefix *WritablePrefix
}

func (r ApiIpamPrefixesCreateRequest) WritablePrefix(writablePrefix WritablePrefix) ApiIpamPrefixesCreateRequest {
	r.writablePrefix = &writablePrefix
	return r
}

func (r ApiIpamPrefixesCreateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesCreateExecute(r)
}

/*
IpamPrefixesCreate Method for IpamPrefixesCreate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesCreateRequest
*/
func (a *IpamApiService) IpamPrefixesCreate(ctx context.Context) ApiIpamPrefixesCreateRequest {
	return ApiIpamPrefixesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesCreateExecute(r ApiIpamPrefixesCreateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefix == nil {
		return localVarReturnValue, nil, reportError("writablePrefix is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefix
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamPrefixesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamPrefixesDestroyExecute(r)
}

/*
IpamPrefixesDestroy Method for IpamPrefixesDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesDestroyRequest
*/
func (a *IpamApiService) IpamPrefixesDestroy(ctx context.Context, id string) ApiIpamPrefixesDestroyRequest {
	return ApiIpamPrefixesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamPrefixesDestroyExecute(r ApiIpamPrefixesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamPrefixesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	contains *string
	created *string
	createdGte *string
	createdLte *string
	family *float32
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	isPool *bool
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	maskLength *float32
	maskLengthGte *float32
	maskLengthLte *float32
	offset *int32
	prefix *string
	presentInVrf *string
	presentInVrfId *string
	q *string
	region *[]string
	regionN *[]string
	regionId *[]string
	regionIdN *[]string
	role *[]string
	roleN *[]string
	roleId *[]*string
	roleIdN *[]*string
	site *[]string
	siteN *[]string
	siteId *[]*string
	siteIdN *[]*string
	status *[]string
	statusN *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
	vlanId *[]*string
	vlanIdN *[]*string
	vlanVid *int32
	vrf *[]*string
	vrfN *[]*string
	vrfId *[]*string
	vrfIdN *[]*string
	within *string
	withinInclude *string
}

// Prefixes which contain this prefix or IP
func (r ApiIpamPrefixesListRequest) Contains(contains string) ApiIpamPrefixesListRequest {
	r.contains = &contains
	return r
}

func (r ApiIpamPrefixesListRequest) Created(created string) ApiIpamPrefixesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedGte(createdGte string) ApiIpamPrefixesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamPrefixesListRequest) CreatedLte(createdLte string) ApiIpamPrefixesListRequest {
	r.createdLte = &createdLte
	return r
}

// Family
func (r ApiIpamPrefixesListRequest) Family(family float32) ApiIpamPrefixesListRequest {
	r.family = &family
	return r
}

func (r ApiIpamPrefixesListRequest) Id(id []string) ApiIpamPrefixesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamPrefixesListRequest) IdIc(idIc []string) ApiIpamPrefixesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamPrefixesListRequest) IdIe(idIe []string) ApiIpamPrefixesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamPrefixesListRequest) IdIew(idIew []string) ApiIpamPrefixesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamPrefixesListRequest) IdIre(idIre []string) ApiIpamPrefixesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamPrefixesListRequest) IdIsw(idIsw []string) ApiIpamPrefixesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamPrefixesListRequest) IdN(idN []string) ApiIpamPrefixesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamPrefixesListRequest) IdNic(idNic []string) ApiIpamPrefixesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamPrefixesListRequest) IdNie(idNie []string) ApiIpamPrefixesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamPrefixesListRequest) IdNiew(idNiew []string) ApiIpamPrefixesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamPrefixesListRequest) IdNire(idNire []string) ApiIpamPrefixesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamPrefixesListRequest) IdNisw(idNisw []string) ApiIpamPrefixesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamPrefixesListRequest) IdNre(idNre []string) ApiIpamPrefixesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamPrefixesListRequest) IdRe(idRe []string) ApiIpamPrefixesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamPrefixesListRequest) IsPool(isPool bool) ApiIpamPrefixesListRequest {
	r.isPool = &isPool
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdated(lastUpdated time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamPrefixesListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamPrefixesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamPrefixesListRequest) Limit(limit int32) ApiIpamPrefixesListRequest {
	r.limit = &limit
	return r
}

// mask_length
func (r ApiIpamPrefixesListRequest) MaskLength(maskLength float32) ApiIpamPrefixesListRequest {
	r.maskLength = &maskLength
	return r
}

// mask_length__gte
func (r ApiIpamPrefixesListRequest) MaskLengthGte(maskLengthGte float32) ApiIpamPrefixesListRequest {
	r.maskLengthGte = &maskLengthGte
	return r
}

// mask_length__lte
func (r ApiIpamPrefixesListRequest) MaskLengthLte(maskLengthLte float32) ApiIpamPrefixesListRequest {
	r.maskLengthLte = &maskLengthLte
	return r
}

// The initial index from which to return the results.
func (r ApiIpamPrefixesListRequest) Offset(offset int32) ApiIpamPrefixesListRequest {
	r.offset = &offset
	return r
}

// Prefix
func (r ApiIpamPrefixesListRequest) Prefix(prefix string) ApiIpamPrefixesListRequest {
	r.prefix = &prefix
	return r
}

// VRF (RD)
func (r ApiIpamPrefixesListRequest) PresentInVrf(presentInVrf string) ApiIpamPrefixesListRequest {
	r.presentInVrf = &presentInVrf
	return r
}

// VRF
func (r ApiIpamPrefixesListRequest) PresentInVrfId(presentInVrfId string) ApiIpamPrefixesListRequest {
	r.presentInVrfId = &presentInVrfId
	return r
}

// Search
func (r ApiIpamPrefixesListRequest) Q(q string) ApiIpamPrefixesListRequest {
	r.q = &q
	return r
}

// Region (slug)
func (r ApiIpamPrefixesListRequest) Region(region []string) ApiIpamPrefixesListRequest {
	r.region = &region
	return r
}

// Region (slug)
func (r ApiIpamPrefixesListRequest) RegionN(regionN []string) ApiIpamPrefixesListRequest {
	r.regionN = &regionN
	return r
}

// Region (ID)
func (r ApiIpamPrefixesListRequest) RegionId(regionId []string) ApiIpamPrefixesListRequest {
	r.regionId = &regionId
	return r
}

// Region (ID)
func (r ApiIpamPrefixesListRequest) RegionIdN(regionIdN []string) ApiIpamPrefixesListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Role (slug)
func (r ApiIpamPrefixesListRequest) Role(role []string) ApiIpamPrefixesListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamPrefixesListRequest) RoleN(roleN []string) ApiIpamPrefixesListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamPrefixesListRequest) RoleId(roleId []*string) ApiIpamPrefixesListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamPrefixesListRequest) RoleIdN(roleIdN []*string) ApiIpamPrefixesListRequest {
	r.roleIdN = &roleIdN
	return r
}

// Site (slug)
func (r ApiIpamPrefixesListRequest) Site(site []string) ApiIpamPrefixesListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamPrefixesListRequest) SiteN(siteN []string) ApiIpamPrefixesListRequest {
	r.siteN = &siteN
	return r
}

// Site (ID)
func (r ApiIpamPrefixesListRequest) SiteId(siteId []*string) ApiIpamPrefixesListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamPrefixesListRequest) SiteIdN(siteIdN []*string) ApiIpamPrefixesListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiIpamPrefixesListRequest) Status(status []string) ApiIpamPrefixesListRequest {
	r.status = &status
	return r
}

func (r ApiIpamPrefixesListRequest) StatusN(statusN []string) ApiIpamPrefixesListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamPrefixesListRequest) Tag(tag []string) ApiIpamPrefixesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamPrefixesListRequest) TagN(tagN []string) ApiIpamPrefixesListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamPrefixesListRequest) Tenant(tenant []string) ApiIpamPrefixesListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamPrefixesListRequest) TenantN(tenantN []string) ApiIpamPrefixesListRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamPrefixesListRequest) TenantGroup(tenantGroup []string) ApiIpamPrefixesListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamPrefixesListRequest) TenantGroupN(tenantGroupN []string) ApiIpamPrefixesListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamPrefixesListRequest) TenantGroupId(tenantGroupId []string) ApiIpamPrefixesListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamPrefixesListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamPrefixesListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamPrefixesListRequest) TenantId(tenantId []*string) ApiIpamPrefixesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamPrefixesListRequest) TenantIdN(tenantIdN []*string) ApiIpamPrefixesListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanId(vlanId []*string) ApiIpamPrefixesListRequest {
	r.vlanId = &vlanId
	return r
}

// VLAN (ID)
func (r ApiIpamPrefixesListRequest) VlanIdN(vlanIdN []*string) ApiIpamPrefixesListRequest {
	r.vlanIdN = &vlanIdN
	return r
}

// VLAN number (1-4095)
func (r ApiIpamPrefixesListRequest) VlanVid(vlanVid int32) ApiIpamPrefixesListRequest {
	r.vlanVid = &vlanVid
	return r
}

// VRF (RD)
func (r ApiIpamPrefixesListRequest) Vrf(vrf []*string) ApiIpamPrefixesListRequest {
	r.vrf = &vrf
	return r
}

// VRF (RD)
func (r ApiIpamPrefixesListRequest) VrfN(vrfN []*string) ApiIpamPrefixesListRequest {
	r.vrfN = &vrfN
	return r
}

// VRF
func (r ApiIpamPrefixesListRequest) VrfId(vrfId []*string) ApiIpamPrefixesListRequest {
	r.vrfId = &vrfId
	return r
}

// VRF
func (r ApiIpamPrefixesListRequest) VrfIdN(vrfIdN []*string) ApiIpamPrefixesListRequest {
	r.vrfIdN = &vrfIdN
	return r
}

// Within prefix
func (r ApiIpamPrefixesListRequest) Within(within string) ApiIpamPrefixesListRequest {
	r.within = &within
	return r
}

// Within and including prefix
func (r ApiIpamPrefixesListRequest) WithinInclude(withinInclude string) ApiIpamPrefixesListRequest {
	r.withinInclude = &withinInclude
	return r
}

func (r ApiIpamPrefixesListRequest) Execute() (*PaginatedPrefixList, *http.Response, error) {
	return r.ApiService.IpamPrefixesListExecute(r)
}

/*
IpamPrefixesList Method for IpamPrefixesList

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamPrefixesListRequest
*/
func (a *IpamApiService) IpamPrefixesList(ctx context.Context) ApiIpamPrefixesListRequest {
	return ApiIpamPrefixesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedPrefixList
func (a *IpamApiService) IpamPrefixesListExecute(r ApiIpamPrefixesListRequest) (*PaginatedPrefixList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPrefixList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.isPool != nil {
		localVarQueryParams.Add("is_pool", parameterToString(*r.isPool, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.maskLength != nil {
		localVarQueryParams.Add("mask_length", parameterToString(*r.maskLength, ""))
	}
	if r.maskLengthGte != nil {
		localVarQueryParams.Add("mask_length__gte", parameterToString(*r.maskLengthGte, ""))
	}
	if r.maskLengthLte != nil {
		localVarQueryParams.Add("mask_length__lte", parameterToString(*r.maskLengthLte, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.presentInVrf != nil {
		localVarQueryParams.Add("present_in_vrf", parameterToString(*r.presentInVrf, ""))
	}
	if r.presentInVrfId != nil {
		localVarQueryParams.Add("present_in_vrf_id", parameterToString(*r.presentInVrfId, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region", parameterToString(t, "multi"))
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region__n", parameterToString(t, "multi"))
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id", parameterToString(t, "multi"))
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id__n", parameterToString(t, "multi"))
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role", parameterToString(t, "multi"))
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role__n", parameterToString(t, "multi"))
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role_id", parameterToString(t, "multi"))
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role_id__n", parameterToString(t, "multi"))
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site", parameterToString(t, "multi"))
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site__n", parameterToString(t, "multi"))
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id", parameterToString(t, "multi"))
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id__n", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status__n", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	if r.vlanId != nil {
		t := *r.vlanId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vlan_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vlan_id", parameterToString(t, "multi"))
		}
	}
	if r.vlanIdN != nil {
		t := *r.vlanIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vlan_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vlan_id__n", parameterToString(t, "multi"))
		}
	}
	if r.vlanVid != nil {
		localVarQueryParams.Add("vlan_vid", parameterToString(*r.vlanVid, ""))
	}
	if r.vrf != nil {
		t := *r.vrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf", parameterToString(t, "multi"))
		}
	}
	if r.vrfN != nil {
		t := *r.vrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf__n", parameterToString(t, "multi"))
		}
	}
	if r.vrfId != nil {
		t := *r.vrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id", parameterToString(t, "multi"))
		}
	}
	if r.vrfIdN != nil {
		t := *r.vrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vrf_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vrf_id__n", parameterToString(t, "multi"))
		}
	}
	if r.within != nil {
		localVarQueryParams.Add("within", parameterToString(*r.within, ""))
	}
	if r.withinInclude != nil {
		localVarQueryParams.Add("within_include", parameterToString(*r.withinInclude, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritablePrefix *PatchedWritablePrefix
}

func (r ApiIpamPrefixesPartialUpdateRequest) PatchedWritablePrefix(patchedWritablePrefix PatchedWritablePrefix) ApiIpamPrefixesPartialUpdateRequest {
	r.patchedWritablePrefix = &patchedWritablePrefix
	return r
}

func (r ApiIpamPrefixesPartialUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesPartialUpdateExecute(r)
}

/*
IpamPrefixesPartialUpdate Method for IpamPrefixesPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesPartialUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesPartialUpdate(ctx context.Context, id string) ApiIpamPrefixesPartialUpdateRequest {
	return ApiIpamPrefixesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesPartialUpdateExecute(r ApiIpamPrefixesPartialUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritablePrefix
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamPrefixesRetrieveRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesRetrieveExecute(r)
}

/*
IpamPrefixesRetrieve Method for IpamPrefixesRetrieve

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesRetrieveRequest
*/
func (a *IpamApiService) IpamPrefixesRetrieve(ctx context.Context, id string) ApiIpamPrefixesRetrieveRequest {
	return ApiIpamPrefixesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesRetrieveExecute(r ApiIpamPrefixesRetrieveRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamPrefixesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writablePrefix *WritablePrefix
}

func (r ApiIpamPrefixesUpdateRequest) WritablePrefix(writablePrefix WritablePrefix) ApiIpamPrefixesUpdateRequest {
	r.writablePrefix = &writablePrefix
	return r
}

func (r ApiIpamPrefixesUpdateRequest) Execute() (*Prefix, *http.Response, error) {
	return r.ApiService.IpamPrefixesUpdateExecute(r)
}

/*
IpamPrefixesUpdate Method for IpamPrefixesUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this prefix.
 @return ApiIpamPrefixesUpdateRequest
*/
func (a *IpamApiService) IpamPrefixesUpdate(ctx context.Context, id string) ApiIpamPrefixesUpdateRequest {
	return ApiIpamPrefixesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Prefix
func (a *IpamApiService) IpamPrefixesUpdateExecute(r ApiIpamPrefixesUpdateRequest) (*Prefix, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Prefix
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamPrefixesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/prefixes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writablePrefix == nil {
		return localVarReturnValue, nil, reportError("writablePrefix is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writablePrefix
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamRirsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsBulkDestroyExecute(r)
}

/*
IpamRirsBulkDestroy Method for IpamRirsBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkDestroyRequest
*/
func (a *IpamApiService) IpamRirsBulkDestroy(ctx context.Context) ApiIpamRirsBulkDestroyRequest {
	return ApiIpamRirsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRirsBulkDestroyExecute(r ApiIpamRirsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedRIR *PatchedRIR
}

func (r ApiIpamRirsBulkPartialUpdateRequest) PatchedRIR(patchedRIR PatchedRIR) ApiIpamRirsBulkPartialUpdateRequest {
	r.patchedRIR = &patchedRIR
	return r
}

func (r ApiIpamRirsBulkPartialUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkPartialUpdateExecute(r)
}

/*
IpamRirsBulkPartialUpdate Method for IpamRirsBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamRirsBulkPartialUpdate(ctx context.Context) ApiIpamRirsBulkPartialUpdateRequest {
	return ApiIpamRirsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsBulkPartialUpdateExecute(r ApiIpamRirsBulkPartialUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRIR
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	rIR *RIR
}

func (r ApiIpamRirsBulkUpdateRequest) RIR(rIR RIR) ApiIpamRirsBulkUpdateRequest {
	r.rIR = &rIR
	return r
}

func (r ApiIpamRirsBulkUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsBulkUpdateExecute(r)
}

/*
IpamRirsBulkUpdate Method for IpamRirsBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsBulkUpdateRequest
*/
func (a *IpamApiService) IpamRirsBulkUpdate(ctx context.Context) ApiIpamRirsBulkUpdateRequest {
	return ApiIpamRirsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsBulkUpdateExecute(r ApiIpamRirsBulkUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIR == nil {
		return localVarReturnValue, nil, reportError("rIR is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIR
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	rIR *RIR
}

func (r ApiIpamRirsCreateRequest) RIR(rIR RIR) ApiIpamRirsCreateRequest {
	r.rIR = &rIR
	return r
}

func (r ApiIpamRirsCreateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsCreateExecute(r)
}

/*
IpamRirsCreate Method for IpamRirsCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsCreateRequest
*/
func (a *IpamApiService) IpamRirsCreate(ctx context.Context) ApiIpamRirsCreateRequest {
	return ApiIpamRirsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsCreateExecute(r ApiIpamRirsCreateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIR == nil {
		return localVarReturnValue, nil, reportError("rIR is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIR
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamRirsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRirsDestroyExecute(r)
}

/*
IpamRirsDestroy Method for IpamRirsDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsDestroyRequest
*/
func (a *IpamApiService) IpamRirsDestroy(ctx context.Context, id string) ApiIpamRirsDestroyRequest {
	return ApiIpamRirsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRirsDestroyExecute(r ApiIpamRirsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRirsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	isPrivate *bool
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	slug *[]string
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIre *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNire *[]string
	slugNisw *[]string
	slugNre *[]string
	slugRe *[]string
}

func (r ApiIpamRirsListRequest) Created(created string) ApiIpamRirsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRirsListRequest) CreatedGte(createdGte string) ApiIpamRirsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRirsListRequest) CreatedLte(createdLte string) ApiIpamRirsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRirsListRequest) Description(description []string) ApiIpamRirsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIc(descriptionIc []string) ApiIpamRirsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIe(descriptionIe []string) ApiIpamRirsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIew(descriptionIew []string) ApiIpamRirsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIre(descriptionIre []string) ApiIpamRirsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiIpamRirsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamRirsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionN(descriptionN []string) ApiIpamRirsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNic(descriptionNic []string) ApiIpamRirsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNie(descriptionNie []string) ApiIpamRirsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamRirsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNire(descriptionNire []string) ApiIpamRirsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamRirsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamRirsListRequest) DescriptionNre(descriptionNre []string) ApiIpamRirsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiIpamRirsListRequest) DescriptionRe(descriptionRe []string) ApiIpamRirsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiIpamRirsListRequest) Id(id []string) ApiIpamRirsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRirsListRequest) IdIc(idIc []string) ApiIpamRirsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamRirsListRequest) IdIe(idIe []string) ApiIpamRirsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamRirsListRequest) IdIew(idIew []string) ApiIpamRirsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamRirsListRequest) IdIre(idIre []string) ApiIpamRirsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamRirsListRequest) IdIsw(idIsw []string) ApiIpamRirsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamRirsListRequest) IdN(idN []string) ApiIpamRirsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRirsListRequest) IdNic(idNic []string) ApiIpamRirsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamRirsListRequest) IdNie(idNie []string) ApiIpamRirsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamRirsListRequest) IdNiew(idNiew []string) ApiIpamRirsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamRirsListRequest) IdNire(idNire []string) ApiIpamRirsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamRirsListRequest) IdNisw(idNisw []string) ApiIpamRirsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamRirsListRequest) IdNre(idNre []string) ApiIpamRirsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamRirsListRequest) IdRe(idRe []string) ApiIpamRirsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamRirsListRequest) IsPrivate(isPrivate bool) ApiIpamRirsListRequest {
	r.isPrivate = &isPrivate
	return r
}

func (r ApiIpamRirsListRequest) LastUpdated(lastUpdated time.Time) ApiIpamRirsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRirsListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamRirsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamRirsListRequest) Limit(limit int32) ApiIpamRirsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRirsListRequest) Name(name []string) ApiIpamRirsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRirsListRequest) NameIc(nameIc []string) ApiIpamRirsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRirsListRequest) NameIe(nameIe []string) ApiIpamRirsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRirsListRequest) NameIew(nameIew []string) ApiIpamRirsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRirsListRequest) NameIre(nameIre []string) ApiIpamRirsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamRirsListRequest) NameIsw(nameIsw []string) ApiIpamRirsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRirsListRequest) NameN(nameN []string) ApiIpamRirsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRirsListRequest) NameNic(nameNic []string) ApiIpamRirsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRirsListRequest) NameNie(nameNie []string) ApiIpamRirsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRirsListRequest) NameNiew(nameNiew []string) ApiIpamRirsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRirsListRequest) NameNire(nameNire []string) ApiIpamRirsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamRirsListRequest) NameNisw(nameNisw []string) ApiIpamRirsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRirsListRequest) NameNre(nameNre []string) ApiIpamRirsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamRirsListRequest) NameRe(nameRe []string) ApiIpamRirsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRirsListRequest) Offset(offset int32) ApiIpamRirsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamRirsListRequest) Q(q string) ApiIpamRirsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRirsListRequest) Slug(slug []string) ApiIpamRirsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRirsListRequest) SlugIc(slugIc []string) ApiIpamRirsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRirsListRequest) SlugIe(slugIe []string) ApiIpamRirsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRirsListRequest) SlugIew(slugIew []string) ApiIpamRirsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRirsListRequest) SlugIre(slugIre []string) ApiIpamRirsListRequest {
	r.slugIre = &slugIre
	return r
}

func (r ApiIpamRirsListRequest) SlugIsw(slugIsw []string) ApiIpamRirsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRirsListRequest) SlugN(slugN []string) ApiIpamRirsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRirsListRequest) SlugNic(slugNic []string) ApiIpamRirsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRirsListRequest) SlugNie(slugNie []string) ApiIpamRirsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRirsListRequest) SlugNiew(slugNiew []string) ApiIpamRirsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRirsListRequest) SlugNire(slugNire []string) ApiIpamRirsListRequest {
	r.slugNire = &slugNire
	return r
}

func (r ApiIpamRirsListRequest) SlugNisw(slugNisw []string) ApiIpamRirsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRirsListRequest) SlugNre(slugNre []string) ApiIpamRirsListRequest {
	r.slugNre = &slugNre
	return r
}

func (r ApiIpamRirsListRequest) SlugRe(slugRe []string) ApiIpamRirsListRequest {
	r.slugRe = &slugRe
	return r
}

func (r ApiIpamRirsListRequest) Execute() (*PaginatedRIRList, *http.Response, error) {
	return r.ApiService.IpamRirsListExecute(r)
}

/*
IpamRirsList Method for IpamRirsList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRirsListRequest
*/
func (a *IpamApiService) IpamRirsList(ctx context.Context) ApiIpamRirsListRequest {
	return ApiIpamRirsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRIRList
func (a *IpamApiService) IpamRirsListExecute(r ApiIpamRirsListRequest) (*PaginatedRIRList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRIRList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__ic", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__ie", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__iew", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__ire", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__isw", parameterToString(t, "multi"))
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__n", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nic", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nie", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__niew", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nire", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nisw", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nre", parameterToString(t, "multi"))
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__re", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.isPrivate != nil {
		localVarQueryParams.Add("is_private", parameterToString(*r.isPrivate, ""))
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug", parameterToString(t, "multi"))
		}
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ic", parameterToString(t, "multi"))
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ie", parameterToString(t, "multi"))
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__iew", parameterToString(t, "multi"))
		}
	}
	if r.slugIre != nil {
		t := *r.slugIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ire", parameterToString(t, "multi"))
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__isw", parameterToString(t, "multi"))
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__n", parameterToString(t, "multi"))
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nic", parameterToString(t, "multi"))
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nie", parameterToString(t, "multi"))
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__niew", parameterToString(t, "multi"))
		}
	}
	if r.slugNire != nil {
		t := *r.slugNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nire", parameterToString(t, "multi"))
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nisw", parameterToString(t, "multi"))
		}
	}
	if r.slugNre != nil {
		t := *r.slugNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nre", parameterToString(t, "multi"))
		}
	}
	if r.slugRe != nil {
		t := *r.slugRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__re", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedRIR *PatchedRIR
}

func (r ApiIpamRirsPartialUpdateRequest) PatchedRIR(patchedRIR PatchedRIR) ApiIpamRirsPartialUpdateRequest {
	r.patchedRIR = &patchedRIR
	return r
}

func (r ApiIpamRirsPartialUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsPartialUpdateExecute(r)
}

/*
IpamRirsPartialUpdate Method for IpamRirsPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsPartialUpdateRequest
*/
func (a *IpamApiService) IpamRirsPartialUpdate(ctx context.Context, id string) ApiIpamRirsPartialUpdateRequest {
	return ApiIpamRirsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsPartialUpdateExecute(r ApiIpamRirsPartialUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRIR
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamRirsRetrieveRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsRetrieveExecute(r)
}

/*
IpamRirsRetrieve Method for IpamRirsRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsRetrieveRequest
*/
func (a *IpamApiService) IpamRirsRetrieve(ctx context.Context, id string) ApiIpamRirsRetrieveRequest {
	return ApiIpamRirsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsRetrieveExecute(r ApiIpamRirsRetrieveRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRirsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	rIR *RIR
}

func (r ApiIpamRirsUpdateRequest) RIR(rIR RIR) ApiIpamRirsUpdateRequest {
	r.rIR = &rIR
	return r
}

func (r ApiIpamRirsUpdateRequest) Execute() (*RIR, *http.Response, error) {
	return r.ApiService.IpamRirsUpdateExecute(r)
}

/*
IpamRirsUpdate Method for IpamRirsUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this RIR.
 @return ApiIpamRirsUpdateRequest
*/
func (a *IpamApiService) IpamRirsUpdate(ctx context.Context, id string) ApiIpamRirsUpdateRequest {
	return ApiIpamRirsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RIR
func (a *IpamApiService) IpamRirsUpdateExecute(r ApiIpamRirsUpdateRequest) (*RIR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RIR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRirsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/rirs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.rIR == nil {
		return localVarReturnValue, nil, reportError("rIR is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rIR
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamRolesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesBulkDestroyExecute(r)
}

/*
IpamRolesBulkDestroy Method for IpamRolesBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkDestroyRequest
*/
func (a *IpamApiService) IpamRolesBulkDestroy(ctx context.Context) ApiIpamRolesBulkDestroyRequest {
	return ApiIpamRolesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRolesBulkDestroyExecute(r ApiIpamRolesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedRole *PatchedRole
}

func (r ApiIpamRolesBulkPartialUpdateRequest) PatchedRole(patchedRole PatchedRole) ApiIpamRolesBulkPartialUpdateRequest {
	r.patchedRole = &patchedRole
	return r
}

func (r ApiIpamRolesBulkPartialUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkPartialUpdateExecute(r)
}

/*
IpamRolesBulkPartialUpdate Method for IpamRolesBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamRolesBulkPartialUpdate(ctx context.Context) ApiIpamRolesBulkPartialUpdateRequest {
	return ApiIpamRolesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesBulkPartialUpdateExecute(r ApiIpamRolesBulkPartialUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRole
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	role *Role
}

func (r ApiIpamRolesBulkUpdateRequest) Role(role Role) ApiIpamRolesBulkUpdateRequest {
	r.role = &role
	return r
}

func (r ApiIpamRolesBulkUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesBulkUpdateExecute(r)
}

/*
IpamRolesBulkUpdate Method for IpamRolesBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesBulkUpdateRequest
*/
func (a *IpamApiService) IpamRolesBulkUpdate(ctx context.Context) ApiIpamRolesBulkUpdateRequest {
	return ApiIpamRolesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesBulkUpdateExecute(r ApiIpamRolesBulkUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.role == nil {
		return localVarReturnValue, nil, reportError("role is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.role
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	role *Role
}

func (r ApiIpamRolesCreateRequest) Role(role Role) ApiIpamRolesCreateRequest {
	r.role = &role
	return r
}

func (r ApiIpamRolesCreateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesCreateExecute(r)
}

/*
IpamRolesCreate Method for IpamRolesCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesCreateRequest
*/
func (a *IpamApiService) IpamRolesCreate(ctx context.Context) ApiIpamRolesCreateRequest {
	return ApiIpamRolesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesCreateExecute(r ApiIpamRolesCreateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.role == nil {
		return localVarReturnValue, nil, reportError("role is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.role
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamRolesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRolesDestroyExecute(r)
}

/*
IpamRolesDestroy Method for IpamRolesDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this role.
 @return ApiIpamRolesDestroyRequest
*/
func (a *IpamApiService) IpamRolesDestroy(ctx context.Context, id string) ApiIpamRolesDestroyRequest {
	return ApiIpamRolesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRolesDestroyExecute(r ApiIpamRolesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRolesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	slug *[]string
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIre *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNire *[]string
	slugNisw *[]string
	slugNre *[]string
	slugRe *[]string
}

func (r ApiIpamRolesListRequest) Created(created string) ApiIpamRolesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRolesListRequest) CreatedGte(createdGte string) ApiIpamRolesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRolesListRequest) CreatedLte(createdLte string) ApiIpamRolesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamRolesListRequest) Id(id []string) ApiIpamRolesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRolesListRequest) IdIc(idIc []string) ApiIpamRolesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamRolesListRequest) IdIe(idIe []string) ApiIpamRolesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamRolesListRequest) IdIew(idIew []string) ApiIpamRolesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamRolesListRequest) IdIre(idIre []string) ApiIpamRolesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamRolesListRequest) IdIsw(idIsw []string) ApiIpamRolesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamRolesListRequest) IdN(idN []string) ApiIpamRolesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRolesListRequest) IdNic(idNic []string) ApiIpamRolesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamRolesListRequest) IdNie(idNie []string) ApiIpamRolesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamRolesListRequest) IdNiew(idNiew []string) ApiIpamRolesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamRolesListRequest) IdNire(idNire []string) ApiIpamRolesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamRolesListRequest) IdNisw(idNisw []string) ApiIpamRolesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamRolesListRequest) IdNre(idNre []string) ApiIpamRolesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamRolesListRequest) IdRe(idRe []string) ApiIpamRolesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamRolesListRequest) LastUpdated(lastUpdated time.Time) ApiIpamRolesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRolesListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamRolesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamRolesListRequest) Limit(limit int32) ApiIpamRolesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRolesListRequest) Name(name []string) ApiIpamRolesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRolesListRequest) NameIc(nameIc []string) ApiIpamRolesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRolesListRequest) NameIe(nameIe []string) ApiIpamRolesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRolesListRequest) NameIew(nameIew []string) ApiIpamRolesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRolesListRequest) NameIre(nameIre []string) ApiIpamRolesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamRolesListRequest) NameIsw(nameIsw []string) ApiIpamRolesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRolesListRequest) NameN(nameN []string) ApiIpamRolesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRolesListRequest) NameNic(nameNic []string) ApiIpamRolesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRolesListRequest) NameNie(nameNie []string) ApiIpamRolesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRolesListRequest) NameNiew(nameNiew []string) ApiIpamRolesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRolesListRequest) NameNire(nameNire []string) ApiIpamRolesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamRolesListRequest) NameNisw(nameNisw []string) ApiIpamRolesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRolesListRequest) NameNre(nameNre []string) ApiIpamRolesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamRolesListRequest) NameRe(nameRe []string) ApiIpamRolesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRolesListRequest) Offset(offset int32) ApiIpamRolesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamRolesListRequest) Q(q string) ApiIpamRolesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRolesListRequest) Slug(slug []string) ApiIpamRolesListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamRolesListRequest) SlugIc(slugIc []string) ApiIpamRolesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamRolesListRequest) SlugIe(slugIe []string) ApiIpamRolesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamRolesListRequest) SlugIew(slugIew []string) ApiIpamRolesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamRolesListRequest) SlugIre(slugIre []string) ApiIpamRolesListRequest {
	r.slugIre = &slugIre
	return r
}

func (r ApiIpamRolesListRequest) SlugIsw(slugIsw []string) ApiIpamRolesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamRolesListRequest) SlugN(slugN []string) ApiIpamRolesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamRolesListRequest) SlugNic(slugNic []string) ApiIpamRolesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamRolesListRequest) SlugNie(slugNie []string) ApiIpamRolesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamRolesListRequest) SlugNiew(slugNiew []string) ApiIpamRolesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamRolesListRequest) SlugNire(slugNire []string) ApiIpamRolesListRequest {
	r.slugNire = &slugNire
	return r
}

func (r ApiIpamRolesListRequest) SlugNisw(slugNisw []string) ApiIpamRolesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamRolesListRequest) SlugNre(slugNre []string) ApiIpamRolesListRequest {
	r.slugNre = &slugNre
	return r
}

func (r ApiIpamRolesListRequest) SlugRe(slugRe []string) ApiIpamRolesListRequest {
	r.slugRe = &slugRe
	return r
}

func (r ApiIpamRolesListRequest) Execute() (*PaginatedRoleList, *http.Response, error) {
	return r.ApiService.IpamRolesListExecute(r)
}

/*
IpamRolesList Method for IpamRolesList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRolesListRequest
*/
func (a *IpamApiService) IpamRolesList(ctx context.Context) ApiIpamRolesListRequest {
	return ApiIpamRolesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRoleList
func (a *IpamApiService) IpamRolesListExecute(r ApiIpamRolesListRequest) (*PaginatedRoleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug", parameterToString(t, "multi"))
		}
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ic", parameterToString(t, "multi"))
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ie", parameterToString(t, "multi"))
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__iew", parameterToString(t, "multi"))
		}
	}
	if r.slugIre != nil {
		t := *r.slugIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ire", parameterToString(t, "multi"))
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__isw", parameterToString(t, "multi"))
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__n", parameterToString(t, "multi"))
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nic", parameterToString(t, "multi"))
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nie", parameterToString(t, "multi"))
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__niew", parameterToString(t, "multi"))
		}
	}
	if r.slugNire != nil {
		t := *r.slugNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nire", parameterToString(t, "multi"))
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nisw", parameterToString(t, "multi"))
		}
	}
	if r.slugNre != nil {
		t := *r.slugNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nre", parameterToString(t, "multi"))
		}
	}
	if r.slugRe != nil {
		t := *r.slugRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__re", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedRole *PatchedRole
}

func (r ApiIpamRolesPartialUpdateRequest) PatchedRole(patchedRole PatchedRole) ApiIpamRolesPartialUpdateRequest {
	r.patchedRole = &patchedRole
	return r
}

func (r ApiIpamRolesPartialUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesPartialUpdateExecute(r)
}

/*
IpamRolesPartialUpdate Method for IpamRolesPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this role.
 @return ApiIpamRolesPartialUpdateRequest
*/
func (a *IpamApiService) IpamRolesPartialUpdate(ctx context.Context, id string) ApiIpamRolesPartialUpdateRequest {
	return ApiIpamRolesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesPartialUpdateExecute(r ApiIpamRolesPartialUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedRole
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamRolesRetrieveRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesRetrieveExecute(r)
}

/*
IpamRolesRetrieve Method for IpamRolesRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this role.
 @return ApiIpamRolesRetrieveRequest
*/
func (a *IpamApiService) IpamRolesRetrieve(ctx context.Context, id string) ApiIpamRolesRetrieveRequest {
	return ApiIpamRolesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesRetrieveExecute(r ApiIpamRolesRetrieveRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRolesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	role *Role
}

func (r ApiIpamRolesUpdateRequest) Role(role Role) ApiIpamRolesUpdateRequest {
	r.role = &role
	return r
}

func (r ApiIpamRolesUpdateRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.IpamRolesUpdateExecute(r)
}

/*
IpamRolesUpdate Method for IpamRolesUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this role.
 @return ApiIpamRolesUpdateRequest
*/
func (a *IpamApiService) IpamRolesUpdate(ctx context.Context, id string) ApiIpamRolesUpdateRequest {
	return ApiIpamRolesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Role
func (a *IpamApiService) IpamRolesUpdateExecute(r ApiIpamRolesUpdateRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRolesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/roles/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.role == nil {
		return localVarReturnValue, nil, reportError("role is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.role
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamRouteTargetsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkDestroyExecute(r)
}

/*
IpamRouteTargetsBulkDestroy Method for IpamRouteTargetsBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkDestroyRequest
*/
func (a *IpamApiService) IpamRouteTargetsBulkDestroy(ctx context.Context) ApiIpamRouteTargetsBulkDestroyRequest {
	return ApiIpamRouteTargetsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRouteTargetsBulkDestroyExecute(r ApiIpamRouteTargetsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedWritableRouteTarget *PatchedWritableRouteTarget
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) PatchedWritableRouteTarget(patchedWritableRouteTarget PatchedWritableRouteTarget) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	r.patchedWritableRouteTarget = &patchedWritableRouteTarget
	return r
}

func (r ApiIpamRouteTargetsBulkPartialUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkPartialUpdateExecute(r)
}

/*
IpamRouteTargetsBulkPartialUpdate Method for IpamRouteTargetsBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsBulkPartialUpdate(ctx context.Context) ApiIpamRouteTargetsBulkPartialUpdateRequest {
	return ApiIpamRouteTargetsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsBulkPartialUpdateExecute(r ApiIpamRouteTargetsBulkPartialUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableRouteTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableRouteTarget *WritableRouteTarget
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) WritableRouteTarget(writableRouteTarget WritableRouteTarget) ApiIpamRouteTargetsBulkUpdateRequest {
	r.writableRouteTarget = &writableRouteTarget
	return r
}

func (r ApiIpamRouteTargetsBulkUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsBulkUpdateExecute(r)
}

/*
IpamRouteTargetsBulkUpdate Method for IpamRouteTargetsBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsBulkUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsBulkUpdate(ctx context.Context) ApiIpamRouteTargetsBulkUpdateRequest {
	return ApiIpamRouteTargetsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsBulkUpdateExecute(r ApiIpamRouteTargetsBulkUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRouteTarget == nil {
		return localVarReturnValue, nil, reportError("writableRouteTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRouteTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableRouteTarget *WritableRouteTarget
}

func (r ApiIpamRouteTargetsCreateRequest) WritableRouteTarget(writableRouteTarget WritableRouteTarget) ApiIpamRouteTargetsCreateRequest {
	r.writableRouteTarget = &writableRouteTarget
	return r
}

func (r ApiIpamRouteTargetsCreateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsCreateExecute(r)
}

/*
IpamRouteTargetsCreate Method for IpamRouteTargetsCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsCreateRequest
*/
func (a *IpamApiService) IpamRouteTargetsCreate(ctx context.Context) ApiIpamRouteTargetsCreateRequest {
	return ApiIpamRouteTargetsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsCreateExecute(r ApiIpamRouteTargetsCreateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRouteTarget == nil {
		return localVarReturnValue, nil, reportError("writableRouteTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRouteTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamRouteTargetsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamRouteTargetsDestroyExecute(r)
}

/*
IpamRouteTargetsDestroy Method for IpamRouteTargetsDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsDestroyRequest
*/
func (a *IpamApiService) IpamRouteTargetsDestroy(ctx context.Context, id string) ApiIpamRouteTargetsDestroyRequest {
	return ApiIpamRouteTargetsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamRouteTargetsDestroyExecute(r ApiIpamRouteTargetsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	exportingVrf *[]*string
	exportingVrfN *[]*string
	exportingVrfId *[]string
	exportingVrfIdN *[]string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	importingVrf *[]*string
	importingVrfN *[]*string
	importingVrfId *[]string
	importingVrfIdN *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
}

func (r ApiIpamRouteTargetsListRequest) Created(created string) ApiIpamRouteTargetsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedGte(createdGte string) ApiIpamRouteTargetsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) CreatedLte(createdLte string) ApiIpamRouteTargetsListRequest {
	r.createdLte = &createdLte
	return r
}

// Export VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ExportingVrf(exportingVrf []*string) ApiIpamRouteTargetsListRequest {
	r.exportingVrf = &exportingVrf
	return r
}

// Export VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ExportingVrfN(exportingVrfN []*string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfN = &exportingVrfN
	return r
}

// Exporting VRF
func (r ApiIpamRouteTargetsListRequest) ExportingVrfId(exportingVrfId []string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfId = &exportingVrfId
	return r
}

// Exporting VRF
func (r ApiIpamRouteTargetsListRequest) ExportingVrfIdN(exportingVrfIdN []string) ApiIpamRouteTargetsListRequest {
	r.exportingVrfIdN = &exportingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Id(id []string) ApiIpamRouteTargetsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIc(idIc []string) ApiIpamRouteTargetsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIe(idIe []string) ApiIpamRouteTargetsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIew(idIew []string) ApiIpamRouteTargetsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIre(idIre []string) ApiIpamRouteTargetsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdIsw(idIsw []string) ApiIpamRouteTargetsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdN(idN []string) ApiIpamRouteTargetsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNic(idNic []string) ApiIpamRouteTargetsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNie(idNie []string) ApiIpamRouteTargetsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNiew(idNiew []string) ApiIpamRouteTargetsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNire(idNire []string) ApiIpamRouteTargetsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNisw(idNisw []string) ApiIpamRouteTargetsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdNre(idNre []string) ApiIpamRouteTargetsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamRouteTargetsListRequest) IdRe(idRe []string) ApiIpamRouteTargetsListRequest {
	r.idRe = &idRe
	return r
}

// Import VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ImportingVrf(importingVrf []*string) ApiIpamRouteTargetsListRequest {
	r.importingVrf = &importingVrf
	return r
}

// Import VRF (RD)
func (r ApiIpamRouteTargetsListRequest) ImportingVrfN(importingVrfN []*string) ApiIpamRouteTargetsListRequest {
	r.importingVrfN = &importingVrfN
	return r
}

// Importing VRF
func (r ApiIpamRouteTargetsListRequest) ImportingVrfId(importingVrfId []string) ApiIpamRouteTargetsListRequest {
	r.importingVrfId = &importingVrfId
	return r
}

// Importing VRF
func (r ApiIpamRouteTargetsListRequest) ImportingVrfIdN(importingVrfIdN []string) ApiIpamRouteTargetsListRequest {
	r.importingVrfIdN = &importingVrfIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdated(lastUpdated time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamRouteTargetsListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamRouteTargetsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamRouteTargetsListRequest) Limit(limit int32) ApiIpamRouteTargetsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamRouteTargetsListRequest) Name(name []string) ApiIpamRouteTargetsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIc(nameIc []string) ApiIpamRouteTargetsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIe(nameIe []string) ApiIpamRouteTargetsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIew(nameIew []string) ApiIpamRouteTargetsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIre(nameIre []string) ApiIpamRouteTargetsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameIsw(nameIsw []string) ApiIpamRouteTargetsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameN(nameN []string) ApiIpamRouteTargetsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNic(nameNic []string) ApiIpamRouteTargetsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNie(nameNie []string) ApiIpamRouteTargetsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNiew(nameNiew []string) ApiIpamRouteTargetsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNire(nameNire []string) ApiIpamRouteTargetsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNisw(nameNisw []string) ApiIpamRouteTargetsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameNre(nameNre []string) ApiIpamRouteTargetsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamRouteTargetsListRequest) NameRe(nameRe []string) ApiIpamRouteTargetsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamRouteTargetsListRequest) Offset(offset int32) ApiIpamRouteTargetsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamRouteTargetsListRequest) Q(q string) ApiIpamRouteTargetsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamRouteTargetsListRequest) Tag(tag []string) ApiIpamRouteTargetsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamRouteTargetsListRequest) TagN(tagN []string) ApiIpamRouteTargetsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamRouteTargetsListRequest) Tenant(tenant []string) ApiIpamRouteTargetsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamRouteTargetsListRequest) TenantN(tenantN []string) ApiIpamRouteTargetsListRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamRouteTargetsListRequest) TenantGroup(tenantGroup []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamRouteTargetsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamRouteTargetsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamRouteTargetsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamRouteTargetsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamRouteTargetsListRequest) TenantId(tenantId []*string) ApiIpamRouteTargetsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamRouteTargetsListRequest) TenantIdN(tenantIdN []*string) ApiIpamRouteTargetsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamRouteTargetsListRequest) Execute() (*PaginatedRouteTargetList, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsListExecute(r)
}

/*
IpamRouteTargetsList Method for IpamRouteTargetsList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamRouteTargetsListRequest
*/
func (a *IpamApiService) IpamRouteTargetsList(ctx context.Context) ApiIpamRouteTargetsListRequest {
	return ApiIpamRouteTargetsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRouteTargetList
func (a *IpamApiService) IpamRouteTargetsListExecute(r ApiIpamRouteTargetsListRequest) (*PaginatedRouteTargetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRouteTargetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.exportingVrf != nil {
		t := *r.exportingVrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exporting_vrf", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exporting_vrf", parameterToString(t, "multi"))
		}
	}
	if r.exportingVrfN != nil {
		t := *r.exportingVrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exporting_vrf__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exporting_vrf__n", parameterToString(t, "multi"))
		}
	}
	if r.exportingVrfId != nil {
		t := *r.exportingVrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exporting_vrf_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exporting_vrf_id", parameterToString(t, "multi"))
		}
	}
	if r.exportingVrfIdN != nil {
		t := *r.exportingVrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("exporting_vrf_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("exporting_vrf_id__n", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.importingVrf != nil {
		t := *r.importingVrf
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("importing_vrf", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("importing_vrf", parameterToString(t, "multi"))
		}
	}
	if r.importingVrfN != nil {
		t := *r.importingVrfN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("importing_vrf__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("importing_vrf__n", parameterToString(t, "multi"))
		}
	}
	if r.importingVrfId != nil {
		t := *r.importingVrfId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("importing_vrf_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("importing_vrf_id", parameterToString(t, "multi"))
		}
	}
	if r.importingVrfIdN != nil {
		t := *r.importingVrfIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("importing_vrf_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("importing_vrf_id__n", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritableRouteTarget *PatchedWritableRouteTarget
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) PatchedWritableRouteTarget(patchedWritableRouteTarget PatchedWritableRouteTarget) ApiIpamRouteTargetsPartialUpdateRequest {
	r.patchedWritableRouteTarget = &patchedWritableRouteTarget
	return r
}

func (r ApiIpamRouteTargetsPartialUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsPartialUpdateExecute(r)
}

/*
IpamRouteTargetsPartialUpdate Method for IpamRouteTargetsPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsPartialUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsPartialUpdate(ctx context.Context, id string) ApiIpamRouteTargetsPartialUpdateRequest {
	return ApiIpamRouteTargetsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsPartialUpdateExecute(r ApiIpamRouteTargetsPartialUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableRouteTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamRouteTargetsRetrieveRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsRetrieveExecute(r)
}

/*
IpamRouteTargetsRetrieve Method for IpamRouteTargetsRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsRetrieveRequest
*/
func (a *IpamApiService) IpamRouteTargetsRetrieve(ctx context.Context, id string) ApiIpamRouteTargetsRetrieveRequest {
	return ApiIpamRouteTargetsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsRetrieveExecute(r ApiIpamRouteTargetsRetrieveRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamRouteTargetsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writableRouteTarget *WritableRouteTarget
}

func (r ApiIpamRouteTargetsUpdateRequest) WritableRouteTarget(writableRouteTarget WritableRouteTarget) ApiIpamRouteTargetsUpdateRequest {
	r.writableRouteTarget = &writableRouteTarget
	return r
}

func (r ApiIpamRouteTargetsUpdateRequest) Execute() (*RouteTarget, *http.Response, error) {
	return r.ApiService.IpamRouteTargetsUpdateExecute(r)
}

/*
IpamRouteTargetsUpdate Method for IpamRouteTargetsUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this route target.
 @return ApiIpamRouteTargetsUpdateRequest
*/
func (a *IpamApiService) IpamRouteTargetsUpdate(ctx context.Context, id string) ApiIpamRouteTargetsUpdateRequest {
	return ApiIpamRouteTargetsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RouteTarget
func (a *IpamApiService) IpamRouteTargetsUpdateExecute(r ApiIpamRouteTargetsUpdateRequest) (*RouteTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamRouteTargetsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/route-targets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableRouteTarget == nil {
		return localVarReturnValue, nil, reportError("writableRouteTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableRouteTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamServicesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesBulkDestroyExecute(r)
}

/*
IpamServicesBulkDestroy Method for IpamServicesBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkDestroyRequest
*/
func (a *IpamApiService) IpamServicesBulkDestroy(ctx context.Context) ApiIpamServicesBulkDestroyRequest {
	return ApiIpamServicesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamServicesBulkDestroyExecute(r ApiIpamServicesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedWritableService *PatchedWritableService
}

func (r ApiIpamServicesBulkPartialUpdateRequest) PatchedWritableService(patchedWritableService PatchedWritableService) ApiIpamServicesBulkPartialUpdateRequest {
	r.patchedWritableService = &patchedWritableService
	return r
}

func (r ApiIpamServicesBulkPartialUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkPartialUpdateExecute(r)
}

/*
IpamServicesBulkPartialUpdate Method for IpamServicesBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamServicesBulkPartialUpdate(ctx context.Context) ApiIpamServicesBulkPartialUpdateRequest {
	return ApiIpamServicesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesBulkPartialUpdateExecute(r ApiIpamServicesBulkPartialUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableService
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableService *WritableService
}

func (r ApiIpamServicesBulkUpdateRequest) WritableService(writableService WritableService) ApiIpamServicesBulkUpdateRequest {
	r.writableService = &writableService
	return r
}

func (r ApiIpamServicesBulkUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesBulkUpdateExecute(r)
}

/*
IpamServicesBulkUpdate Method for IpamServicesBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesBulkUpdateRequest
*/
func (a *IpamApiService) IpamServicesBulkUpdate(ctx context.Context) ApiIpamServicesBulkUpdateRequest {
	return ApiIpamServicesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesBulkUpdateExecute(r ApiIpamServicesBulkUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableService == nil {
		return localVarReturnValue, nil, reportError("writableService is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableService
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableService *WritableService
}

func (r ApiIpamServicesCreateRequest) WritableService(writableService WritableService) ApiIpamServicesCreateRequest {
	r.writableService = &writableService
	return r
}

func (r ApiIpamServicesCreateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesCreateExecute(r)
}

/*
IpamServicesCreate Method for IpamServicesCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesCreateRequest
*/
func (a *IpamApiService) IpamServicesCreate(ctx context.Context) ApiIpamServicesCreateRequest {
	return ApiIpamServicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesCreateExecute(r ApiIpamServicesCreateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableService == nil {
		return localVarReturnValue, nil, reportError("writableService is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableService
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamServicesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamServicesDestroyExecute(r)
}

/*
IpamServicesDestroy Method for IpamServicesDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesDestroyRequest
*/
func (a *IpamApiService) IpamServicesDestroy(ctx context.Context, id string) ApiIpamServicesDestroyRequest {
	return ApiIpamServicesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamServicesDestroyExecute(r ApiIpamServicesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamServicesListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	device *[]*string
	deviceN *[]*string
	deviceId *[]*string
	deviceIdN *[]*string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	port *float32
	protocol *string
	protocolN *string
	q *string
	tag *[]string
	tagN *[]string
	virtualMachine *[]string
	virtualMachineN *[]string
	virtualMachineId *[]*string
	virtualMachineIdN *[]*string
}

func (r ApiIpamServicesListRequest) Created(created string) ApiIpamServicesListRequest {
	r.created = &created
	return r
}

func (r ApiIpamServicesListRequest) CreatedGte(createdGte string) ApiIpamServicesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamServicesListRequest) CreatedLte(createdLte string) ApiIpamServicesListRequest {
	r.createdLte = &createdLte
	return r
}

// Device (name)
func (r ApiIpamServicesListRequest) Device(device []*string) ApiIpamServicesListRequest {
	r.device = &device
	return r
}

// Device (name)
func (r ApiIpamServicesListRequest) DeviceN(deviceN []*string) ApiIpamServicesListRequest {
	r.deviceN = &deviceN
	return r
}

// Device (ID)
func (r ApiIpamServicesListRequest) DeviceId(deviceId []*string) ApiIpamServicesListRequest {
	r.deviceId = &deviceId
	return r
}

// Device (ID)
func (r ApiIpamServicesListRequest) DeviceIdN(deviceIdN []*string) ApiIpamServicesListRequest {
	r.deviceIdN = &deviceIdN
	return r
}

func (r ApiIpamServicesListRequest) Id(id []string) ApiIpamServicesListRequest {
	r.id = &id
	return r
}

func (r ApiIpamServicesListRequest) IdIc(idIc []string) ApiIpamServicesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamServicesListRequest) IdIe(idIe []string) ApiIpamServicesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamServicesListRequest) IdIew(idIew []string) ApiIpamServicesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamServicesListRequest) IdIre(idIre []string) ApiIpamServicesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamServicesListRequest) IdIsw(idIsw []string) ApiIpamServicesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamServicesListRequest) IdN(idN []string) ApiIpamServicesListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamServicesListRequest) IdNic(idNic []string) ApiIpamServicesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamServicesListRequest) IdNie(idNie []string) ApiIpamServicesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamServicesListRequest) IdNiew(idNiew []string) ApiIpamServicesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamServicesListRequest) IdNire(idNire []string) ApiIpamServicesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamServicesListRequest) IdNisw(idNisw []string) ApiIpamServicesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamServicesListRequest) IdNre(idNre []string) ApiIpamServicesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamServicesListRequest) IdRe(idRe []string) ApiIpamServicesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamServicesListRequest) LastUpdated(lastUpdated time.Time) ApiIpamServicesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamServicesListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamServicesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamServicesListRequest) Limit(limit int32) ApiIpamServicesListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamServicesListRequest) Name(name []string) ApiIpamServicesListRequest {
	r.name = &name
	return r
}

func (r ApiIpamServicesListRequest) NameIc(nameIc []string) ApiIpamServicesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamServicesListRequest) NameIe(nameIe []string) ApiIpamServicesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamServicesListRequest) NameIew(nameIew []string) ApiIpamServicesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamServicesListRequest) NameIre(nameIre []string) ApiIpamServicesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamServicesListRequest) NameIsw(nameIsw []string) ApiIpamServicesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamServicesListRequest) NameN(nameN []string) ApiIpamServicesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamServicesListRequest) NameNic(nameNic []string) ApiIpamServicesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamServicesListRequest) NameNie(nameNie []string) ApiIpamServicesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamServicesListRequest) NameNiew(nameNiew []string) ApiIpamServicesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamServicesListRequest) NameNire(nameNire []string) ApiIpamServicesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamServicesListRequest) NameNisw(nameNisw []string) ApiIpamServicesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamServicesListRequest) NameNre(nameNre []string) ApiIpamServicesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamServicesListRequest) NameRe(nameRe []string) ApiIpamServicesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamServicesListRequest) Offset(offset int32) ApiIpamServicesListRequest {
	r.offset = &offset
	return r
}

func (r ApiIpamServicesListRequest) Port(port float32) ApiIpamServicesListRequest {
	r.port = &port
	return r
}

func (r ApiIpamServicesListRequest) Protocol(protocol string) ApiIpamServicesListRequest {
	r.protocol = &protocol
	return r
}

func (r ApiIpamServicesListRequest) ProtocolN(protocolN string) ApiIpamServicesListRequest {
	r.protocolN = &protocolN
	return r
}

// Search
func (r ApiIpamServicesListRequest) Q(q string) ApiIpamServicesListRequest {
	r.q = &q
	return r
}

func (r ApiIpamServicesListRequest) Tag(tag []string) ApiIpamServicesListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamServicesListRequest) TagN(tagN []string) ApiIpamServicesListRequest {
	r.tagN = &tagN
	return r
}

// Virtual machine (name)
func (r ApiIpamServicesListRequest) VirtualMachine(virtualMachine []string) ApiIpamServicesListRequest {
	r.virtualMachine = &virtualMachine
	return r
}

// Virtual machine (name)
func (r ApiIpamServicesListRequest) VirtualMachineN(virtualMachineN []string) ApiIpamServicesListRequest {
	r.virtualMachineN = &virtualMachineN
	return r
}

// Virtual machine (ID)
func (r ApiIpamServicesListRequest) VirtualMachineId(virtualMachineId []*string) ApiIpamServicesListRequest {
	r.virtualMachineId = &virtualMachineId
	return r
}

// Virtual machine (ID)
func (r ApiIpamServicesListRequest) VirtualMachineIdN(virtualMachineIdN []*string) ApiIpamServicesListRequest {
	r.virtualMachineIdN = &virtualMachineIdN
	return r
}

func (r ApiIpamServicesListRequest) Execute() (*PaginatedServiceList, *http.Response, error) {
	return r.ApiService.IpamServicesListExecute(r)
}

/*
IpamServicesList Method for IpamServicesList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamServicesListRequest
*/
func (a *IpamApiService) IpamServicesList(ctx context.Context) ApiIpamServicesListRequest {
	return ApiIpamServicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedServiceList
func (a *IpamApiService) IpamServicesListExecute(r ApiIpamServicesListRequest) (*PaginatedServiceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedServiceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.device != nil {
		t := *r.device
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device", parameterToString(t, "multi"))
		}
	}
	if r.deviceN != nil {
		t := *r.deviceN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device__n", parameterToString(t, "multi"))
		}
	}
	if r.deviceId != nil {
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device_id", parameterToString(t, "multi"))
		}
	}
	if r.deviceIdN != nil {
		t := *r.deviceIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("device_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("device_id__n", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.port != nil {
		localVarQueryParams.Add("port", parameterToString(*r.port, ""))
	}
	if r.protocol != nil {
		localVarQueryParams.Add("protocol", parameterToString(*r.protocol, ""))
	}
	if r.protocolN != nil {
		localVarQueryParams.Add("protocol__n", parameterToString(*r.protocolN, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachine != nil {
		t := *r.virtualMachine
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachineN != nil {
		t := *r.virtualMachineN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine__n", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachineId != nil {
		t := *r.virtualMachineId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine_id", parameterToString(t, "multi"))
		}
	}
	if r.virtualMachineIdN != nil {
		t := *r.virtualMachineIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("virtual_machine_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("virtual_machine_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritableService *PatchedWritableService
}

func (r ApiIpamServicesPartialUpdateRequest) PatchedWritableService(patchedWritableService PatchedWritableService) ApiIpamServicesPartialUpdateRequest {
	r.patchedWritableService = &patchedWritableService
	return r
}

func (r ApiIpamServicesPartialUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesPartialUpdateExecute(r)
}

/*
IpamServicesPartialUpdate Method for IpamServicesPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesPartialUpdateRequest
*/
func (a *IpamApiService) IpamServicesPartialUpdate(ctx context.Context, id string) ApiIpamServicesPartialUpdateRequest {
	return ApiIpamServicesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesPartialUpdateExecute(r ApiIpamServicesPartialUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableService
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamServicesRetrieveRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesRetrieveExecute(r)
}

/*
IpamServicesRetrieve Method for IpamServicesRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesRetrieveRequest
*/
func (a *IpamApiService) IpamServicesRetrieve(ctx context.Context, id string) ApiIpamServicesRetrieveRequest {
	return ApiIpamServicesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesRetrieveExecute(r ApiIpamServicesRetrieveRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamServicesUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writableService *WritableService
}

func (r ApiIpamServicesUpdateRequest) WritableService(writableService WritableService) ApiIpamServicesUpdateRequest {
	r.writableService = &writableService
	return r
}

func (r ApiIpamServicesUpdateRequest) Execute() (*Service, *http.Response, error) {
	return r.ApiService.IpamServicesUpdateExecute(r)
}

/*
IpamServicesUpdate Method for IpamServicesUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this service.
 @return ApiIpamServicesUpdateRequest
*/
func (a *IpamApiService) IpamServicesUpdate(ctx context.Context, id string) ApiIpamServicesUpdateRequest {
	return ApiIpamServicesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Service
func (a *IpamApiService) IpamServicesUpdateExecute(r ApiIpamServicesUpdateRequest) (*Service, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Service
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamServicesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableService == nil {
		return localVarReturnValue, nil, reportError("writableService is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableService
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamVlanGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkDestroyExecute(r)
}

/*
IpamVlanGroupsBulkDestroy Method for IpamVlanGroupsBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkDestroyRequest
*/
func (a *IpamApiService) IpamVlanGroupsBulkDestroy(ctx context.Context) ApiIpamVlanGroupsBulkDestroyRequest {
	return ApiIpamVlanGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlanGroupsBulkDestroyExecute(r ApiIpamVlanGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedWritableVLANGroup *PatchedWritableVLANGroup
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) PatchedWritableVLANGroup(patchedWritableVLANGroup PatchedWritableVLANGroup) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	r.patchedWritableVLANGroup = &patchedWritableVLANGroup
	return r
}

func (r ApiIpamVlanGroupsBulkPartialUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkPartialUpdateExecute(r)
}

/*
IpamVlanGroupsBulkPartialUpdate Method for IpamVlanGroupsBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsBulkPartialUpdate(ctx context.Context) ApiIpamVlanGroupsBulkPartialUpdateRequest {
	return ApiIpamVlanGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsBulkPartialUpdateExecute(r ApiIpamVlanGroupsBulkPartialUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVLANGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableVLANGroup *WritableVLANGroup
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) WritableVLANGroup(writableVLANGroup WritableVLANGroup) ApiIpamVlanGroupsBulkUpdateRequest {
	r.writableVLANGroup = &writableVLANGroup
	return r
}

func (r ApiIpamVlanGroupsBulkUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsBulkUpdateExecute(r)
}

/*
IpamVlanGroupsBulkUpdate Method for IpamVlanGroupsBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsBulkUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsBulkUpdate(ctx context.Context) ApiIpamVlanGroupsBulkUpdateRequest {
	return ApiIpamVlanGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsBulkUpdateExecute(r ApiIpamVlanGroupsBulkUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLANGroup == nil {
		return localVarReturnValue, nil, reportError("writableVLANGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLANGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableVLANGroup *WritableVLANGroup
}

func (r ApiIpamVlanGroupsCreateRequest) WritableVLANGroup(writableVLANGroup WritableVLANGroup) ApiIpamVlanGroupsCreateRequest {
	r.writableVLANGroup = &writableVLANGroup
	return r
}

func (r ApiIpamVlanGroupsCreateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsCreateExecute(r)
}

/*
IpamVlanGroupsCreate Method for IpamVlanGroupsCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsCreateRequest
*/
func (a *IpamApiService) IpamVlanGroupsCreate(ctx context.Context) ApiIpamVlanGroupsCreateRequest {
	return ApiIpamVlanGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsCreateExecute(r ApiIpamVlanGroupsCreateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLANGroup == nil {
		return localVarReturnValue, nil, reportError("writableVLANGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLANGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamVlanGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlanGroupsDestroyExecute(r)
}

/*
IpamVlanGroupsDestroy Method for IpamVlanGroupsDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsDestroyRequest
*/
func (a *IpamApiService) IpamVlanGroupsDestroy(ctx context.Context, id string) ApiIpamVlanGroupsDestroyRequest {
	return ApiIpamVlanGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlanGroupsDestroyExecute(r ApiIpamVlanGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	description *[]string
	descriptionIc *[]string
	descriptionIe *[]string
	descriptionIew *[]string
	descriptionIre *[]string
	descriptionIsw *[]string
	descriptionN *[]string
	descriptionNic *[]string
	descriptionNie *[]string
	descriptionNiew *[]string
	descriptionNire *[]string
	descriptionNisw *[]string
	descriptionNre *[]string
	descriptionRe *[]string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	region *[]string
	regionN *[]string
	regionId *[]string
	regionIdN *[]string
	site *[]string
	siteN *[]string
	siteId *[]*string
	siteIdN *[]*string
	slug *[]string
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIre *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNire *[]string
	slugNisw *[]string
	slugNre *[]string
	slugRe *[]string
}

func (r ApiIpamVlanGroupsListRequest) Created(created string) ApiIpamVlanGroupsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedGte(createdGte string) ApiIpamVlanGroupsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) CreatedLte(createdLte string) ApiIpamVlanGroupsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVlanGroupsListRequest) Description(description []string) ApiIpamVlanGroupsListRequest {
	r.description = &description
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIc(descriptionIc []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIc = &descriptionIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIe(descriptionIe []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIe = &descriptionIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIew(descriptionIew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIew = &descriptionIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIre(descriptionIre []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIre = &descriptionIre
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionIsw(descriptionIsw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionIsw = &descriptionIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionN(descriptionN []string) ApiIpamVlanGroupsListRequest {
	r.descriptionN = &descriptionN
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNic(descriptionNic []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNic = &descriptionNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNie(descriptionNie []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNie = &descriptionNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNiew(descriptionNiew []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNiew = &descriptionNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNire(descriptionNire []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNire = &descriptionNire
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNisw(descriptionNisw []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNisw = &descriptionNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionNre(descriptionNre []string) ApiIpamVlanGroupsListRequest {
	r.descriptionNre = &descriptionNre
	return r
}

func (r ApiIpamVlanGroupsListRequest) DescriptionRe(descriptionRe []string) ApiIpamVlanGroupsListRequest {
	r.descriptionRe = &descriptionRe
	return r
}

func (r ApiIpamVlanGroupsListRequest) Id(id []string) ApiIpamVlanGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIc(idIc []string) ApiIpamVlanGroupsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIe(idIe []string) ApiIpamVlanGroupsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIew(idIew []string) ApiIpamVlanGroupsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIre(idIre []string) ApiIpamVlanGroupsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdIsw(idIsw []string) ApiIpamVlanGroupsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdN(idN []string) ApiIpamVlanGroupsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNic(idNic []string) ApiIpamVlanGroupsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNie(idNie []string) ApiIpamVlanGroupsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNiew(idNiew []string) ApiIpamVlanGroupsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNire(idNire []string) ApiIpamVlanGroupsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNisw(idNisw []string) ApiIpamVlanGroupsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdNre(idNre []string) ApiIpamVlanGroupsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVlanGroupsListRequest) IdRe(idRe []string) ApiIpamVlanGroupsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdated(lastUpdated time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlanGroupsListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamVlanGroupsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamVlanGroupsListRequest) Limit(limit int32) ApiIpamVlanGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlanGroupsListRequest) Name(name []string) ApiIpamVlanGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIc(nameIc []string) ApiIpamVlanGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIe(nameIe []string) ApiIpamVlanGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIew(nameIew []string) ApiIpamVlanGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIre(nameIre []string) ApiIpamVlanGroupsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameIsw(nameIsw []string) ApiIpamVlanGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameN(nameN []string) ApiIpamVlanGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNic(nameNic []string) ApiIpamVlanGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNie(nameNie []string) ApiIpamVlanGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNiew(nameNiew []string) ApiIpamVlanGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNire(nameNire []string) ApiIpamVlanGroupsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNisw(nameNisw []string) ApiIpamVlanGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameNre(nameNre []string) ApiIpamVlanGroupsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamVlanGroupsListRequest) NameRe(nameRe []string) ApiIpamVlanGroupsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlanGroupsListRequest) Offset(offset int32) ApiIpamVlanGroupsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamVlanGroupsListRequest) Q(q string) ApiIpamVlanGroupsListRequest {
	r.q = &q
	return r
}

// Region (slug)
func (r ApiIpamVlanGroupsListRequest) Region(region []string) ApiIpamVlanGroupsListRequest {
	r.region = &region
	return r
}

// Region (slug)
func (r ApiIpamVlanGroupsListRequest) RegionN(regionN []string) ApiIpamVlanGroupsListRequest {
	r.regionN = &regionN
	return r
}

// Region (ID)
func (r ApiIpamVlanGroupsListRequest) RegionId(regionId []string) ApiIpamVlanGroupsListRequest {
	r.regionId = &regionId
	return r
}

// Region (ID)
func (r ApiIpamVlanGroupsListRequest) RegionIdN(regionIdN []string) ApiIpamVlanGroupsListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Site (slug)
func (r ApiIpamVlanGroupsListRequest) Site(site []string) ApiIpamVlanGroupsListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamVlanGroupsListRequest) SiteN(siteN []string) ApiIpamVlanGroupsListRequest {
	r.siteN = &siteN
	return r
}

// Site (ID)
func (r ApiIpamVlanGroupsListRequest) SiteId(siteId []*string) ApiIpamVlanGroupsListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamVlanGroupsListRequest) SiteIdN(siteIdN []*string) ApiIpamVlanGroupsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiIpamVlanGroupsListRequest) Slug(slug []string) ApiIpamVlanGroupsListRequest {
	r.slug = &slug
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIc(slugIc []string) ApiIpamVlanGroupsListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIe(slugIe []string) ApiIpamVlanGroupsListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIew(slugIew []string) ApiIpamVlanGroupsListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIre(slugIre []string) ApiIpamVlanGroupsListRequest {
	r.slugIre = &slugIre
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugIsw(slugIsw []string) ApiIpamVlanGroupsListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugN(slugN []string) ApiIpamVlanGroupsListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNic(slugNic []string) ApiIpamVlanGroupsListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNie(slugNie []string) ApiIpamVlanGroupsListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNiew(slugNiew []string) ApiIpamVlanGroupsListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNire(slugNire []string) ApiIpamVlanGroupsListRequest {
	r.slugNire = &slugNire
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNisw(slugNisw []string) ApiIpamVlanGroupsListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugNre(slugNre []string) ApiIpamVlanGroupsListRequest {
	r.slugNre = &slugNre
	return r
}

func (r ApiIpamVlanGroupsListRequest) SlugRe(slugRe []string) ApiIpamVlanGroupsListRequest {
	r.slugRe = &slugRe
	return r
}

func (r ApiIpamVlanGroupsListRequest) Execute() (*PaginatedVLANGroupList, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsListExecute(r)
}

/*
IpamVlanGroupsList Method for IpamVlanGroupsList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlanGroupsListRequest
*/
func (a *IpamApiService) IpamVlanGroupsList(ctx context.Context) ApiIpamVlanGroupsListRequest {
	return ApiIpamVlanGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANGroupList
func (a *IpamApiService) IpamVlanGroupsListExecute(r ApiIpamVlanGroupsListRequest) (*PaginatedVLANGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.description != nil {
		t := *r.description
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIc != nil {
		t := *r.descriptionIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__ic", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIe != nil {
		t := *r.descriptionIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__ie", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIew != nil {
		t := *r.descriptionIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__iew", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIre != nil {
		t := *r.descriptionIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__ire", parameterToString(t, "multi"))
		}
	}
	if r.descriptionIsw != nil {
		t := *r.descriptionIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__isw", parameterToString(t, "multi"))
		}
	}
	if r.descriptionN != nil {
		t := *r.descriptionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__n", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNic != nil {
		t := *r.descriptionNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nic", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNie != nil {
		t := *r.descriptionNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nie", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNiew != nil {
		t := *r.descriptionNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__niew", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNire != nil {
		t := *r.descriptionNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nire", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNisw != nil {
		t := *r.descriptionNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nisw", parameterToString(t, "multi"))
		}
	}
	if r.descriptionNre != nil {
		t := *r.descriptionNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__nre", parameterToString(t, "multi"))
		}
	}
	if r.descriptionRe != nil {
		t := *r.descriptionRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("description__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("description__re", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region", parameterToString(t, "multi"))
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region__n", parameterToString(t, "multi"))
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id", parameterToString(t, "multi"))
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id__n", parameterToString(t, "multi"))
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site", parameterToString(t, "multi"))
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site__n", parameterToString(t, "multi"))
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id", parameterToString(t, "multi"))
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id__n", parameterToString(t, "multi"))
		}
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug", parameterToString(t, "multi"))
		}
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ic", parameterToString(t, "multi"))
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ie", parameterToString(t, "multi"))
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__iew", parameterToString(t, "multi"))
		}
	}
	if r.slugIre != nil {
		t := *r.slugIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ire", parameterToString(t, "multi"))
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__isw", parameterToString(t, "multi"))
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__n", parameterToString(t, "multi"))
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nic", parameterToString(t, "multi"))
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nie", parameterToString(t, "multi"))
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__niew", parameterToString(t, "multi"))
		}
	}
	if r.slugNire != nil {
		t := *r.slugNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nire", parameterToString(t, "multi"))
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nisw", parameterToString(t, "multi"))
		}
	}
	if r.slugNre != nil {
		t := *r.slugNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nre", parameterToString(t, "multi"))
		}
	}
	if r.slugRe != nil {
		t := *r.slugRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__re", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritableVLANGroup *PatchedWritableVLANGroup
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) PatchedWritableVLANGroup(patchedWritableVLANGroup PatchedWritableVLANGroup) ApiIpamVlanGroupsPartialUpdateRequest {
	r.patchedWritableVLANGroup = &patchedWritableVLANGroup
	return r
}

func (r ApiIpamVlanGroupsPartialUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsPartialUpdateExecute(r)
}

/*
IpamVlanGroupsPartialUpdate Method for IpamVlanGroupsPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsPartialUpdate(ctx context.Context, id string) ApiIpamVlanGroupsPartialUpdateRequest {
	return ApiIpamVlanGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsPartialUpdateExecute(r ApiIpamVlanGroupsPartialUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVLANGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamVlanGroupsRetrieveRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsRetrieveExecute(r)
}

/*
IpamVlanGroupsRetrieve Method for IpamVlanGroupsRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsRetrieveRequest
*/
func (a *IpamApiService) IpamVlanGroupsRetrieve(ctx context.Context, id string) ApiIpamVlanGroupsRetrieveRequest {
	return ApiIpamVlanGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsRetrieveExecute(r ApiIpamVlanGroupsRetrieveRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlanGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writableVLANGroup *WritableVLANGroup
}

func (r ApiIpamVlanGroupsUpdateRequest) WritableVLANGroup(writableVLANGroup WritableVLANGroup) ApiIpamVlanGroupsUpdateRequest {
	r.writableVLANGroup = &writableVLANGroup
	return r
}

func (r ApiIpamVlanGroupsUpdateRequest) Execute() (*VLANGroup, *http.Response, error) {
	return r.ApiService.IpamVlanGroupsUpdateExecute(r)
}

/*
IpamVlanGroupsUpdate Method for IpamVlanGroupsUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN group.
 @return ApiIpamVlanGroupsUpdateRequest
*/
func (a *IpamApiService) IpamVlanGroupsUpdate(ctx context.Context, id string) ApiIpamVlanGroupsUpdateRequest {
	return ApiIpamVlanGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLANGroup
func (a *IpamApiService) IpamVlanGroupsUpdateExecute(r ApiIpamVlanGroupsUpdateRequest) (*VLANGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLANGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlanGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlan-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLANGroup == nil {
		return localVarReturnValue, nil, reportError("writableVLANGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLANGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamVlansBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansBulkDestroyExecute(r)
}

/*
IpamVlansBulkDestroy Method for IpamVlansBulkDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkDestroyRequest
*/
func (a *IpamApiService) IpamVlansBulkDestroy(ctx context.Context) ApiIpamVlansBulkDestroyRequest {
	return ApiIpamVlansBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlansBulkDestroyExecute(r ApiIpamVlansBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedWritableVLAN *PatchedWritableVLAN
}

func (r ApiIpamVlansBulkPartialUpdateRequest) PatchedWritableVLAN(patchedWritableVLAN PatchedWritableVLAN) ApiIpamVlansBulkPartialUpdateRequest {
	r.patchedWritableVLAN = &patchedWritableVLAN
	return r
}

func (r ApiIpamVlansBulkPartialUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkPartialUpdateExecute(r)
}

/*
IpamVlansBulkPartialUpdate Method for IpamVlansBulkPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlansBulkPartialUpdate(ctx context.Context) ApiIpamVlansBulkPartialUpdateRequest {
	return ApiIpamVlansBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansBulkPartialUpdateExecute(r ApiIpamVlansBulkPartialUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVLAN
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableVLAN *WritableVLAN
}

func (r ApiIpamVlansBulkUpdateRequest) WritableVLAN(writableVLAN WritableVLAN) ApiIpamVlansBulkUpdateRequest {
	r.writableVLAN = &writableVLAN
	return r
}

func (r ApiIpamVlansBulkUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansBulkUpdateExecute(r)
}

/*
IpamVlansBulkUpdate Method for IpamVlansBulkUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansBulkUpdateRequest
*/
func (a *IpamApiService) IpamVlansBulkUpdate(ctx context.Context) ApiIpamVlansBulkUpdateRequest {
	return ApiIpamVlansBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansBulkUpdateExecute(r ApiIpamVlansBulkUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLAN == nil {
		return localVarReturnValue, nil, reportError("writableVLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLAN
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableVLAN *WritableVLAN
}

func (r ApiIpamVlansCreateRequest) WritableVLAN(writableVLAN WritableVLAN) ApiIpamVlansCreateRequest {
	r.writableVLAN = &writableVLAN
	return r
}

func (r ApiIpamVlansCreateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansCreateExecute(r)
}

/*
IpamVlansCreate Method for IpamVlansCreate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansCreateRequest
*/
func (a *IpamApiService) IpamVlansCreate(ctx context.Context) ApiIpamVlansCreateRequest {
	return ApiIpamVlansCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansCreateExecute(r ApiIpamVlansCreateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLAN == nil {
		return localVarReturnValue, nil, reportError("writableVLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLAN
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamVlansDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVlansDestroyExecute(r)
}

/*
IpamVlansDestroy Method for IpamVlansDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansDestroyRequest
*/
func (a *IpamApiService) IpamVlansDestroy(ctx context.Context, id string) ApiIpamVlansDestroyRequest {
	return ApiIpamVlansDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVlansDestroyExecute(r ApiIpamVlansDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVlansListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	group *[]string
	groupN *[]string
	groupId *[]*string
	groupIdN *[]*string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	region *[]string
	regionN *[]string
	regionId *[]string
	regionIdN *[]string
	role *[]string
	roleN *[]string
	roleId *[]*string
	roleIdN *[]*string
	site *[]string
	siteN *[]string
	siteId *[]*string
	siteIdN *[]*string
	status *[]string
	statusN *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
	vid *[]int32
	vidGt *[]int32
	vidGte *[]int32
	vidLt *[]int32
	vidLte *[]int32
	vidN *[]int32
}

func (r ApiIpamVlansListRequest) Created(created string) ApiIpamVlansListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVlansListRequest) CreatedGte(createdGte string) ApiIpamVlansListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVlansListRequest) CreatedLte(createdLte string) ApiIpamVlansListRequest {
	r.createdLte = &createdLte
	return r
}

// Group
func (r ApiIpamVlansListRequest) Group(group []string) ApiIpamVlansListRequest {
	r.group = &group
	return r
}

// Group
func (r ApiIpamVlansListRequest) GroupN(groupN []string) ApiIpamVlansListRequest {
	r.groupN = &groupN
	return r
}

// Group (ID)
func (r ApiIpamVlansListRequest) GroupId(groupId []*string) ApiIpamVlansListRequest {
	r.groupId = &groupId
	return r
}

// Group (ID)
func (r ApiIpamVlansListRequest) GroupIdN(groupIdN []*string) ApiIpamVlansListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiIpamVlansListRequest) Id(id []string) ApiIpamVlansListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVlansListRequest) IdIc(idIc []string) ApiIpamVlansListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVlansListRequest) IdIe(idIe []string) ApiIpamVlansListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVlansListRequest) IdIew(idIew []string) ApiIpamVlansListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVlansListRequest) IdIre(idIre []string) ApiIpamVlansListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVlansListRequest) IdIsw(idIsw []string) ApiIpamVlansListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVlansListRequest) IdN(idN []string) ApiIpamVlansListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVlansListRequest) IdNic(idNic []string) ApiIpamVlansListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVlansListRequest) IdNie(idNie []string) ApiIpamVlansListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVlansListRequest) IdNiew(idNiew []string) ApiIpamVlansListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVlansListRequest) IdNire(idNire []string) ApiIpamVlansListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVlansListRequest) IdNisw(idNisw []string) ApiIpamVlansListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVlansListRequest) IdNre(idNre []string) ApiIpamVlansListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVlansListRequest) IdRe(idRe []string) ApiIpamVlansListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiIpamVlansListRequest) LastUpdated(lastUpdated time.Time) ApiIpamVlansListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVlansListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamVlansListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamVlansListRequest) Limit(limit int32) ApiIpamVlansListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVlansListRequest) Name(name []string) ApiIpamVlansListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVlansListRequest) NameIc(nameIc []string) ApiIpamVlansListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVlansListRequest) NameIe(nameIe []string) ApiIpamVlansListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVlansListRequest) NameIew(nameIew []string) ApiIpamVlansListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVlansListRequest) NameIre(nameIre []string) ApiIpamVlansListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamVlansListRequest) NameIsw(nameIsw []string) ApiIpamVlansListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVlansListRequest) NameN(nameN []string) ApiIpamVlansListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVlansListRequest) NameNic(nameNic []string) ApiIpamVlansListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVlansListRequest) NameNie(nameNie []string) ApiIpamVlansListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVlansListRequest) NameNiew(nameNiew []string) ApiIpamVlansListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVlansListRequest) NameNire(nameNire []string) ApiIpamVlansListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamVlansListRequest) NameNisw(nameNisw []string) ApiIpamVlansListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVlansListRequest) NameNre(nameNre []string) ApiIpamVlansListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamVlansListRequest) NameRe(nameRe []string) ApiIpamVlansListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVlansListRequest) Offset(offset int32) ApiIpamVlansListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamVlansListRequest) Q(q string) ApiIpamVlansListRequest {
	r.q = &q
	return r
}

// Region (slug)
func (r ApiIpamVlansListRequest) Region(region []string) ApiIpamVlansListRequest {
	r.region = &region
	return r
}

// Region (slug)
func (r ApiIpamVlansListRequest) RegionN(regionN []string) ApiIpamVlansListRequest {
	r.regionN = &regionN
	return r
}

// Region (ID)
func (r ApiIpamVlansListRequest) RegionId(regionId []string) ApiIpamVlansListRequest {
	r.regionId = &regionId
	return r
}

// Region (ID)
func (r ApiIpamVlansListRequest) RegionIdN(regionIdN []string) ApiIpamVlansListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Role (slug)
func (r ApiIpamVlansListRequest) Role(role []string) ApiIpamVlansListRequest {
	r.role = &role
	return r
}

// Role (slug)
func (r ApiIpamVlansListRequest) RoleN(roleN []string) ApiIpamVlansListRequest {
	r.roleN = &roleN
	return r
}

// Role (ID)
func (r ApiIpamVlansListRequest) RoleId(roleId []*string) ApiIpamVlansListRequest {
	r.roleId = &roleId
	return r
}

// Role (ID)
func (r ApiIpamVlansListRequest) RoleIdN(roleIdN []*string) ApiIpamVlansListRequest {
	r.roleIdN = &roleIdN
	return r
}

// Site (slug)
func (r ApiIpamVlansListRequest) Site(site []string) ApiIpamVlansListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiIpamVlansListRequest) SiteN(siteN []string) ApiIpamVlansListRequest {
	r.siteN = &siteN
	return r
}

// Site (ID)
func (r ApiIpamVlansListRequest) SiteId(siteId []*string) ApiIpamVlansListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiIpamVlansListRequest) SiteIdN(siteIdN []*string) ApiIpamVlansListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiIpamVlansListRequest) Status(status []string) ApiIpamVlansListRequest {
	r.status = &status
	return r
}

func (r ApiIpamVlansListRequest) StatusN(statusN []string) ApiIpamVlansListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiIpamVlansListRequest) Tag(tag []string) ApiIpamVlansListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVlansListRequest) TagN(tagN []string) ApiIpamVlansListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamVlansListRequest) Tenant(tenant []string) ApiIpamVlansListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamVlansListRequest) TenantN(tenantN []string) ApiIpamVlansListRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamVlansListRequest) TenantGroup(tenantGroup []string) ApiIpamVlansListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamVlansListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVlansListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamVlansListRequest) TenantGroupId(tenantGroupId []string) ApiIpamVlansListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamVlansListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamVlansListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamVlansListRequest) TenantId(tenantId []*string) ApiIpamVlansListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamVlansListRequest) TenantIdN(tenantIdN []*string) ApiIpamVlansListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVlansListRequest) Vid(vid []int32) ApiIpamVlansListRequest {
	r.vid = &vid
	return r
}

func (r ApiIpamVlansListRequest) VidGt(vidGt []int32) ApiIpamVlansListRequest {
	r.vidGt = &vidGt
	return r
}

func (r ApiIpamVlansListRequest) VidGte(vidGte []int32) ApiIpamVlansListRequest {
	r.vidGte = &vidGte
	return r
}

func (r ApiIpamVlansListRequest) VidLt(vidLt []int32) ApiIpamVlansListRequest {
	r.vidLt = &vidLt
	return r
}

func (r ApiIpamVlansListRequest) VidLte(vidLte []int32) ApiIpamVlansListRequest {
	r.vidLte = &vidLte
	return r
}

func (r ApiIpamVlansListRequest) VidN(vidN []int32) ApiIpamVlansListRequest {
	r.vidN = &vidN
	return r
}

func (r ApiIpamVlansListRequest) Execute() (*PaginatedVLANList, *http.Response, error) {
	return r.ApiService.IpamVlansListExecute(r)
}

/*
IpamVlansList Method for IpamVlansList

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVlansListRequest
*/
func (a *IpamApiService) IpamVlansList(ctx context.Context) ApiIpamVlansListRequest {
	return ApiIpamVlansListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVLANList
func (a *IpamApiService) IpamVlansListExecute(r ApiIpamVlansListRequest) (*PaginatedVLANList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVLANList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group__n", parameterToString(t, "multi"))
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group_id", parameterToString(t, "multi"))
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region", parameterToString(t, "multi"))
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region__n", parameterToString(t, "multi"))
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id", parameterToString(t, "multi"))
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id__n", parameterToString(t, "multi"))
		}
	}
	if r.role != nil {
		t := *r.role
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role", parameterToString(t, "multi"))
		}
	}
	if r.roleN != nil {
		t := *r.roleN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role__n", parameterToString(t, "multi"))
		}
	}
	if r.roleId != nil {
		t := *r.roleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role_id", parameterToString(t, "multi"))
		}
	}
	if r.roleIdN != nil {
		t := *r.roleIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("role_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("role_id__n", parameterToString(t, "multi"))
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site", parameterToString(t, "multi"))
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site__n", parameterToString(t, "multi"))
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id", parameterToString(t, "multi"))
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id__n", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status__n", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	if r.vid != nil {
		t := *r.vid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vid", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vid", parameterToString(t, "multi"))
		}
	}
	if r.vidGt != nil {
		t := *r.vidGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vid__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vid__gt", parameterToString(t, "multi"))
		}
	}
	if r.vidGte != nil {
		t := *r.vidGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vid__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vid__gte", parameterToString(t, "multi"))
		}
	}
	if r.vidLt != nil {
		t := *r.vidLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vid__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vid__lt", parameterToString(t, "multi"))
		}
	}
	if r.vidLte != nil {
		t := *r.vidLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vid__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vid__lte", parameterToString(t, "multi"))
		}
	}
	if r.vidN != nil {
		t := *r.vidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vid__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vid__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritableVLAN *PatchedWritableVLAN
}

func (r ApiIpamVlansPartialUpdateRequest) PatchedWritableVLAN(patchedWritableVLAN PatchedWritableVLAN) ApiIpamVlansPartialUpdateRequest {
	r.patchedWritableVLAN = &patchedWritableVLAN
	return r
}

func (r ApiIpamVlansPartialUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansPartialUpdateExecute(r)
}

/*
IpamVlansPartialUpdate Method for IpamVlansPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansPartialUpdateRequest
*/
func (a *IpamApiService) IpamVlansPartialUpdate(ctx context.Context, id string) ApiIpamVlansPartialUpdateRequest {
	return ApiIpamVlansPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansPartialUpdateExecute(r ApiIpamVlansPartialUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVLAN
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamVlansRetrieveRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansRetrieveExecute(r)
}

/*
IpamVlansRetrieve Method for IpamVlansRetrieve

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansRetrieveRequest
*/
func (a *IpamApiService) IpamVlansRetrieve(ctx context.Context, id string) ApiIpamVlansRetrieveRequest {
	return ApiIpamVlansRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansRetrieveExecute(r ApiIpamVlansRetrieveRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVlansUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writableVLAN *WritableVLAN
}

func (r ApiIpamVlansUpdateRequest) WritableVLAN(writableVLAN WritableVLAN) ApiIpamVlansUpdateRequest {
	r.writableVLAN = &writableVLAN
	return r
}

func (r ApiIpamVlansUpdateRequest) Execute() (*VLAN, *http.Response, error) {
	return r.ApiService.IpamVlansUpdateExecute(r)
}

/*
IpamVlansUpdate Method for IpamVlansUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VLAN.
 @return ApiIpamVlansUpdateRequest
*/
func (a *IpamApiService) IpamVlansUpdate(ctx context.Context, id string) ApiIpamVlansUpdateRequest {
	return ApiIpamVlansUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VLAN
func (a *IpamApiService) IpamVlansUpdateExecute(r ApiIpamVlansUpdateRequest) (*VLAN, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VLAN
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVlansUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVLAN == nil {
		return localVarReturnValue, nil, reportError("writableVLAN is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVLAN
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
}

func (r ApiIpamVrfsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsBulkDestroyExecute(r)
}

/*
IpamVrfsBulkDestroy Method for IpamVrfsBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkDestroyRequest
*/
func (a *IpamApiService) IpamVrfsBulkDestroy(ctx context.Context) ApiIpamVrfsBulkDestroyRequest {
	return ApiIpamVrfsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVrfsBulkDestroyExecute(r ApiIpamVrfsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	patchedWritableVRF *PatchedWritableVRF
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) PatchedWritableVRF(patchedWritableVRF PatchedWritableVRF) ApiIpamVrfsBulkPartialUpdateRequest {
	r.patchedWritableVRF = &patchedWritableVRF
	return r
}

func (r ApiIpamVrfsBulkPartialUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkPartialUpdateExecute(r)
}

/*
IpamVrfsBulkPartialUpdate Method for IpamVrfsBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkPartialUpdateRequest
*/
func (a *IpamApiService) IpamVrfsBulkPartialUpdate(ctx context.Context) ApiIpamVrfsBulkPartialUpdateRequest {
	return ApiIpamVrfsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsBulkPartialUpdateExecute(r ApiIpamVrfsBulkPartialUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVRF
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableVRF *WritableVRF
}

func (r ApiIpamVrfsBulkUpdateRequest) WritableVRF(writableVRF WritableVRF) ApiIpamVrfsBulkUpdateRequest {
	r.writableVRF = &writableVRF
	return r
}

func (r ApiIpamVrfsBulkUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsBulkUpdateExecute(r)
}

/*
IpamVrfsBulkUpdate Method for IpamVrfsBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsBulkUpdateRequest
*/
func (a *IpamApiService) IpamVrfsBulkUpdate(ctx context.Context) ApiIpamVrfsBulkUpdateRequest {
	return ApiIpamVrfsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsBulkUpdateExecute(r ApiIpamVrfsBulkUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVRF == nil {
		return localVarReturnValue, nil, reportError("writableVRF is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVRF
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsCreateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	writableVRF *WritableVRF
}

func (r ApiIpamVrfsCreateRequest) WritableVRF(writableVRF WritableVRF) ApiIpamVrfsCreateRequest {
	r.writableVRF = &writableVRF
	return r
}

func (r ApiIpamVrfsCreateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsCreateExecute(r)
}

/*
IpamVrfsCreate Method for IpamVrfsCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsCreateRequest
*/
func (a *IpamApiService) IpamVrfsCreate(ctx context.Context) ApiIpamVrfsCreateRequest {
	return ApiIpamVrfsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsCreateExecute(r ApiIpamVrfsCreateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVRF == nil {
		return localVarReturnValue, nil, reportError("writableVRF is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVRF
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsDestroyRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamVrfsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.IpamVrfsDestroyExecute(r)
}

/*
IpamVrfsDestroy Method for IpamVrfsDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsDestroyRequest
*/
func (a *IpamApiService) IpamVrfsDestroy(ctx context.Context, id string) ApiIpamVrfsDestroyRequest {
	return ApiIpamVrfsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *IpamApiService) IpamVrfsDestroyExecute(r ApiIpamVrfsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIpamVrfsListRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	created *string
	createdGte *string
	createdLte *string
	enforceUnique *bool
	exportTarget *[]string
	exportTargetN *[]string
	exportTargetId *[]string
	exportTargetIdN *[]string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	importTarget *[]string
	importTargetN *[]string
	importTargetId *[]string
	importTargetIdN *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	rd *[]string
	rdIc *[]string
	rdIe *[]string
	rdIew *[]string
	rdIre *[]string
	rdIsw *[]string
	rdN *[]string
	rdNic *[]string
	rdNie *[]string
	rdNiew *[]string
	rdNire *[]string
	rdNisw *[]string
	rdNre *[]string
	rdRe *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
}

func (r ApiIpamVrfsListRequest) Created(created string) ApiIpamVrfsListRequest {
	r.created = &created
	return r
}

func (r ApiIpamVrfsListRequest) CreatedGte(createdGte string) ApiIpamVrfsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiIpamVrfsListRequest) CreatedLte(createdLte string) ApiIpamVrfsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiIpamVrfsListRequest) EnforceUnique(enforceUnique bool) ApiIpamVrfsListRequest {
	r.enforceUnique = &enforceUnique
	return r
}

// Export target (name)
func (r ApiIpamVrfsListRequest) ExportTarget(exportTarget []string) ApiIpamVrfsListRequest {
	r.exportTarget = &exportTarget
	return r
}

// Export target (name)
func (r ApiIpamVrfsListRequest) ExportTargetN(exportTargetN []string) ApiIpamVrfsListRequest {
	r.exportTargetN = &exportTargetN
	return r
}

// Export target
func (r ApiIpamVrfsListRequest) ExportTargetId(exportTargetId []string) ApiIpamVrfsListRequest {
	r.exportTargetId = &exportTargetId
	return r
}

// Export target
func (r ApiIpamVrfsListRequest) ExportTargetIdN(exportTargetIdN []string) ApiIpamVrfsListRequest {
	r.exportTargetIdN = &exportTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) Id(id []string) ApiIpamVrfsListRequest {
	r.id = &id
	return r
}

func (r ApiIpamVrfsListRequest) IdIc(idIc []string) ApiIpamVrfsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiIpamVrfsListRequest) IdIe(idIe []string) ApiIpamVrfsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiIpamVrfsListRequest) IdIew(idIew []string) ApiIpamVrfsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiIpamVrfsListRequest) IdIre(idIre []string) ApiIpamVrfsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiIpamVrfsListRequest) IdIsw(idIsw []string) ApiIpamVrfsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiIpamVrfsListRequest) IdN(idN []string) ApiIpamVrfsListRequest {
	r.idN = &idN
	return r
}

func (r ApiIpamVrfsListRequest) IdNic(idNic []string) ApiIpamVrfsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiIpamVrfsListRequest) IdNie(idNie []string) ApiIpamVrfsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiIpamVrfsListRequest) IdNiew(idNiew []string) ApiIpamVrfsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiIpamVrfsListRequest) IdNire(idNire []string) ApiIpamVrfsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiIpamVrfsListRequest) IdNisw(idNisw []string) ApiIpamVrfsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiIpamVrfsListRequest) IdNre(idNre []string) ApiIpamVrfsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiIpamVrfsListRequest) IdRe(idRe []string) ApiIpamVrfsListRequest {
	r.idRe = &idRe
	return r
}

// Import target (name)
func (r ApiIpamVrfsListRequest) ImportTarget(importTarget []string) ApiIpamVrfsListRequest {
	r.importTarget = &importTarget
	return r
}

// Import target (name)
func (r ApiIpamVrfsListRequest) ImportTargetN(importTargetN []string) ApiIpamVrfsListRequest {
	r.importTargetN = &importTargetN
	return r
}

// Import target
func (r ApiIpamVrfsListRequest) ImportTargetId(importTargetId []string) ApiIpamVrfsListRequest {
	r.importTargetId = &importTargetId
	return r
}

// Import target
func (r ApiIpamVrfsListRequest) ImportTargetIdN(importTargetIdN []string) ApiIpamVrfsListRequest {
	r.importTargetIdN = &importTargetIdN
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdated(lastUpdated time.Time) ApiIpamVrfsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiIpamVrfsListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiIpamVrfsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiIpamVrfsListRequest) Limit(limit int32) ApiIpamVrfsListRequest {
	r.limit = &limit
	return r
}

func (r ApiIpamVrfsListRequest) Name(name []string) ApiIpamVrfsListRequest {
	r.name = &name
	return r
}

func (r ApiIpamVrfsListRequest) NameIc(nameIc []string) ApiIpamVrfsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiIpamVrfsListRequest) NameIe(nameIe []string) ApiIpamVrfsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiIpamVrfsListRequest) NameIew(nameIew []string) ApiIpamVrfsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiIpamVrfsListRequest) NameIre(nameIre []string) ApiIpamVrfsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiIpamVrfsListRequest) NameIsw(nameIsw []string) ApiIpamVrfsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiIpamVrfsListRequest) NameN(nameN []string) ApiIpamVrfsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiIpamVrfsListRequest) NameNic(nameNic []string) ApiIpamVrfsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiIpamVrfsListRequest) NameNie(nameNie []string) ApiIpamVrfsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiIpamVrfsListRequest) NameNiew(nameNiew []string) ApiIpamVrfsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiIpamVrfsListRequest) NameNire(nameNire []string) ApiIpamVrfsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiIpamVrfsListRequest) NameNisw(nameNisw []string) ApiIpamVrfsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiIpamVrfsListRequest) NameNre(nameNre []string) ApiIpamVrfsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiIpamVrfsListRequest) NameRe(nameRe []string) ApiIpamVrfsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiIpamVrfsListRequest) Offset(offset int32) ApiIpamVrfsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiIpamVrfsListRequest) Q(q string) ApiIpamVrfsListRequest {
	r.q = &q
	return r
}

func (r ApiIpamVrfsListRequest) Rd(rd []string) ApiIpamVrfsListRequest {
	r.rd = &rd
	return r
}

func (r ApiIpamVrfsListRequest) RdIc(rdIc []string) ApiIpamVrfsListRequest {
	r.rdIc = &rdIc
	return r
}

func (r ApiIpamVrfsListRequest) RdIe(rdIe []string) ApiIpamVrfsListRequest {
	r.rdIe = &rdIe
	return r
}

func (r ApiIpamVrfsListRequest) RdIew(rdIew []string) ApiIpamVrfsListRequest {
	r.rdIew = &rdIew
	return r
}

func (r ApiIpamVrfsListRequest) RdIre(rdIre []string) ApiIpamVrfsListRequest {
	r.rdIre = &rdIre
	return r
}

func (r ApiIpamVrfsListRequest) RdIsw(rdIsw []string) ApiIpamVrfsListRequest {
	r.rdIsw = &rdIsw
	return r
}

func (r ApiIpamVrfsListRequest) RdN(rdN []string) ApiIpamVrfsListRequest {
	r.rdN = &rdN
	return r
}

func (r ApiIpamVrfsListRequest) RdNic(rdNic []string) ApiIpamVrfsListRequest {
	r.rdNic = &rdNic
	return r
}

func (r ApiIpamVrfsListRequest) RdNie(rdNie []string) ApiIpamVrfsListRequest {
	r.rdNie = &rdNie
	return r
}

func (r ApiIpamVrfsListRequest) RdNiew(rdNiew []string) ApiIpamVrfsListRequest {
	r.rdNiew = &rdNiew
	return r
}

func (r ApiIpamVrfsListRequest) RdNire(rdNire []string) ApiIpamVrfsListRequest {
	r.rdNire = &rdNire
	return r
}

func (r ApiIpamVrfsListRequest) RdNisw(rdNisw []string) ApiIpamVrfsListRequest {
	r.rdNisw = &rdNisw
	return r
}

func (r ApiIpamVrfsListRequest) RdNre(rdNre []string) ApiIpamVrfsListRequest {
	r.rdNre = &rdNre
	return r
}

func (r ApiIpamVrfsListRequest) RdRe(rdRe []string) ApiIpamVrfsListRequest {
	r.rdRe = &rdRe
	return r
}

func (r ApiIpamVrfsListRequest) Tag(tag []string) ApiIpamVrfsListRequest {
	r.tag = &tag
	return r
}

func (r ApiIpamVrfsListRequest) TagN(tagN []string) ApiIpamVrfsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiIpamVrfsListRequest) Tenant(tenant []string) ApiIpamVrfsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiIpamVrfsListRequest) TenantN(tenantN []string) ApiIpamVrfsListRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiIpamVrfsListRequest) TenantGroup(tenantGroup []string) ApiIpamVrfsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiIpamVrfsListRequest) TenantGroupN(tenantGroupN []string) ApiIpamVrfsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiIpamVrfsListRequest) TenantGroupId(tenantGroupId []string) ApiIpamVrfsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiIpamVrfsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiIpamVrfsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiIpamVrfsListRequest) TenantId(tenantId []*string) ApiIpamVrfsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiIpamVrfsListRequest) TenantIdN(tenantIdN []*string) ApiIpamVrfsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

func (r ApiIpamVrfsListRequest) Execute() (*PaginatedVRFList, *http.Response, error) {
	return r.ApiService.IpamVrfsListExecute(r)
}

/*
IpamVrfsList Method for IpamVrfsList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIpamVrfsListRequest
*/
func (a *IpamApiService) IpamVrfsList(ctx context.Context) ApiIpamVrfsListRequest {
	return ApiIpamVrfsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedVRFList
func (a *IpamApiService) IpamVrfsListExecute(r ApiIpamVrfsListRequest) (*PaginatedVRFList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedVRFList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.enforceUnique != nil {
		localVarQueryParams.Add("enforce_unique", parameterToString(*r.enforceUnique, ""))
	}
	if r.exportTarget != nil {
		t := *r.exportTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("export_target", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("export_target", parameterToString(t, "multi"))
		}
	}
	if r.exportTargetN != nil {
		t := *r.exportTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("export_target__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("export_target__n", parameterToString(t, "multi"))
		}
	}
	if r.exportTargetId != nil {
		t := *r.exportTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("export_target_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("export_target_id", parameterToString(t, "multi"))
		}
	}
	if r.exportTargetIdN != nil {
		t := *r.exportTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("export_target_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("export_target_id__n", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.importTarget != nil {
		t := *r.importTarget
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("import_target", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("import_target", parameterToString(t, "multi"))
		}
	}
	if r.importTargetN != nil {
		t := *r.importTargetN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("import_target__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("import_target__n", parameterToString(t, "multi"))
		}
	}
	if r.importTargetId != nil {
		t := *r.importTargetId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("import_target_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("import_target_id", parameterToString(t, "multi"))
		}
	}
	if r.importTargetIdN != nil {
		t := *r.importTargetIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("import_target_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("import_target_id__n", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.rd != nil {
		t := *r.rd
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd", parameterToString(t, "multi"))
		}
	}
	if r.rdIc != nil {
		t := *r.rdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__ic", parameterToString(t, "multi"))
		}
	}
	if r.rdIe != nil {
		t := *r.rdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__ie", parameterToString(t, "multi"))
		}
	}
	if r.rdIew != nil {
		t := *r.rdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__iew", parameterToString(t, "multi"))
		}
	}
	if r.rdIre != nil {
		t := *r.rdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__ire", parameterToString(t, "multi"))
		}
	}
	if r.rdIsw != nil {
		t := *r.rdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__isw", parameterToString(t, "multi"))
		}
	}
	if r.rdN != nil {
		t := *r.rdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__n", parameterToString(t, "multi"))
		}
	}
	if r.rdNic != nil {
		t := *r.rdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__nic", parameterToString(t, "multi"))
		}
	}
	if r.rdNie != nil {
		t := *r.rdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__nie", parameterToString(t, "multi"))
		}
	}
	if r.rdNiew != nil {
		t := *r.rdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__niew", parameterToString(t, "multi"))
		}
	}
	if r.rdNire != nil {
		t := *r.rdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__nire", parameterToString(t, "multi"))
		}
	}
	if r.rdNisw != nil {
		t := *r.rdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__nisw", parameterToString(t, "multi"))
		}
	}
	if r.rdNre != nil {
		t := *r.rdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__nre", parameterToString(t, "multi"))
		}
	}
	if r.rdRe != nil {
		t := *r.rdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("rd__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("rd__re", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	patchedWritableVRF *PatchedWritableVRF
}

func (r ApiIpamVrfsPartialUpdateRequest) PatchedWritableVRF(patchedWritableVRF PatchedWritableVRF) ApiIpamVrfsPartialUpdateRequest {
	r.patchedWritableVRF = &patchedWritableVRF
	return r
}

func (r ApiIpamVrfsPartialUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsPartialUpdateExecute(r)
}

/*
IpamVrfsPartialUpdate Method for IpamVrfsPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsPartialUpdateRequest
*/
func (a *IpamApiService) IpamVrfsPartialUpdate(ctx context.Context, id string) ApiIpamVrfsPartialUpdateRequest {
	return ApiIpamVrfsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsPartialUpdateExecute(r ApiIpamVrfsPartialUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableVRF
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsRetrieveRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
}

func (r ApiIpamVrfsRetrieveRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsRetrieveExecute(r)
}

/*
IpamVrfsRetrieve Method for IpamVrfsRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsRetrieveRequest
*/
func (a *IpamApiService) IpamVrfsRetrieve(ctx context.Context, id string) ApiIpamVrfsRetrieveRequest {
	return ApiIpamVrfsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsRetrieveExecute(r ApiIpamVrfsRetrieveRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIpamVrfsUpdateRequest struct {
	ctx context.Context
	ApiService *IpamApiService
	id string
	writableVRF *WritableVRF
}

func (r ApiIpamVrfsUpdateRequest) WritableVRF(writableVRF WritableVRF) ApiIpamVrfsUpdateRequest {
	r.writableVRF = &writableVRF
	return r
}

func (r ApiIpamVrfsUpdateRequest) Execute() (*VRF, *http.Response, error) {
	return r.ApiService.IpamVrfsUpdateExecute(r)
}

/*
IpamVrfsUpdate Method for IpamVrfsUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this VRF.
 @return ApiIpamVrfsUpdateRequest
*/
func (a *IpamApiService) IpamVrfsUpdate(ctx context.Context, id string) ApiIpamVrfsUpdateRequest {
	return ApiIpamVrfsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VRF
func (a *IpamApiService) IpamVrfsUpdateExecute(r ApiIpamVrfsUpdateRequest) (*VRF, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VRF
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IpamApiService.IpamVrfsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipam/vrfs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableVRF == nil {
		return localVarReturnValue, nil, reportError("writableVRF is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableVRF
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
