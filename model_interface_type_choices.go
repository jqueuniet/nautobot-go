/*
API Documentation

Source of truth and network automation platform

API version: 1.3.7 (1.2)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// InterfaceTypeChoices the model 'InterfaceTypeChoices'
type InterfaceTypeChoices string

// List of InterfaceTypeChoices
const (
	VIRTUAL InterfaceTypeChoices = "virtual"
	LAG InterfaceTypeChoices = "lag"
	_100BASE_TX InterfaceTypeChoices = "100base-tx"
	_1000BASE_T InterfaceTypeChoices = "1000base-t"
	_2_5GBASE_T InterfaceTypeChoices = "2.5gbase-t"
	_5GBASE_T InterfaceTypeChoices = "5gbase-t"
	_10GBASE_T InterfaceTypeChoices = "10gbase-t"
	_10GBASE_CX4 InterfaceTypeChoices = "10gbase-cx4"
	_1000BASE_X_GBIC InterfaceTypeChoices = "1000base-x-gbic"
	_1000BASE_X_SFP InterfaceTypeChoices = "1000base-x-sfp"
	_10GBASE_X_SFPP InterfaceTypeChoices = "10gbase-x-sfpp"
	_10GBASE_X_XFP InterfaceTypeChoices = "10gbase-x-xfp"
	_10GBASE_X_XENPAK InterfaceTypeChoices = "10gbase-x-xenpak"
	_10GBASE_X_X2 InterfaceTypeChoices = "10gbase-x-x2"
	_25GBASE_X_SFP28 InterfaceTypeChoices = "25gbase-x-sfp28"
	_40GBASE_X_QSFPP InterfaceTypeChoices = "40gbase-x-qsfpp"
	_50GBASE_X_SFP28 InterfaceTypeChoices = "50gbase-x-sfp28"
	_100GBASE_X_CFP InterfaceTypeChoices = "100gbase-x-cfp"
	_100GBASE_X_CFP2 InterfaceTypeChoices = "100gbase-x-cfp2"
	_200GBASE_X_CFP2 InterfaceTypeChoices = "200gbase-x-cfp2"
	_100GBASE_X_CFP4 InterfaceTypeChoices = "100gbase-x-cfp4"
	_100GBASE_X_CPAK InterfaceTypeChoices = "100gbase-x-cpak"
	_100GBASE_X_QSFP28 InterfaceTypeChoices = "100gbase-x-qsfp28"
	_200GBASE_X_QSFP56 InterfaceTypeChoices = "200gbase-x-qsfp56"
	_400GBASE_X_QSFPDD InterfaceTypeChoices = "400gbase-x-qsfpdd"
	_400GBASE_X_OSFP InterfaceTypeChoices = "400gbase-x-osfp"
	IEEE802_11A InterfaceTypeChoices = "ieee802.11a"
	IEEE802_11G InterfaceTypeChoices = "ieee802.11g"
	IEEE802_11N InterfaceTypeChoices = "ieee802.11n"
	IEEE802_11AC InterfaceTypeChoices = "ieee802.11ac"
	IEEE802_11AD InterfaceTypeChoices = "ieee802.11ad"
	IEEE802_11AX InterfaceTypeChoices = "ieee802.11ax"
	GSM InterfaceTypeChoices = "gsm"
	CDMA InterfaceTypeChoices = "cdma"
	LTE InterfaceTypeChoices = "lte"
	SONET_OC3 InterfaceTypeChoices = "sonet-oc3"
	SONET_OC12 InterfaceTypeChoices = "sonet-oc12"
	SONET_OC48 InterfaceTypeChoices = "sonet-oc48"
	SONET_OC192 InterfaceTypeChoices = "sonet-oc192"
	SONET_OC768 InterfaceTypeChoices = "sonet-oc768"
	SONET_OC1920 InterfaceTypeChoices = "sonet-oc1920"
	SONET_OC3840 InterfaceTypeChoices = "sonet-oc3840"
	_1GFC_SFP InterfaceTypeChoices = "1gfc-sfp"
	_2GFC_SFP InterfaceTypeChoices = "2gfc-sfp"
	_4GFC_SFP InterfaceTypeChoices = "4gfc-sfp"
	_8GFC_SFPP InterfaceTypeChoices = "8gfc-sfpp"
	_16GFC_SFPP InterfaceTypeChoices = "16gfc-sfpp"
	_32GFC_SFP28 InterfaceTypeChoices = "32gfc-sfp28"
	_64GFC_QSFPP InterfaceTypeChoices = "64gfc-qsfpp"
	_128GFC_SFP28 InterfaceTypeChoices = "128gfc-sfp28"
	INFINIBAND_SDR InterfaceTypeChoices = "infiniband-sdr"
	INFINIBAND_DDR InterfaceTypeChoices = "infiniband-ddr"
	INFINIBAND_QDR InterfaceTypeChoices = "infiniband-qdr"
	INFINIBAND_FDR10 InterfaceTypeChoices = "infiniband-fdr10"
	INFINIBAND_FDR InterfaceTypeChoices = "infiniband-fdr"
	INFINIBAND_EDR InterfaceTypeChoices = "infiniband-edr"
	INFINIBAND_HDR InterfaceTypeChoices = "infiniband-hdr"
	INFINIBAND_NDR InterfaceTypeChoices = "infiniband-ndr"
	INFINIBAND_XDR InterfaceTypeChoices = "infiniband-xdr"
	T1 InterfaceTypeChoices = "t1"
	E1 InterfaceTypeChoices = "e1"
	T3 InterfaceTypeChoices = "t3"
	E3 InterfaceTypeChoices = "e3"
	CISCO_STACKWISE InterfaceTypeChoices = "cisco-stackwise"
	CISCO_STACKWISE_PLUS InterfaceTypeChoices = "cisco-stackwise-plus"
	CISCO_FLEXSTACK InterfaceTypeChoices = "cisco-flexstack"
	CISCO_FLEXSTACK_PLUS InterfaceTypeChoices = "cisco-flexstack-plus"
	JUNIPER_VCP InterfaceTypeChoices = "juniper-vcp"
	EXTREME_SUMMITSTACK InterfaceTypeChoices = "extreme-summitstack"
	EXTREME_SUMMITSTACK_128 InterfaceTypeChoices = "extreme-summitstack-128"
	EXTREME_SUMMITSTACK_256 InterfaceTypeChoices = "extreme-summitstack-256"
	EXTREME_SUMMITSTACK_512 InterfaceTypeChoices = "extreme-summitstack-512"
	OTHER InterfaceTypeChoices = "other"
)

// All allowed values of InterfaceTypeChoices enum
var AllowedInterfaceTypeChoicesEnumValues = []InterfaceTypeChoices{
	"virtual",
	"lag",
	"100base-tx",
	"1000base-t",
	"2.5gbase-t",
	"5gbase-t",
	"10gbase-t",
	"10gbase-cx4",
	"1000base-x-gbic",
	"1000base-x-sfp",
	"10gbase-x-sfpp",
	"10gbase-x-xfp",
	"10gbase-x-xenpak",
	"10gbase-x-x2",
	"25gbase-x-sfp28",
	"40gbase-x-qsfpp",
	"50gbase-x-sfp28",
	"100gbase-x-cfp",
	"100gbase-x-cfp2",
	"200gbase-x-cfp2",
	"100gbase-x-cfp4",
	"100gbase-x-cpak",
	"100gbase-x-qsfp28",
	"200gbase-x-qsfp56",
	"400gbase-x-qsfpdd",
	"400gbase-x-osfp",
	"ieee802.11a",
	"ieee802.11g",
	"ieee802.11n",
	"ieee802.11ac",
	"ieee802.11ad",
	"ieee802.11ax",
	"gsm",
	"cdma",
	"lte",
	"sonet-oc3",
	"sonet-oc12",
	"sonet-oc48",
	"sonet-oc192",
	"sonet-oc768",
	"sonet-oc1920",
	"sonet-oc3840",
	"1gfc-sfp",
	"2gfc-sfp",
	"4gfc-sfp",
	"8gfc-sfpp",
	"16gfc-sfpp",
	"32gfc-sfp28",
	"64gfc-qsfpp",
	"128gfc-sfp28",
	"infiniband-sdr",
	"infiniband-ddr",
	"infiniband-qdr",
	"infiniband-fdr10",
	"infiniband-fdr",
	"infiniband-edr",
	"infiniband-hdr",
	"infiniband-ndr",
	"infiniband-xdr",
	"t1",
	"e1",
	"t3",
	"e3",
	"cisco-stackwise",
	"cisco-stackwise-plus",
	"cisco-flexstack",
	"cisco-flexstack-plus",
	"juniper-vcp",
	"extreme-summitstack",
	"extreme-summitstack-128",
	"extreme-summitstack-256",
	"extreme-summitstack-512",
	"other",
}

func (v *InterfaceTypeChoices) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := InterfaceTypeChoices(value)
	for _, existing := range AllowedInterfaceTypeChoicesEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid InterfaceTypeChoices", value)
}

// NewInterfaceTypeChoicesFromValue returns a pointer to a valid InterfaceTypeChoices
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewInterfaceTypeChoicesFromValue(v string) (*InterfaceTypeChoices, error) {
	ev := InterfaceTypeChoices(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for InterfaceTypeChoices: valid values are %v", v, AllowedInterfaceTypeChoicesEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v InterfaceTypeChoices) IsValid() bool {
	for _, existing := range AllowedInterfaceTypeChoicesEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to InterfaceTypeChoices value
func (v InterfaceTypeChoices) Ptr() *InterfaceTypeChoices {
	return &v
}

type NullableInterfaceTypeChoices struct {
	value *InterfaceTypeChoices
	isSet bool
}

func (v NullableInterfaceTypeChoices) Get() *InterfaceTypeChoices {
	return v.value
}

func (v *NullableInterfaceTypeChoices) Set(val *InterfaceTypeChoices) {
	v.value = val
	v.isSet = true
}

func (v NullableInterfaceTypeChoices) IsSet() bool {
	return v.isSet
}

func (v *NullableInterfaceTypeChoices) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableInterfaceTypeChoices(val *InterfaceTypeChoices) *NullableInterfaceTypeChoices {
	return &NullableInterfaceTypeChoices{value: val, isSet: true}
}

func (v NullableInterfaceTypeChoices) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableInterfaceTypeChoices) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

