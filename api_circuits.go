/*
API Documentation

Source of truth and network automation platform

API version: 1.3.7 (1.2)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// CircuitsApiService CircuitsApi service
type CircuitsApiService service

type ApiCircuitsCircuitTerminationsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsCircuitTerminationsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsBulkDestroyExecute(r)
}

/*
CircuitsCircuitTerminationsBulkDestroy Method for CircuitsCircuitTerminationsBulkDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsBulkDestroyRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkDestroy(ctx context.Context) ApiCircuitsCircuitTerminationsBulkDestroyRequest {
	return ApiCircuitsCircuitTerminationsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkDestroyExecute(r ApiCircuitsCircuitTerminationsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	patchedWritableCircuitTermination *PatchedWritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest) PatchedWritableCircuitTermination(patchedWritableCircuitTermination PatchedWritableCircuitTermination) ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest {
	r.patchedWritableCircuitTermination = &patchedWritableCircuitTermination
	return r
}

func (r ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsBulkPartialUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsBulkPartialUpdate Method for CircuitsCircuitTerminationsBulkPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkPartialUpdate(ctx context.Context) ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest {
	return ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkPartialUpdateExecute(r ApiCircuitsCircuitTerminationsBulkPartialUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableCircuitTermination
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	writableCircuitTermination *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsBulkUpdateRequest) WritableCircuitTermination(writableCircuitTermination WritableCircuitTermination) ApiCircuitsCircuitTerminationsBulkUpdateRequest {
	r.writableCircuitTermination = &writableCircuitTermination
	return r
}

func (r ApiCircuitsCircuitTerminationsBulkUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsBulkUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsBulkUpdate Method for CircuitsCircuitTerminationsBulkUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkUpdate(ctx context.Context) ApiCircuitsCircuitTerminationsBulkUpdateRequest {
	return ApiCircuitsCircuitTerminationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsBulkUpdateExecute(r ApiCircuitsCircuitTerminationsBulkUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCircuitTermination == nil {
		return localVarReturnValue, nil, reportError("writableCircuitTermination is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCircuitTermination
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	writableCircuitTermination *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsCreateRequest) WritableCircuitTermination(writableCircuitTermination WritableCircuitTermination) ApiCircuitsCircuitTerminationsCreateRequest {
	r.writableCircuitTermination = &writableCircuitTermination
	return r
}

func (r ApiCircuitsCircuitTerminationsCreateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsCreateExecute(r)
}

/*
CircuitsCircuitTerminationsCreate Method for CircuitsCircuitTerminationsCreate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsCreateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsCreate(ctx context.Context) ApiCircuitsCircuitTerminationsCreateRequest {
	return ApiCircuitsCircuitTerminationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsCreateExecute(r ApiCircuitsCircuitTerminationsCreateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCircuitTermination == nil {
		return localVarReturnValue, nil, reportError("writableCircuitTermination is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCircuitTermination
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsCircuitTerminationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsDestroyExecute(r)
}

/*
CircuitsCircuitTerminationsDestroy Method for CircuitsCircuitTerminationsDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsDestroyRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsDestroy(ctx context.Context, id string) ApiCircuitsCircuitTerminationsDestroyRequest {
	return ApiCircuitsCircuitTerminationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTerminationsDestroyExecute(r ApiCircuitsCircuitTerminationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	cabled *bool
	circuitId *[]string
	circuitIdN *[]string
	connected *bool
	limit *int32
	offset *int32
	portSpeed *[]int32
	portSpeedGt *[]int32
	portSpeedGte *[]int32
	portSpeedLt *[]int32
	portSpeedLte *[]int32
	portSpeedN *[]int32
	providerNetworkId *[]*string
	providerNetworkIdN *[]*string
	q *string
	site *[]string
	siteN *[]string
	siteId *[]*string
	siteIdN *[]*string
	termSide *string
	termSideN *string
	upstreamSpeed *[]int32
	upstreamSpeedGt *[]int32
	upstreamSpeedGte *[]int32
	upstreamSpeedLt *[]int32
	upstreamSpeedLte *[]int32
	upstreamSpeedN *[]int32
	xconnectId *[]string
	xconnectIdIc *[]string
	xconnectIdIe *[]string
	xconnectIdIew *[]string
	xconnectIdIre *[]string
	xconnectIdIsw *[]string
	xconnectIdN *[]string
	xconnectIdNic *[]string
	xconnectIdNie *[]string
	xconnectIdNiew *[]string
	xconnectIdNire *[]string
	xconnectIdNisw *[]string
	xconnectIdNre *[]string
	xconnectIdRe *[]string
}

func (r ApiCircuitsCircuitTerminationsListRequest) Cabled(cabled bool) ApiCircuitsCircuitTerminationsListRequest {
	r.cabled = &cabled
	return r
}

// Circuit
func (r ApiCircuitsCircuitTerminationsListRequest) CircuitId(circuitId []string) ApiCircuitsCircuitTerminationsListRequest {
	r.circuitId = &circuitId
	return r
}

// Circuit
func (r ApiCircuitsCircuitTerminationsListRequest) CircuitIdN(circuitIdN []string) ApiCircuitsCircuitTerminationsListRequest {
	r.circuitIdN = &circuitIdN
	return r
}

// Connected status (bool)
func (r ApiCircuitsCircuitTerminationsListRequest) Connected(connected bool) ApiCircuitsCircuitTerminationsListRequest {
	r.connected = &connected
	return r
}

// Number of results to return per page.
func (r ApiCircuitsCircuitTerminationsListRequest) Limit(limit int32) ApiCircuitsCircuitTerminationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsCircuitTerminationsListRequest) Offset(offset int32) ApiCircuitsCircuitTerminationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeed(portSpeed []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeed = &portSpeed
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedGt(portSpeedGt []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedGt = &portSpeedGt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedGte(portSpeedGte []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedGte = &portSpeedGte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedLt(portSpeedLt []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedLt = &portSpeedLt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedLte(portSpeedLte []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedLte = &portSpeedLte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) PortSpeedN(portSpeedN []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.portSpeedN = &portSpeedN
	return r
}

// Provider Network (ID)
func (r ApiCircuitsCircuitTerminationsListRequest) ProviderNetworkId(providerNetworkId []*string) ApiCircuitsCircuitTerminationsListRequest {
	r.providerNetworkId = &providerNetworkId
	return r
}

// Provider Network (ID)
func (r ApiCircuitsCircuitTerminationsListRequest) ProviderNetworkIdN(providerNetworkIdN []*string) ApiCircuitsCircuitTerminationsListRequest {
	r.providerNetworkIdN = &providerNetworkIdN
	return r
}

// Search
func (r ApiCircuitsCircuitTerminationsListRequest) Q(q string) ApiCircuitsCircuitTerminationsListRequest {
	r.q = &q
	return r
}

// Site (slug)
func (r ApiCircuitsCircuitTerminationsListRequest) Site(site []string) ApiCircuitsCircuitTerminationsListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiCircuitsCircuitTerminationsListRequest) SiteN(siteN []string) ApiCircuitsCircuitTerminationsListRequest {
	r.siteN = &siteN
	return r
}

// Site (ID)
func (r ApiCircuitsCircuitTerminationsListRequest) SiteId(siteId []*string) ApiCircuitsCircuitTerminationsListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiCircuitsCircuitTerminationsListRequest) SiteIdN(siteIdN []*string) ApiCircuitsCircuitTerminationsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) TermSide(termSide string) ApiCircuitsCircuitTerminationsListRequest {
	r.termSide = &termSide
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) TermSideN(termSideN string) ApiCircuitsCircuitTerminationsListRequest {
	r.termSideN = &termSideN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeed(upstreamSpeed []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeed = &upstreamSpeed
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedGt(upstreamSpeedGt []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedGt = &upstreamSpeedGt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedGte(upstreamSpeedGte []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedGte = &upstreamSpeedGte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedLt(upstreamSpeedLt []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedLt = &upstreamSpeedLt
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedLte(upstreamSpeedLte []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedLte = &upstreamSpeedLte
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) UpstreamSpeedN(upstreamSpeedN []int32) ApiCircuitsCircuitTerminationsListRequest {
	r.upstreamSpeedN = &upstreamSpeedN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectId(xconnectId []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectId = &xconnectId
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIc(xconnectIdIc []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIc = &xconnectIdIc
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIe(xconnectIdIe []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIe = &xconnectIdIe
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIew(xconnectIdIew []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIew = &xconnectIdIew
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIre(xconnectIdIre []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIre = &xconnectIdIre
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdIsw(xconnectIdIsw []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdIsw = &xconnectIdIsw
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdN(xconnectIdN []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdN = &xconnectIdN
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNic(xconnectIdNic []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNic = &xconnectIdNic
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNie(xconnectIdNie []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNie = &xconnectIdNie
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNiew(xconnectIdNiew []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNiew = &xconnectIdNiew
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNire(xconnectIdNire []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNire = &xconnectIdNire
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNisw(xconnectIdNisw []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNisw = &xconnectIdNisw
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdNre(xconnectIdNre []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdNre = &xconnectIdNre
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) XconnectIdRe(xconnectIdRe []string) ApiCircuitsCircuitTerminationsListRequest {
	r.xconnectIdRe = &xconnectIdRe
	return r
}

func (r ApiCircuitsCircuitTerminationsListRequest) Execute() (*PaginatedCircuitTerminationList, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsListExecute(r)
}

/*
CircuitsCircuitTerminationsList Method for CircuitsCircuitTerminationsList

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTerminationsListRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsList(ctx context.Context) ApiCircuitsCircuitTerminationsListRequest {
	return ApiCircuitsCircuitTerminationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedCircuitTerminationList
func (a *CircuitsApiService) CircuitsCircuitTerminationsListExecute(r ApiCircuitsCircuitTerminationsListRequest) (*PaginatedCircuitTerminationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedCircuitTerminationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cabled != nil {
		localVarQueryParams.Add("cabled", parameterToString(*r.cabled, ""))
	}
	if r.circuitId != nil {
		t := *r.circuitId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("circuit_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("circuit_id", parameterToString(t, "multi"))
		}
	}
	if r.circuitIdN != nil {
		t := *r.circuitIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("circuit_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("circuit_id__n", parameterToString(t, "multi"))
		}
	}
	if r.connected != nil {
		localVarQueryParams.Add("connected", parameterToString(*r.connected, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.portSpeed != nil {
		t := *r.portSpeed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("port_speed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("port_speed", parameterToString(t, "multi"))
		}
	}
	if r.portSpeedGt != nil {
		t := *r.portSpeedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("port_speed__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("port_speed__gt", parameterToString(t, "multi"))
		}
	}
	if r.portSpeedGte != nil {
		t := *r.portSpeedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("port_speed__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("port_speed__gte", parameterToString(t, "multi"))
		}
	}
	if r.portSpeedLt != nil {
		t := *r.portSpeedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("port_speed__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("port_speed__lt", parameterToString(t, "multi"))
		}
	}
	if r.portSpeedLte != nil {
		t := *r.portSpeedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("port_speed__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("port_speed__lte", parameterToString(t, "multi"))
		}
	}
	if r.portSpeedN != nil {
		t := *r.portSpeedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("port_speed__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("port_speed__n", parameterToString(t, "multi"))
		}
	}
	if r.providerNetworkId != nil {
		t := *r.providerNetworkId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_network_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_network_id", parameterToString(t, "multi"))
		}
	}
	if r.providerNetworkIdN != nil {
		t := *r.providerNetworkIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_network_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_network_id__n", parameterToString(t, "multi"))
		}
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site", parameterToString(t, "multi"))
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site__n", parameterToString(t, "multi"))
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id", parameterToString(t, "multi"))
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id__n", parameterToString(t, "multi"))
		}
	}
	if r.termSide != nil {
		localVarQueryParams.Add("term_side", parameterToString(*r.termSide, ""))
	}
	if r.termSideN != nil {
		localVarQueryParams.Add("term_side__n", parameterToString(*r.termSideN, ""))
	}
	if r.upstreamSpeed != nil {
		t := *r.upstreamSpeed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("upstream_speed", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("upstream_speed", parameterToString(t, "multi"))
		}
	}
	if r.upstreamSpeedGt != nil {
		t := *r.upstreamSpeedGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("upstream_speed__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("upstream_speed__gt", parameterToString(t, "multi"))
		}
	}
	if r.upstreamSpeedGte != nil {
		t := *r.upstreamSpeedGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("upstream_speed__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("upstream_speed__gte", parameterToString(t, "multi"))
		}
	}
	if r.upstreamSpeedLt != nil {
		t := *r.upstreamSpeedLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("upstream_speed__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("upstream_speed__lt", parameterToString(t, "multi"))
		}
	}
	if r.upstreamSpeedLte != nil {
		t := *r.upstreamSpeedLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("upstream_speed__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("upstream_speed__lte", parameterToString(t, "multi"))
		}
	}
	if r.upstreamSpeedN != nil {
		t := *r.upstreamSpeedN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("upstream_speed__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("upstream_speed__n", parameterToString(t, "multi"))
		}
	}
	if r.xconnectId != nil {
		t := *r.xconnectId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdIc != nil {
		t := *r.xconnectIdIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__ic", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdIe != nil {
		t := *r.xconnectIdIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__ie", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdIew != nil {
		t := *r.xconnectIdIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__iew", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdIre != nil {
		t := *r.xconnectIdIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__ire", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdIsw != nil {
		t := *r.xconnectIdIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__isw", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdN != nil {
		t := *r.xconnectIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__n", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdNic != nil {
		t := *r.xconnectIdNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__nic", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdNie != nil {
		t := *r.xconnectIdNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__nie", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdNiew != nil {
		t := *r.xconnectIdNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__niew", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdNire != nil {
		t := *r.xconnectIdNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__nire", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdNisw != nil {
		t := *r.xconnectIdNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdNre != nil {
		t := *r.xconnectIdNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__nre", parameterToString(t, "multi"))
		}
	}
	if r.xconnectIdRe != nil {
		t := *r.xconnectIdRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("xconnect_id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("xconnect_id__re", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	patchedWritableCircuitTermination *PatchedWritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsPartialUpdateRequest) PatchedWritableCircuitTermination(patchedWritableCircuitTermination PatchedWritableCircuitTermination) ApiCircuitsCircuitTerminationsPartialUpdateRequest {
	r.patchedWritableCircuitTermination = &patchedWritableCircuitTermination
	return r
}

func (r ApiCircuitsCircuitTerminationsPartialUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsPartialUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsPartialUpdate Method for CircuitsCircuitTerminationsPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsPartialUpdate(ctx context.Context, id string) ApiCircuitsCircuitTerminationsPartialUpdateRequest {
	return ApiCircuitsCircuitTerminationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsPartialUpdateExecute(r ApiCircuitsCircuitTerminationsPartialUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableCircuitTermination
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsRetrieveRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsCircuitTerminationsRetrieveRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsRetrieveExecute(r)
}

/*
CircuitsCircuitTerminationsRetrieve Method for CircuitsCircuitTerminationsRetrieve

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsRetrieveRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsRetrieve(ctx context.Context, id string) ApiCircuitsCircuitTerminationsRetrieveRequest {
	return ApiCircuitsCircuitTerminationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsRetrieveExecute(r ApiCircuitsCircuitTerminationsRetrieveRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsTraceRetrieveRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsCircuitTerminationsTraceRetrieveRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsTraceRetrieveExecute(r)
}

/*
CircuitsCircuitTerminationsTraceRetrieve Method for CircuitsCircuitTerminationsTraceRetrieve

Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsTraceRetrieveRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsTraceRetrieve(ctx context.Context, id string) ApiCircuitsCircuitTerminationsTraceRetrieveRequest {
	return ApiCircuitsCircuitTerminationsTraceRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsTraceRetrieveExecute(r ApiCircuitsCircuitTerminationsTraceRetrieveRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsTraceRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/trace/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTerminationsUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	writableCircuitTermination *WritableCircuitTermination
}

func (r ApiCircuitsCircuitTerminationsUpdateRequest) WritableCircuitTermination(writableCircuitTermination WritableCircuitTermination) ApiCircuitsCircuitTerminationsUpdateRequest {
	r.writableCircuitTermination = &writableCircuitTermination
	return r
}

func (r ApiCircuitsCircuitTerminationsUpdateRequest) Execute() (*CircuitTermination, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTerminationsUpdateExecute(r)
}

/*
CircuitsCircuitTerminationsUpdate Method for CircuitsCircuitTerminationsUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit termination.
 @return ApiCircuitsCircuitTerminationsUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTerminationsUpdate(ctx context.Context, id string) ApiCircuitsCircuitTerminationsUpdateRequest {
	return ApiCircuitsCircuitTerminationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitTermination
func (a *CircuitsApiService) CircuitsCircuitTerminationsUpdateExecute(r ApiCircuitsCircuitTerminationsUpdateRequest) (*CircuitTermination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitTermination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTerminationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-terminations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCircuitTermination == nil {
		return localVarReturnValue, nil, reportError("writableCircuitTermination is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCircuitTermination
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesBulkDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsCircuitTypesBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesBulkDestroyExecute(r)
}

/*
CircuitsCircuitTypesBulkDestroy Method for CircuitsCircuitTypesBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesBulkDestroyRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesBulkDestroy(ctx context.Context) ApiCircuitsCircuitTypesBulkDestroyRequest {
	return ApiCircuitsCircuitTypesBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTypesBulkDestroyExecute(r ApiCircuitsCircuitTypesBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	patchedCircuitType *PatchedCircuitType
}

func (r ApiCircuitsCircuitTypesBulkPartialUpdateRequest) PatchedCircuitType(patchedCircuitType PatchedCircuitType) ApiCircuitsCircuitTypesBulkPartialUpdateRequest {
	r.patchedCircuitType = &patchedCircuitType
	return r
}

func (r ApiCircuitsCircuitTypesBulkPartialUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesBulkPartialUpdateExecute(r)
}

/*
CircuitsCircuitTypesBulkPartialUpdate Method for CircuitsCircuitTypesBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesBulkPartialUpdate(ctx context.Context) ApiCircuitsCircuitTypesBulkPartialUpdateRequest {
	return ApiCircuitsCircuitTypesBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesBulkPartialUpdateExecute(r ApiCircuitsCircuitTypesBulkPartialUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedCircuitType
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	circuitType *CircuitType
}

func (r ApiCircuitsCircuitTypesBulkUpdateRequest) CircuitType(circuitType CircuitType) ApiCircuitsCircuitTypesBulkUpdateRequest {
	r.circuitType = &circuitType
	return r
}

func (r ApiCircuitsCircuitTypesBulkUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesBulkUpdateExecute(r)
}

/*
CircuitsCircuitTypesBulkUpdate Method for CircuitsCircuitTypesBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesBulkUpdate(ctx context.Context) ApiCircuitsCircuitTypesBulkUpdateRequest {
	return ApiCircuitsCircuitTypesBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesBulkUpdateExecute(r ApiCircuitsCircuitTypesBulkUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.circuitType == nil {
		return localVarReturnValue, nil, reportError("circuitType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.circuitType
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	circuitType *CircuitType
}

func (r ApiCircuitsCircuitTypesCreateRequest) CircuitType(circuitType CircuitType) ApiCircuitsCircuitTypesCreateRequest {
	r.circuitType = &circuitType
	return r
}

func (r ApiCircuitsCircuitTypesCreateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesCreateExecute(r)
}

/*
CircuitsCircuitTypesCreate Method for CircuitsCircuitTypesCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesCreateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesCreate(ctx context.Context) ApiCircuitsCircuitTypesCreateRequest {
	return ApiCircuitsCircuitTypesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesCreateExecute(r ApiCircuitsCircuitTypesCreateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.circuitType == nil {
		return localVarReturnValue, nil, reportError("circuitType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.circuitType
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsCircuitTypesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesDestroyExecute(r)
}

/*
CircuitsCircuitTypesDestroy Method for CircuitsCircuitTypesDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit type.
 @return ApiCircuitsCircuitTypesDestroyRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesDestroy(ctx context.Context, id string) ApiCircuitsCircuitTypesDestroyRequest {
	return ApiCircuitsCircuitTypesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitTypesDestroyExecute(r ApiCircuitsCircuitTypesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	created *string
	createdGte *string
	createdLte *string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	slug *[]string
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIre *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNire *[]string
	slugNisw *[]string
	slugNre *[]string
	slugRe *[]string
}

func (r ApiCircuitsCircuitTypesListRequest) Created(created string) ApiCircuitsCircuitTypesListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) CreatedGte(createdGte string) ApiCircuitsCircuitTypesListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) CreatedLte(createdLte string) ApiCircuitsCircuitTypesListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Id(id []string) ApiCircuitsCircuitTypesListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdIc(idIc []string) ApiCircuitsCircuitTypesListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdIe(idIe []string) ApiCircuitsCircuitTypesListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdIew(idIew []string) ApiCircuitsCircuitTypesListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdIre(idIre []string) ApiCircuitsCircuitTypesListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdIsw(idIsw []string) ApiCircuitsCircuitTypesListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdN(idN []string) ApiCircuitsCircuitTypesListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdNic(idNic []string) ApiCircuitsCircuitTypesListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdNie(idNie []string) ApiCircuitsCircuitTypesListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdNiew(idNiew []string) ApiCircuitsCircuitTypesListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdNire(idNire []string) ApiCircuitsCircuitTypesListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdNisw(idNisw []string) ApiCircuitsCircuitTypesListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdNre(idNre []string) ApiCircuitsCircuitTypesListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) IdRe(idRe []string) ApiCircuitsCircuitTypesListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) LastUpdated(lastUpdated time.Time) ApiCircuitsCircuitTypesListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiCircuitsCircuitTypesListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiCircuitsCircuitTypesListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiCircuitsCircuitTypesListRequest) Limit(limit int32) ApiCircuitsCircuitTypesListRequest {
	r.limit = &limit
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Name(name []string) ApiCircuitsCircuitTypesListRequest {
	r.name = &name
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIc(nameIc []string) ApiCircuitsCircuitTypesListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIe(nameIe []string) ApiCircuitsCircuitTypesListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIew(nameIew []string) ApiCircuitsCircuitTypesListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIre(nameIre []string) ApiCircuitsCircuitTypesListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameIsw(nameIsw []string) ApiCircuitsCircuitTypesListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameN(nameN []string) ApiCircuitsCircuitTypesListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNic(nameNic []string) ApiCircuitsCircuitTypesListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNie(nameNie []string) ApiCircuitsCircuitTypesListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNiew(nameNiew []string) ApiCircuitsCircuitTypesListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNire(nameNire []string) ApiCircuitsCircuitTypesListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNisw(nameNisw []string) ApiCircuitsCircuitTypesListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameNre(nameNre []string) ApiCircuitsCircuitTypesListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) NameRe(nameRe []string) ApiCircuitsCircuitTypesListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsCircuitTypesListRequest) Offset(offset int32) ApiCircuitsCircuitTypesListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiCircuitsCircuitTypesListRequest) Q(q string) ApiCircuitsCircuitTypesListRequest {
	r.q = &q
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Slug(slug []string) ApiCircuitsCircuitTypesListRequest {
	r.slug = &slug
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIc(slugIc []string) ApiCircuitsCircuitTypesListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIe(slugIe []string) ApiCircuitsCircuitTypesListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIew(slugIew []string) ApiCircuitsCircuitTypesListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIre(slugIre []string) ApiCircuitsCircuitTypesListRequest {
	r.slugIre = &slugIre
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugIsw(slugIsw []string) ApiCircuitsCircuitTypesListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugN(slugN []string) ApiCircuitsCircuitTypesListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNic(slugNic []string) ApiCircuitsCircuitTypesListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNie(slugNie []string) ApiCircuitsCircuitTypesListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNiew(slugNiew []string) ApiCircuitsCircuitTypesListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNire(slugNire []string) ApiCircuitsCircuitTypesListRequest {
	r.slugNire = &slugNire
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNisw(slugNisw []string) ApiCircuitsCircuitTypesListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugNre(slugNre []string) ApiCircuitsCircuitTypesListRequest {
	r.slugNre = &slugNre
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) SlugRe(slugRe []string) ApiCircuitsCircuitTypesListRequest {
	r.slugRe = &slugRe
	return r
}

func (r ApiCircuitsCircuitTypesListRequest) Execute() (*PaginatedCircuitTypeList, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesListExecute(r)
}

/*
CircuitsCircuitTypesList Method for CircuitsCircuitTypesList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitTypesListRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesList(ctx context.Context) ApiCircuitsCircuitTypesListRequest {
	return ApiCircuitsCircuitTypesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedCircuitTypeList
func (a *CircuitsApiService) CircuitsCircuitTypesListExecute(r ApiCircuitsCircuitTypesListRequest) (*PaginatedCircuitTypeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedCircuitTypeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug", parameterToString(t, "multi"))
		}
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ic", parameterToString(t, "multi"))
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ie", parameterToString(t, "multi"))
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__iew", parameterToString(t, "multi"))
		}
	}
	if r.slugIre != nil {
		t := *r.slugIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ire", parameterToString(t, "multi"))
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__isw", parameterToString(t, "multi"))
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__n", parameterToString(t, "multi"))
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nic", parameterToString(t, "multi"))
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nie", parameterToString(t, "multi"))
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__niew", parameterToString(t, "multi"))
		}
	}
	if r.slugNire != nil {
		t := *r.slugNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nire", parameterToString(t, "multi"))
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nisw", parameterToString(t, "multi"))
		}
	}
	if r.slugNre != nil {
		t := *r.slugNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nre", parameterToString(t, "multi"))
		}
	}
	if r.slugRe != nil {
		t := *r.slugRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__re", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	patchedCircuitType *PatchedCircuitType
}

func (r ApiCircuitsCircuitTypesPartialUpdateRequest) PatchedCircuitType(patchedCircuitType PatchedCircuitType) ApiCircuitsCircuitTypesPartialUpdateRequest {
	r.patchedCircuitType = &patchedCircuitType
	return r
}

func (r ApiCircuitsCircuitTypesPartialUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesPartialUpdateExecute(r)
}

/*
CircuitsCircuitTypesPartialUpdate Method for CircuitsCircuitTypesPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit type.
 @return ApiCircuitsCircuitTypesPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesPartialUpdate(ctx context.Context, id string) ApiCircuitsCircuitTypesPartialUpdateRequest {
	return ApiCircuitsCircuitTypesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesPartialUpdateExecute(r ApiCircuitsCircuitTypesPartialUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedCircuitType
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesRetrieveRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsCircuitTypesRetrieveRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesRetrieveExecute(r)
}

/*
CircuitsCircuitTypesRetrieve Method for CircuitsCircuitTypesRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit type.
 @return ApiCircuitsCircuitTypesRetrieveRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesRetrieve(ctx context.Context, id string) ApiCircuitsCircuitTypesRetrieveRequest {
	return ApiCircuitsCircuitTypesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesRetrieveExecute(r ApiCircuitsCircuitTypesRetrieveRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitTypesUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	circuitType *CircuitType
}

func (r ApiCircuitsCircuitTypesUpdateRequest) CircuitType(circuitType CircuitType) ApiCircuitsCircuitTypesUpdateRequest {
	r.circuitType = &circuitType
	return r
}

func (r ApiCircuitsCircuitTypesUpdateRequest) Execute() (*CircuitType, *http.Response, error) {
	return r.ApiService.CircuitsCircuitTypesUpdateExecute(r)
}

/*
CircuitsCircuitTypesUpdate Method for CircuitsCircuitTypesUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit type.
 @return ApiCircuitsCircuitTypesUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitTypesUpdate(ctx context.Context, id string) ApiCircuitsCircuitTypesUpdateRequest {
	return ApiCircuitsCircuitTypesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CircuitType
func (a *CircuitsApiService) CircuitsCircuitTypesUpdateExecute(r ApiCircuitsCircuitTypesUpdateRequest) (*CircuitType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CircuitType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitTypesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuit-types/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.circuitType == nil {
		return localVarReturnValue, nil, reportError("circuitType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.circuitType
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsCircuitsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitsBulkDestroyExecute(r)
}

/*
CircuitsCircuitsBulkDestroy Method for CircuitsCircuitsBulkDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsBulkDestroyRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsBulkDestroy(ctx context.Context) ApiCircuitsCircuitsBulkDestroyRequest {
	return ApiCircuitsCircuitsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitsBulkDestroyExecute(r ApiCircuitsCircuitsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	patchedWritableCircuit *PatchedWritableCircuit
}

func (r ApiCircuitsCircuitsBulkPartialUpdateRequest) PatchedWritableCircuit(patchedWritableCircuit PatchedWritableCircuit) ApiCircuitsCircuitsBulkPartialUpdateRequest {
	r.patchedWritableCircuit = &patchedWritableCircuit
	return r
}

func (r ApiCircuitsCircuitsBulkPartialUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsBulkPartialUpdateExecute(r)
}

/*
CircuitsCircuitsBulkPartialUpdate Method for CircuitsCircuitsBulkPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsBulkPartialUpdate(ctx context.Context) ApiCircuitsCircuitsBulkPartialUpdateRequest {
	return ApiCircuitsCircuitsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsBulkPartialUpdateExecute(r ApiCircuitsCircuitsBulkPartialUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableCircuit
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	writableCircuit *WritableCircuit
}

func (r ApiCircuitsCircuitsBulkUpdateRequest) WritableCircuit(writableCircuit WritableCircuit) ApiCircuitsCircuitsBulkUpdateRequest {
	r.writableCircuit = &writableCircuit
	return r
}

func (r ApiCircuitsCircuitsBulkUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsBulkUpdateExecute(r)
}

/*
CircuitsCircuitsBulkUpdate Method for CircuitsCircuitsBulkUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsBulkUpdate(ctx context.Context) ApiCircuitsCircuitsBulkUpdateRequest {
	return ApiCircuitsCircuitsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsBulkUpdateExecute(r ApiCircuitsCircuitsBulkUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCircuit == nil {
		return localVarReturnValue, nil, reportError("writableCircuit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCircuit
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	writableCircuit *WritableCircuit
}

func (r ApiCircuitsCircuitsCreateRequest) WritableCircuit(writableCircuit WritableCircuit) ApiCircuitsCircuitsCreateRequest {
	r.writableCircuit = &writableCircuit
	return r
}

func (r ApiCircuitsCircuitsCreateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsCreateExecute(r)
}

/*
CircuitsCircuitsCreate Method for CircuitsCircuitsCreate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsCreateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsCreate(ctx context.Context) ApiCircuitsCircuitsCreateRequest {
	return ApiCircuitsCircuitsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsCreateExecute(r ApiCircuitsCircuitsCreateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCircuit == nil {
		return localVarReturnValue, nil, reportError("writableCircuit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCircuit
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsCircuitsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsCircuitsDestroyExecute(r)
}

/*
CircuitsCircuitsDestroy Method for CircuitsCircuitsDestroy

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit.
 @return ApiCircuitsCircuitsDestroyRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsDestroy(ctx context.Context, id string) ApiCircuitsCircuitsDestroyRequest {
	return ApiCircuitsCircuitsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsCircuitsDestroyExecute(r ApiCircuitsCircuitsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	cid *[]string
	cidIc *[]string
	cidIe *[]string
	cidIew *[]string
	cidIre *[]string
	cidIsw *[]string
	cidN *[]string
	cidNic *[]string
	cidNie *[]string
	cidNiew *[]string
	cidNire *[]string
	cidNisw *[]string
	cidNre *[]string
	cidRe *[]string
	commitRate *[]int32
	commitRateGt *[]int32
	commitRateGte *[]int32
	commitRateLt *[]int32
	commitRateLte *[]int32
	commitRateN *[]int32
	created *string
	createdGte *string
	createdLte *string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	installDate *[]string
	installDateGt *[]string
	installDateGte *[]string
	installDateLt *[]string
	installDateLte *[]string
	installDateN *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	offset *int32
	provider *[]string
	providerN *[]string
	providerId *[]string
	providerIdN *[]string
	providerNetworkId *[]string
	providerNetworkIdN *[]string
	q *string
	region *[]string
	regionN *[]string
	regionId *[]string
	regionIdN *[]string
	site *[]string
	siteN *[]string
	siteId *[]string
	siteIdN *[]string
	status *[]string
	statusN *[]string
	tag *[]string
	tagN *[]string
	tenant *[]string
	tenantN *[]string
	tenantGroup *[]string
	tenantGroupN *[]string
	tenantGroupId *[]string
	tenantGroupIdN *[]string
	tenantId *[]*string
	tenantIdN *[]*string
	type_ *[]string
	typeN *[]string
	typeId *[]string
	typeIdN *[]string
}

func (r ApiCircuitsCircuitsListRequest) Cid(cid []string) ApiCircuitsCircuitsListRequest {
	r.cid = &cid
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIc(cidIc []string) ApiCircuitsCircuitsListRequest {
	r.cidIc = &cidIc
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIe(cidIe []string) ApiCircuitsCircuitsListRequest {
	r.cidIe = &cidIe
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIew(cidIew []string) ApiCircuitsCircuitsListRequest {
	r.cidIew = &cidIew
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIre(cidIre []string) ApiCircuitsCircuitsListRequest {
	r.cidIre = &cidIre
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidIsw(cidIsw []string) ApiCircuitsCircuitsListRequest {
	r.cidIsw = &cidIsw
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidN(cidN []string) ApiCircuitsCircuitsListRequest {
	r.cidN = &cidN
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNic(cidNic []string) ApiCircuitsCircuitsListRequest {
	r.cidNic = &cidNic
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNie(cidNie []string) ApiCircuitsCircuitsListRequest {
	r.cidNie = &cidNie
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNiew(cidNiew []string) ApiCircuitsCircuitsListRequest {
	r.cidNiew = &cidNiew
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNire(cidNire []string) ApiCircuitsCircuitsListRequest {
	r.cidNire = &cidNire
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNisw(cidNisw []string) ApiCircuitsCircuitsListRequest {
	r.cidNisw = &cidNisw
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidNre(cidNre []string) ApiCircuitsCircuitsListRequest {
	r.cidNre = &cidNre
	return r
}

func (r ApiCircuitsCircuitsListRequest) CidRe(cidRe []string) ApiCircuitsCircuitsListRequest {
	r.cidRe = &cidRe
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRate(commitRate []int32) ApiCircuitsCircuitsListRequest {
	r.commitRate = &commitRate
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateGt(commitRateGt []int32) ApiCircuitsCircuitsListRequest {
	r.commitRateGt = &commitRateGt
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateGte(commitRateGte []int32) ApiCircuitsCircuitsListRequest {
	r.commitRateGte = &commitRateGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateLt(commitRateLt []int32) ApiCircuitsCircuitsListRequest {
	r.commitRateLt = &commitRateLt
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateLte(commitRateLte []int32) ApiCircuitsCircuitsListRequest {
	r.commitRateLte = &commitRateLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) CommitRateN(commitRateN []int32) ApiCircuitsCircuitsListRequest {
	r.commitRateN = &commitRateN
	return r
}

func (r ApiCircuitsCircuitsListRequest) Created(created string) ApiCircuitsCircuitsListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsCircuitsListRequest) CreatedGte(createdGte string) ApiCircuitsCircuitsListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) CreatedLte(createdLte string) ApiCircuitsCircuitsListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) Id(id []string) ApiCircuitsCircuitsListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdIc(idIc []string) ApiCircuitsCircuitsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdIe(idIe []string) ApiCircuitsCircuitsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdIew(idIew []string) ApiCircuitsCircuitsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdIre(idIre []string) ApiCircuitsCircuitsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdIsw(idIsw []string) ApiCircuitsCircuitsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdN(idN []string) ApiCircuitsCircuitsListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdNic(idNic []string) ApiCircuitsCircuitsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdNie(idNie []string) ApiCircuitsCircuitsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdNiew(idNiew []string) ApiCircuitsCircuitsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdNire(idNire []string) ApiCircuitsCircuitsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdNisw(idNisw []string) ApiCircuitsCircuitsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdNre(idNre []string) ApiCircuitsCircuitsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiCircuitsCircuitsListRequest) IdRe(idRe []string) ApiCircuitsCircuitsListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDate(installDate []string) ApiCircuitsCircuitsListRequest {
	r.installDate = &installDate
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateGt(installDateGt []string) ApiCircuitsCircuitsListRequest {
	r.installDateGt = &installDateGt
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateGte(installDateGte []string) ApiCircuitsCircuitsListRequest {
	r.installDateGte = &installDateGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateLt(installDateLt []string) ApiCircuitsCircuitsListRequest {
	r.installDateLt = &installDateLt
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateLte(installDateLte []string) ApiCircuitsCircuitsListRequest {
	r.installDateLte = &installDateLte
	return r
}

func (r ApiCircuitsCircuitsListRequest) InstallDateN(installDateN []string) ApiCircuitsCircuitsListRequest {
	r.installDateN = &installDateN
	return r
}

func (r ApiCircuitsCircuitsListRequest) LastUpdated(lastUpdated time.Time) ApiCircuitsCircuitsListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsCircuitsListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiCircuitsCircuitsListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsCircuitsListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiCircuitsCircuitsListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiCircuitsCircuitsListRequest) Limit(limit int32) ApiCircuitsCircuitsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsCircuitsListRequest) Offset(offset int32) ApiCircuitsCircuitsListRequest {
	r.offset = &offset
	return r
}

// Provider (slug)
func (r ApiCircuitsCircuitsListRequest) Provider(provider []string) ApiCircuitsCircuitsListRequest {
	r.provider = &provider
	return r
}

// Provider (slug)
func (r ApiCircuitsCircuitsListRequest) ProviderN(providerN []string) ApiCircuitsCircuitsListRequest {
	r.providerN = &providerN
	return r
}

// Provider (ID)
func (r ApiCircuitsCircuitsListRequest) ProviderId(providerId []string) ApiCircuitsCircuitsListRequest {
	r.providerId = &providerId
	return r
}

// Provider (ID)
func (r ApiCircuitsCircuitsListRequest) ProviderIdN(providerIdN []string) ApiCircuitsCircuitsListRequest {
	r.providerIdN = &providerIdN
	return r
}

// Provider Network (ID)
func (r ApiCircuitsCircuitsListRequest) ProviderNetworkId(providerNetworkId []string) ApiCircuitsCircuitsListRequest {
	r.providerNetworkId = &providerNetworkId
	return r
}

// Provider Network (ID)
func (r ApiCircuitsCircuitsListRequest) ProviderNetworkIdN(providerNetworkIdN []string) ApiCircuitsCircuitsListRequest {
	r.providerNetworkIdN = &providerNetworkIdN
	return r
}

// Search
func (r ApiCircuitsCircuitsListRequest) Q(q string) ApiCircuitsCircuitsListRequest {
	r.q = &q
	return r
}

// Region (slug)
func (r ApiCircuitsCircuitsListRequest) Region(region []string) ApiCircuitsCircuitsListRequest {
	r.region = &region
	return r
}

// Region (slug)
func (r ApiCircuitsCircuitsListRequest) RegionN(regionN []string) ApiCircuitsCircuitsListRequest {
	r.regionN = &regionN
	return r
}

// Region (ID)
func (r ApiCircuitsCircuitsListRequest) RegionId(regionId []string) ApiCircuitsCircuitsListRequest {
	r.regionId = &regionId
	return r
}

// Region (ID)
func (r ApiCircuitsCircuitsListRequest) RegionIdN(regionIdN []string) ApiCircuitsCircuitsListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Site (slug)
func (r ApiCircuitsCircuitsListRequest) Site(site []string) ApiCircuitsCircuitsListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiCircuitsCircuitsListRequest) SiteN(siteN []string) ApiCircuitsCircuitsListRequest {
	r.siteN = &siteN
	return r
}

// Site (ID)
func (r ApiCircuitsCircuitsListRequest) SiteId(siteId []string) ApiCircuitsCircuitsListRequest {
	r.siteId = &siteId
	return r
}

// Site (ID)
func (r ApiCircuitsCircuitsListRequest) SiteIdN(siteIdN []string) ApiCircuitsCircuitsListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) Status(status []string) ApiCircuitsCircuitsListRequest {
	r.status = &status
	return r
}

func (r ApiCircuitsCircuitsListRequest) StatusN(statusN []string) ApiCircuitsCircuitsListRequest {
	r.statusN = &statusN
	return r
}

func (r ApiCircuitsCircuitsListRequest) Tag(tag []string) ApiCircuitsCircuitsListRequest {
	r.tag = &tag
	return r
}

func (r ApiCircuitsCircuitsListRequest) TagN(tagN []string) ApiCircuitsCircuitsListRequest {
	r.tagN = &tagN
	return r
}

// Tenant (slug)
func (r ApiCircuitsCircuitsListRequest) Tenant(tenant []string) ApiCircuitsCircuitsListRequest {
	r.tenant = &tenant
	return r
}

// Tenant (slug)
func (r ApiCircuitsCircuitsListRequest) TenantN(tenantN []string) ApiCircuitsCircuitsListRequest {
	r.tenantN = &tenantN
	return r
}

// Tenant Group (slug)
func (r ApiCircuitsCircuitsListRequest) TenantGroup(tenantGroup []string) ApiCircuitsCircuitsListRequest {
	r.tenantGroup = &tenantGroup
	return r
}

// Tenant Group (slug)
func (r ApiCircuitsCircuitsListRequest) TenantGroupN(tenantGroupN []string) ApiCircuitsCircuitsListRequest {
	r.tenantGroupN = &tenantGroupN
	return r
}

// Tenant Group (ID)
func (r ApiCircuitsCircuitsListRequest) TenantGroupId(tenantGroupId []string) ApiCircuitsCircuitsListRequest {
	r.tenantGroupId = &tenantGroupId
	return r
}

// Tenant Group (ID)
func (r ApiCircuitsCircuitsListRequest) TenantGroupIdN(tenantGroupIdN []string) ApiCircuitsCircuitsListRequest {
	r.tenantGroupIdN = &tenantGroupIdN
	return r
}

// Tenant (ID)
func (r ApiCircuitsCircuitsListRequest) TenantId(tenantId []*string) ApiCircuitsCircuitsListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant (ID)
func (r ApiCircuitsCircuitsListRequest) TenantIdN(tenantIdN []*string) ApiCircuitsCircuitsListRequest {
	r.tenantIdN = &tenantIdN
	return r
}

// Circuit type (slug)
func (r ApiCircuitsCircuitsListRequest) Type_(type_ []string) ApiCircuitsCircuitsListRequest {
	r.type_ = &type_
	return r
}

// Circuit type (slug)
func (r ApiCircuitsCircuitsListRequest) TypeN(typeN []string) ApiCircuitsCircuitsListRequest {
	r.typeN = &typeN
	return r
}

// Circuit type (ID)
func (r ApiCircuitsCircuitsListRequest) TypeId(typeId []string) ApiCircuitsCircuitsListRequest {
	r.typeId = &typeId
	return r
}

// Circuit type (ID)
func (r ApiCircuitsCircuitsListRequest) TypeIdN(typeIdN []string) ApiCircuitsCircuitsListRequest {
	r.typeIdN = &typeIdN
	return r
}

func (r ApiCircuitsCircuitsListRequest) Execute() (*PaginatedCircuitList, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsListExecute(r)
}

/*
CircuitsCircuitsList Method for CircuitsCircuitsList

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsCircuitsListRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsList(ctx context.Context) ApiCircuitsCircuitsListRequest {
	return ApiCircuitsCircuitsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedCircuitList
func (a *CircuitsApiService) CircuitsCircuitsListExecute(r ApiCircuitsCircuitsListRequest) (*PaginatedCircuitList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedCircuitList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cid != nil {
		t := *r.cid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid", parameterToString(t, "multi"))
		}
	}
	if r.cidIc != nil {
		t := *r.cidIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__ic", parameterToString(t, "multi"))
		}
	}
	if r.cidIe != nil {
		t := *r.cidIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__ie", parameterToString(t, "multi"))
		}
	}
	if r.cidIew != nil {
		t := *r.cidIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__iew", parameterToString(t, "multi"))
		}
	}
	if r.cidIre != nil {
		t := *r.cidIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__ire", parameterToString(t, "multi"))
		}
	}
	if r.cidIsw != nil {
		t := *r.cidIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__isw", parameterToString(t, "multi"))
		}
	}
	if r.cidN != nil {
		t := *r.cidN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__n", parameterToString(t, "multi"))
		}
	}
	if r.cidNic != nil {
		t := *r.cidNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__nic", parameterToString(t, "multi"))
		}
	}
	if r.cidNie != nil {
		t := *r.cidNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__nie", parameterToString(t, "multi"))
		}
	}
	if r.cidNiew != nil {
		t := *r.cidNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__niew", parameterToString(t, "multi"))
		}
	}
	if r.cidNire != nil {
		t := *r.cidNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__nire", parameterToString(t, "multi"))
		}
	}
	if r.cidNisw != nil {
		t := *r.cidNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__nisw", parameterToString(t, "multi"))
		}
	}
	if r.cidNre != nil {
		t := *r.cidNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__nre", parameterToString(t, "multi"))
		}
	}
	if r.cidRe != nil {
		t := *r.cidRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("cid__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("cid__re", parameterToString(t, "multi"))
		}
	}
	if r.commitRate != nil {
		t := *r.commitRate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("commit_rate", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("commit_rate", parameterToString(t, "multi"))
		}
	}
	if r.commitRateGt != nil {
		t := *r.commitRateGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("commit_rate__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("commit_rate__gt", parameterToString(t, "multi"))
		}
	}
	if r.commitRateGte != nil {
		t := *r.commitRateGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("commit_rate__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("commit_rate__gte", parameterToString(t, "multi"))
		}
	}
	if r.commitRateLt != nil {
		t := *r.commitRateLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("commit_rate__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("commit_rate__lt", parameterToString(t, "multi"))
		}
	}
	if r.commitRateLte != nil {
		t := *r.commitRateLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("commit_rate__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("commit_rate__lte", parameterToString(t, "multi"))
		}
	}
	if r.commitRateN != nil {
		t := *r.commitRateN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("commit_rate__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("commit_rate__n", parameterToString(t, "multi"))
		}
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.installDate != nil {
		t := *r.installDate
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("install_date", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("install_date", parameterToString(t, "multi"))
		}
	}
	if r.installDateGt != nil {
		t := *r.installDateGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("install_date__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("install_date__gt", parameterToString(t, "multi"))
		}
	}
	if r.installDateGte != nil {
		t := *r.installDateGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("install_date__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("install_date__gte", parameterToString(t, "multi"))
		}
	}
	if r.installDateLt != nil {
		t := *r.installDateLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("install_date__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("install_date__lt", parameterToString(t, "multi"))
		}
	}
	if r.installDateLte != nil {
		t := *r.installDateLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("install_date__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("install_date__lte", parameterToString(t, "multi"))
		}
	}
	if r.installDateN != nil {
		t := *r.installDateN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("install_date__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("install_date__n", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.provider != nil {
		t := *r.provider
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider", parameterToString(t, "multi"))
		}
	}
	if r.providerN != nil {
		t := *r.providerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider__n", parameterToString(t, "multi"))
		}
	}
	if r.providerId != nil {
		t := *r.providerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_id", parameterToString(t, "multi"))
		}
	}
	if r.providerIdN != nil {
		t := *r.providerIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_id__n", parameterToString(t, "multi"))
		}
	}
	if r.providerNetworkId != nil {
		t := *r.providerNetworkId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_network_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_network_id", parameterToString(t, "multi"))
		}
	}
	if r.providerNetworkIdN != nil {
		t := *r.providerNetworkIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_network_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_network_id__n", parameterToString(t, "multi"))
		}
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region", parameterToString(t, "multi"))
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region__n", parameterToString(t, "multi"))
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id", parameterToString(t, "multi"))
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id__n", parameterToString(t, "multi"))
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site", parameterToString(t, "multi"))
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site__n", parameterToString(t, "multi"))
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id", parameterToString(t, "multi"))
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id__n", parameterToString(t, "multi"))
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status", parameterToString(t, "multi"))
		}
	}
	if r.statusN != nil {
		t := *r.statusN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("status__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("status__n", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	if r.tenant != nil {
		t := *r.tenant
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant", parameterToString(t, "multi"))
		}
	}
	if r.tenantN != nil {
		t := *r.tenantN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroup != nil {
		t := *r.tenantGroup
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupN != nil {
		t := *r.tenantGroupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupId != nil {
		t := *r.tenantGroupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantGroupIdN != nil {
		t := *r.tenantGroupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.tenantId != nil {
		t := *r.tenantId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id", parameterToString(t, "multi"))
		}
	}
	if r.tenantIdN != nil {
		t := *r.tenantIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tenant_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tenant_id__n", parameterToString(t, "multi"))
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type", parameterToString(t, "multi"))
		}
	}
	if r.typeN != nil {
		t := *r.typeN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type__n", parameterToString(t, "multi"))
		}
	}
	if r.typeId != nil {
		t := *r.typeId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type_id", parameterToString(t, "multi"))
		}
	}
	if r.typeIdN != nil {
		t := *r.typeIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	patchedWritableCircuit *PatchedWritableCircuit
}

func (r ApiCircuitsCircuitsPartialUpdateRequest) PatchedWritableCircuit(patchedWritableCircuit PatchedWritableCircuit) ApiCircuitsCircuitsPartialUpdateRequest {
	r.patchedWritableCircuit = &patchedWritableCircuit
	return r
}

func (r ApiCircuitsCircuitsPartialUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsPartialUpdateExecute(r)
}

/*
CircuitsCircuitsPartialUpdate Method for CircuitsCircuitsPartialUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit.
 @return ApiCircuitsCircuitsPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsPartialUpdate(ctx context.Context, id string) ApiCircuitsCircuitsPartialUpdateRequest {
	return ApiCircuitsCircuitsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsPartialUpdateExecute(r ApiCircuitsCircuitsPartialUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableCircuit
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsRetrieveRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsCircuitsRetrieveRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsRetrieveExecute(r)
}

/*
CircuitsCircuitsRetrieve Method for CircuitsCircuitsRetrieve

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit.
 @return ApiCircuitsCircuitsRetrieveRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsRetrieve(ctx context.Context, id string) ApiCircuitsCircuitsRetrieveRequest {
	return ApiCircuitsCircuitsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsRetrieveExecute(r ApiCircuitsCircuitsRetrieveRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsCircuitsUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	writableCircuit *WritableCircuit
}

func (r ApiCircuitsCircuitsUpdateRequest) WritableCircuit(writableCircuit WritableCircuit) ApiCircuitsCircuitsUpdateRequest {
	r.writableCircuit = &writableCircuit
	return r
}

func (r ApiCircuitsCircuitsUpdateRequest) Execute() (*Circuit, *http.Response, error) {
	return r.ApiService.CircuitsCircuitsUpdateExecute(r)
}

/*
CircuitsCircuitsUpdate Method for CircuitsCircuitsUpdate

Mixin to set `metadata_class` to implement `status` field in model viewset metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this circuit.
 @return ApiCircuitsCircuitsUpdateRequest
*/
func (a *CircuitsApiService) CircuitsCircuitsUpdate(ctx context.Context, id string) ApiCircuitsCircuitsUpdateRequest {
	return ApiCircuitsCircuitsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Circuit
func (a *CircuitsApiService) CircuitsCircuitsUpdateExecute(r ApiCircuitsCircuitsUpdateRequest) (*Circuit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Circuit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsCircuitsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/circuits/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableCircuit == nil {
		return localVarReturnValue, nil, reportError("writableCircuit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableCircuit
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksBulkDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsProviderNetworksBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksBulkDestroyExecute(r)
}

/*
CircuitsProviderNetworksBulkDestroy Method for CircuitsProviderNetworksBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksBulkDestroyRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksBulkDestroy(ctx context.Context) ApiCircuitsProviderNetworksBulkDestroyRequest {
	return ApiCircuitsProviderNetworksBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProviderNetworksBulkDestroyExecute(r ApiCircuitsProviderNetworksBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	patchedWritableProviderNetwork *PatchedWritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksBulkPartialUpdateRequest) PatchedWritableProviderNetwork(patchedWritableProviderNetwork PatchedWritableProviderNetwork) ApiCircuitsProviderNetworksBulkPartialUpdateRequest {
	r.patchedWritableProviderNetwork = &patchedWritableProviderNetwork
	return r
}

func (r ApiCircuitsProviderNetworksBulkPartialUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksBulkPartialUpdateExecute(r)
}

/*
CircuitsProviderNetworksBulkPartialUpdate Method for CircuitsProviderNetworksBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksBulkPartialUpdate(ctx context.Context) ApiCircuitsProviderNetworksBulkPartialUpdateRequest {
	return ApiCircuitsProviderNetworksBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksBulkPartialUpdateExecute(r ApiCircuitsProviderNetworksBulkPartialUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableProviderNetwork
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	writableProviderNetwork *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksBulkUpdateRequest) WritableProviderNetwork(writableProviderNetwork WritableProviderNetwork) ApiCircuitsProviderNetworksBulkUpdateRequest {
	r.writableProviderNetwork = &writableProviderNetwork
	return r
}

func (r ApiCircuitsProviderNetworksBulkUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksBulkUpdateExecute(r)
}

/*
CircuitsProviderNetworksBulkUpdate Method for CircuitsProviderNetworksBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksBulkUpdate(ctx context.Context) ApiCircuitsProviderNetworksBulkUpdateRequest {
	return ApiCircuitsProviderNetworksBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksBulkUpdateExecute(r ApiCircuitsProviderNetworksBulkUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableProviderNetwork == nil {
		return localVarReturnValue, nil, reportError("writableProviderNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableProviderNetwork
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	writableProviderNetwork *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksCreateRequest) WritableProviderNetwork(writableProviderNetwork WritableProviderNetwork) ApiCircuitsProviderNetworksCreateRequest {
	r.writableProviderNetwork = &writableProviderNetwork
	return r
}

func (r ApiCircuitsProviderNetworksCreateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksCreateExecute(r)
}

/*
CircuitsProviderNetworksCreate Method for CircuitsProviderNetworksCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksCreateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksCreate(ctx context.Context) ApiCircuitsProviderNetworksCreateRequest {
	return ApiCircuitsProviderNetworksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksCreateExecute(r ApiCircuitsProviderNetworksCreateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableProviderNetwork == nil {
		return localVarReturnValue, nil, reportError("writableProviderNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableProviderNetwork
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsProviderNetworksDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksDestroyExecute(r)
}

/*
CircuitsProviderNetworksDestroy Method for CircuitsProviderNetworksDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider network.
 @return ApiCircuitsProviderNetworksDestroyRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksDestroy(ctx context.Context, id string) ApiCircuitsProviderNetworksDestroyRequest {
	return ApiCircuitsProviderNetworksDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProviderNetworksDestroyExecute(r ApiCircuitsProviderNetworksDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	created *string
	createdGte *string
	createdLte *string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	provider *[]string
	providerN *[]string
	providerId *[]string
	providerIdN *[]string
	q *string
	slug *[]string
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIre *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNire *[]string
	slugNisw *[]string
	slugNre *[]string
	slugRe *[]string
	tag *[]string
	tagN *[]string
}

func (r ApiCircuitsProviderNetworksListRequest) Created(created string) ApiCircuitsProviderNetworksListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) CreatedGte(createdGte string) ApiCircuitsProviderNetworksListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) CreatedLte(createdLte string) ApiCircuitsProviderNetworksListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Id(id []string) ApiCircuitsProviderNetworksListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdIc(idIc []string) ApiCircuitsProviderNetworksListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdIe(idIe []string) ApiCircuitsProviderNetworksListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdIew(idIew []string) ApiCircuitsProviderNetworksListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdIre(idIre []string) ApiCircuitsProviderNetworksListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdIsw(idIsw []string) ApiCircuitsProviderNetworksListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdN(idN []string) ApiCircuitsProviderNetworksListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdNic(idNic []string) ApiCircuitsProviderNetworksListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdNie(idNie []string) ApiCircuitsProviderNetworksListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdNiew(idNiew []string) ApiCircuitsProviderNetworksListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdNire(idNire []string) ApiCircuitsProviderNetworksListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdNisw(idNisw []string) ApiCircuitsProviderNetworksListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdNre(idNre []string) ApiCircuitsProviderNetworksListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) IdRe(idRe []string) ApiCircuitsProviderNetworksListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) LastUpdated(lastUpdated time.Time) ApiCircuitsProviderNetworksListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiCircuitsProviderNetworksListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiCircuitsProviderNetworksListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiCircuitsProviderNetworksListRequest) Limit(limit int32) ApiCircuitsProviderNetworksListRequest {
	r.limit = &limit
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Name(name []string) ApiCircuitsProviderNetworksListRequest {
	r.name = &name
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIc(nameIc []string) ApiCircuitsProviderNetworksListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIe(nameIe []string) ApiCircuitsProviderNetworksListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIew(nameIew []string) ApiCircuitsProviderNetworksListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIre(nameIre []string) ApiCircuitsProviderNetworksListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameIsw(nameIsw []string) ApiCircuitsProviderNetworksListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameN(nameN []string) ApiCircuitsProviderNetworksListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNic(nameNic []string) ApiCircuitsProviderNetworksListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNie(nameNie []string) ApiCircuitsProviderNetworksListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNiew(nameNiew []string) ApiCircuitsProviderNetworksListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNire(nameNire []string) ApiCircuitsProviderNetworksListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNisw(nameNisw []string) ApiCircuitsProviderNetworksListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameNre(nameNre []string) ApiCircuitsProviderNetworksListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) NameRe(nameRe []string) ApiCircuitsProviderNetworksListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsProviderNetworksListRequest) Offset(offset int32) ApiCircuitsProviderNetworksListRequest {
	r.offset = &offset
	return r
}

// Provider (slug)
func (r ApiCircuitsProviderNetworksListRequest) Provider(provider []string) ApiCircuitsProviderNetworksListRequest {
	r.provider = &provider
	return r
}

// Provider (slug)
func (r ApiCircuitsProviderNetworksListRequest) ProviderN(providerN []string) ApiCircuitsProviderNetworksListRequest {
	r.providerN = &providerN
	return r
}

// Provider (ID)
func (r ApiCircuitsProviderNetworksListRequest) ProviderId(providerId []string) ApiCircuitsProviderNetworksListRequest {
	r.providerId = &providerId
	return r
}

// Provider (ID)
func (r ApiCircuitsProviderNetworksListRequest) ProviderIdN(providerIdN []string) ApiCircuitsProviderNetworksListRequest {
	r.providerIdN = &providerIdN
	return r
}

// Search
func (r ApiCircuitsProviderNetworksListRequest) Q(q string) ApiCircuitsProviderNetworksListRequest {
	r.q = &q
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Slug(slug []string) ApiCircuitsProviderNetworksListRequest {
	r.slug = &slug
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugIc(slugIc []string) ApiCircuitsProviderNetworksListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugIe(slugIe []string) ApiCircuitsProviderNetworksListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugIew(slugIew []string) ApiCircuitsProviderNetworksListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugIre(slugIre []string) ApiCircuitsProviderNetworksListRequest {
	r.slugIre = &slugIre
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugIsw(slugIsw []string) ApiCircuitsProviderNetworksListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugN(slugN []string) ApiCircuitsProviderNetworksListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugNic(slugNic []string) ApiCircuitsProviderNetworksListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugNie(slugNie []string) ApiCircuitsProviderNetworksListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugNiew(slugNiew []string) ApiCircuitsProviderNetworksListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugNire(slugNire []string) ApiCircuitsProviderNetworksListRequest {
	r.slugNire = &slugNire
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugNisw(slugNisw []string) ApiCircuitsProviderNetworksListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugNre(slugNre []string) ApiCircuitsProviderNetworksListRequest {
	r.slugNre = &slugNre
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) SlugRe(slugRe []string) ApiCircuitsProviderNetworksListRequest {
	r.slugRe = &slugRe
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Tag(tag []string) ApiCircuitsProviderNetworksListRequest {
	r.tag = &tag
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) TagN(tagN []string) ApiCircuitsProviderNetworksListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiCircuitsProviderNetworksListRequest) Execute() (*PaginatedProviderNetworkList, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksListExecute(r)
}

/*
CircuitsProviderNetworksList Method for CircuitsProviderNetworksList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProviderNetworksListRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksList(ctx context.Context) ApiCircuitsProviderNetworksListRequest {
	return ApiCircuitsProviderNetworksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedProviderNetworkList
func (a *CircuitsApiService) CircuitsProviderNetworksListExecute(r ApiCircuitsProviderNetworksListRequest) (*PaginatedProviderNetworkList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedProviderNetworkList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.provider != nil {
		t := *r.provider
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider", parameterToString(t, "multi"))
		}
	}
	if r.providerN != nil {
		t := *r.providerN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider__n", parameterToString(t, "multi"))
		}
	}
	if r.providerId != nil {
		t := *r.providerId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_id", parameterToString(t, "multi"))
		}
	}
	if r.providerIdN != nil {
		t := *r.providerIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("provider_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("provider_id__n", parameterToString(t, "multi"))
		}
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug", parameterToString(t, "multi"))
		}
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ic", parameterToString(t, "multi"))
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ie", parameterToString(t, "multi"))
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__iew", parameterToString(t, "multi"))
		}
	}
	if r.slugIre != nil {
		t := *r.slugIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ire", parameterToString(t, "multi"))
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__isw", parameterToString(t, "multi"))
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__n", parameterToString(t, "multi"))
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nic", parameterToString(t, "multi"))
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nie", parameterToString(t, "multi"))
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__niew", parameterToString(t, "multi"))
		}
	}
	if r.slugNire != nil {
		t := *r.slugNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nire", parameterToString(t, "multi"))
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nisw", parameterToString(t, "multi"))
		}
	}
	if r.slugNre != nil {
		t := *r.slugNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nre", parameterToString(t, "multi"))
		}
	}
	if r.slugRe != nil {
		t := *r.slugRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__re", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	patchedWritableProviderNetwork *PatchedWritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksPartialUpdateRequest) PatchedWritableProviderNetwork(patchedWritableProviderNetwork PatchedWritableProviderNetwork) ApiCircuitsProviderNetworksPartialUpdateRequest {
	r.patchedWritableProviderNetwork = &patchedWritableProviderNetwork
	return r
}

func (r ApiCircuitsProviderNetworksPartialUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksPartialUpdateExecute(r)
}

/*
CircuitsProviderNetworksPartialUpdate Method for CircuitsProviderNetworksPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider network.
 @return ApiCircuitsProviderNetworksPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksPartialUpdate(ctx context.Context, id string) ApiCircuitsProviderNetworksPartialUpdateRequest {
	return ApiCircuitsProviderNetworksPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksPartialUpdateExecute(r ApiCircuitsProviderNetworksPartialUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableProviderNetwork
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksRetrieveRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsProviderNetworksRetrieveRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksRetrieveExecute(r)
}

/*
CircuitsProviderNetworksRetrieve Method for CircuitsProviderNetworksRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider network.
 @return ApiCircuitsProviderNetworksRetrieveRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksRetrieve(ctx context.Context, id string) ApiCircuitsProviderNetworksRetrieveRequest {
	return ApiCircuitsProviderNetworksRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksRetrieveExecute(r ApiCircuitsProviderNetworksRetrieveRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProviderNetworksUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	writableProviderNetwork *WritableProviderNetwork
}

func (r ApiCircuitsProviderNetworksUpdateRequest) WritableProviderNetwork(writableProviderNetwork WritableProviderNetwork) ApiCircuitsProviderNetworksUpdateRequest {
	r.writableProviderNetwork = &writableProviderNetwork
	return r
}

func (r ApiCircuitsProviderNetworksUpdateRequest) Execute() (*ProviderNetwork, *http.Response, error) {
	return r.ApiService.CircuitsProviderNetworksUpdateExecute(r)
}

/*
CircuitsProviderNetworksUpdate Method for CircuitsProviderNetworksUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider network.
 @return ApiCircuitsProviderNetworksUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProviderNetworksUpdate(ctx context.Context, id string) ApiCircuitsProviderNetworksUpdateRequest {
	return ApiCircuitsProviderNetworksUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProviderNetwork
func (a *CircuitsApiService) CircuitsProviderNetworksUpdateExecute(r ApiCircuitsProviderNetworksUpdateRequest) (*ProviderNetwork, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProviderNetwork
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProviderNetworksUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/provider-networks/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableProviderNetwork == nil {
		return localVarReturnValue, nil, reportError("writableProviderNetwork is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableProviderNetwork
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersBulkDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
}

func (r ApiCircuitsProvidersBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProvidersBulkDestroyExecute(r)
}

/*
CircuitsProvidersBulkDestroy Method for CircuitsProvidersBulkDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersBulkDestroyRequest
*/
func (a *CircuitsApiService) CircuitsProvidersBulkDestroy(ctx context.Context) ApiCircuitsProvidersBulkDestroyRequest {
	return ApiCircuitsProvidersBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProvidersBulkDestroyExecute(r ApiCircuitsProvidersBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProvidersBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	patchedProvider *PatchedProvider
}

func (r ApiCircuitsProvidersBulkPartialUpdateRequest) PatchedProvider(patchedProvider PatchedProvider) ApiCircuitsProvidersBulkPartialUpdateRequest {
	r.patchedProvider = &patchedProvider
	return r
}

func (r ApiCircuitsProvidersBulkPartialUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersBulkPartialUpdateExecute(r)
}

/*
CircuitsProvidersBulkPartialUpdate Method for CircuitsProvidersBulkPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersBulkPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersBulkPartialUpdate(ctx context.Context) ApiCircuitsProvidersBulkPartialUpdateRequest {
	return ApiCircuitsProvidersBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersBulkPartialUpdateExecute(r ApiCircuitsProvidersBulkPartialUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedProvider
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersBulkUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	provider *Provider
}

func (r ApiCircuitsProvidersBulkUpdateRequest) Provider(provider Provider) ApiCircuitsProvidersBulkUpdateRequest {
	r.provider = &provider
	return r
}

func (r ApiCircuitsProvidersBulkUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersBulkUpdateExecute(r)
}

/*
CircuitsProvidersBulkUpdate Method for CircuitsProvidersBulkUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersBulkUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersBulkUpdate(ctx context.Context) ApiCircuitsProvidersBulkUpdateRequest {
	return ApiCircuitsProvidersBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersBulkUpdateExecute(r ApiCircuitsProvidersBulkUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.provider == nil {
		return localVarReturnValue, nil, reportError("provider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.provider
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersCreateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	provider *Provider
}

func (r ApiCircuitsProvidersCreateRequest) Provider(provider Provider) ApiCircuitsProvidersCreateRequest {
	r.provider = &provider
	return r
}

func (r ApiCircuitsProvidersCreateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersCreateExecute(r)
}

/*
CircuitsProvidersCreate Method for CircuitsProvidersCreate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersCreateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersCreate(ctx context.Context) ApiCircuitsProvidersCreateRequest {
	return ApiCircuitsProvidersCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersCreateExecute(r ApiCircuitsProvidersCreateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.provider == nil {
		return localVarReturnValue, nil, reportError("provider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.provider
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersDestroyRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsProvidersDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.CircuitsProvidersDestroyExecute(r)
}

/*
CircuitsProvidersDestroy Method for CircuitsProvidersDestroy

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider.
 @return ApiCircuitsProvidersDestroyRequest
*/
func (a *CircuitsApiService) CircuitsProvidersDestroy(ctx context.Context, id string) ApiCircuitsProvidersDestroyRequest {
	return ApiCircuitsProvidersDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CircuitsApiService) CircuitsProvidersDestroyExecute(r ApiCircuitsProvidersDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCircuitsProvidersListRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	account *[]string
	accountIc *[]string
	accountIe *[]string
	accountIew *[]string
	accountIre *[]string
	accountIsw *[]string
	accountN *[]string
	accountNic *[]string
	accountNie *[]string
	accountNiew *[]string
	accountNire *[]string
	accountNisw *[]string
	accountNre *[]string
	accountRe *[]string
	asn *[]int32
	asnGt *[]int32
	asnGte *[]int32
	asnLt *[]int32
	asnLte *[]int32
	asnN *[]int32
	created *string
	createdGte *string
	createdLte *string
	id *[]string
	idIc *[]string
	idIe *[]string
	idIew *[]string
	idIre *[]string
	idIsw *[]string
	idN *[]string
	idNic *[]string
	idNie *[]string
	idNiew *[]string
	idNire *[]string
	idNisw *[]string
	idNre *[]string
	idRe *[]string
	lastUpdated *time.Time
	lastUpdatedGte *time.Time
	lastUpdatedLte *time.Time
	limit *int32
	name *[]string
	nameIc *[]string
	nameIe *[]string
	nameIew *[]string
	nameIre *[]string
	nameIsw *[]string
	nameN *[]string
	nameNic *[]string
	nameNie *[]string
	nameNiew *[]string
	nameNire *[]string
	nameNisw *[]string
	nameNre *[]string
	nameRe *[]string
	offset *int32
	q *string
	region *[]string
	regionN *[]string
	regionId *[]string
	regionIdN *[]string
	site *[]string
	siteN *[]string
	siteId *[]string
	siteIdN *[]string
	slug *[]string
	slugIc *[]string
	slugIe *[]string
	slugIew *[]string
	slugIre *[]string
	slugIsw *[]string
	slugN *[]string
	slugNic *[]string
	slugNie *[]string
	slugNiew *[]string
	slugNire *[]string
	slugNisw *[]string
	slugNre *[]string
	slugRe *[]string
	tag *[]string
	tagN *[]string
}

func (r ApiCircuitsProvidersListRequest) Account(account []string) ApiCircuitsProvidersListRequest {
	r.account = &account
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIc(accountIc []string) ApiCircuitsProvidersListRequest {
	r.accountIc = &accountIc
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIe(accountIe []string) ApiCircuitsProvidersListRequest {
	r.accountIe = &accountIe
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIew(accountIew []string) ApiCircuitsProvidersListRequest {
	r.accountIew = &accountIew
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIre(accountIre []string) ApiCircuitsProvidersListRequest {
	r.accountIre = &accountIre
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountIsw(accountIsw []string) ApiCircuitsProvidersListRequest {
	r.accountIsw = &accountIsw
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountN(accountN []string) ApiCircuitsProvidersListRequest {
	r.accountN = &accountN
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNic(accountNic []string) ApiCircuitsProvidersListRequest {
	r.accountNic = &accountNic
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNie(accountNie []string) ApiCircuitsProvidersListRequest {
	r.accountNie = &accountNie
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNiew(accountNiew []string) ApiCircuitsProvidersListRequest {
	r.accountNiew = &accountNiew
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNire(accountNire []string) ApiCircuitsProvidersListRequest {
	r.accountNire = &accountNire
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNisw(accountNisw []string) ApiCircuitsProvidersListRequest {
	r.accountNisw = &accountNisw
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountNre(accountNre []string) ApiCircuitsProvidersListRequest {
	r.accountNre = &accountNre
	return r
}

func (r ApiCircuitsProvidersListRequest) AccountRe(accountRe []string) ApiCircuitsProvidersListRequest {
	r.accountRe = &accountRe
	return r
}

func (r ApiCircuitsProvidersListRequest) Asn(asn []int32) ApiCircuitsProvidersListRequest {
	r.asn = &asn
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnGt(asnGt []int32) ApiCircuitsProvidersListRequest {
	r.asnGt = &asnGt
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnGte(asnGte []int32) ApiCircuitsProvidersListRequest {
	r.asnGte = &asnGte
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnLt(asnLt []int32) ApiCircuitsProvidersListRequest {
	r.asnLt = &asnLt
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnLte(asnLte []int32) ApiCircuitsProvidersListRequest {
	r.asnLte = &asnLte
	return r
}

func (r ApiCircuitsProvidersListRequest) AsnN(asnN []int32) ApiCircuitsProvidersListRequest {
	r.asnN = &asnN
	return r
}

func (r ApiCircuitsProvidersListRequest) Created(created string) ApiCircuitsProvidersListRequest {
	r.created = &created
	return r
}

func (r ApiCircuitsProvidersListRequest) CreatedGte(createdGte string) ApiCircuitsProvidersListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiCircuitsProvidersListRequest) CreatedLte(createdLte string) ApiCircuitsProvidersListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiCircuitsProvidersListRequest) Id(id []string) ApiCircuitsProvidersListRequest {
	r.id = &id
	return r
}

func (r ApiCircuitsProvidersListRequest) IdIc(idIc []string) ApiCircuitsProvidersListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiCircuitsProvidersListRequest) IdIe(idIe []string) ApiCircuitsProvidersListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiCircuitsProvidersListRequest) IdIew(idIew []string) ApiCircuitsProvidersListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiCircuitsProvidersListRequest) IdIre(idIre []string) ApiCircuitsProvidersListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiCircuitsProvidersListRequest) IdIsw(idIsw []string) ApiCircuitsProvidersListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiCircuitsProvidersListRequest) IdN(idN []string) ApiCircuitsProvidersListRequest {
	r.idN = &idN
	return r
}

func (r ApiCircuitsProvidersListRequest) IdNic(idNic []string) ApiCircuitsProvidersListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiCircuitsProvidersListRequest) IdNie(idNie []string) ApiCircuitsProvidersListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiCircuitsProvidersListRequest) IdNiew(idNiew []string) ApiCircuitsProvidersListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiCircuitsProvidersListRequest) IdNire(idNire []string) ApiCircuitsProvidersListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiCircuitsProvidersListRequest) IdNisw(idNisw []string) ApiCircuitsProvidersListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiCircuitsProvidersListRequest) IdNre(idNre []string) ApiCircuitsProvidersListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiCircuitsProvidersListRequest) IdRe(idRe []string) ApiCircuitsProvidersListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiCircuitsProvidersListRequest) LastUpdated(lastUpdated time.Time) ApiCircuitsProvidersListRequest {
	r.lastUpdated = &lastUpdated
	return r
}

func (r ApiCircuitsProvidersListRequest) LastUpdatedGte(lastUpdatedGte time.Time) ApiCircuitsProvidersListRequest {
	r.lastUpdatedGte = &lastUpdatedGte
	return r
}

func (r ApiCircuitsProvidersListRequest) LastUpdatedLte(lastUpdatedLte time.Time) ApiCircuitsProvidersListRequest {
	r.lastUpdatedLte = &lastUpdatedLte
	return r
}

// Number of results to return per page.
func (r ApiCircuitsProvidersListRequest) Limit(limit int32) ApiCircuitsProvidersListRequest {
	r.limit = &limit
	return r
}

func (r ApiCircuitsProvidersListRequest) Name(name []string) ApiCircuitsProvidersListRequest {
	r.name = &name
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIc(nameIc []string) ApiCircuitsProvidersListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIe(nameIe []string) ApiCircuitsProvidersListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIew(nameIew []string) ApiCircuitsProvidersListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIre(nameIre []string) ApiCircuitsProvidersListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiCircuitsProvidersListRequest) NameIsw(nameIsw []string) ApiCircuitsProvidersListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiCircuitsProvidersListRequest) NameN(nameN []string) ApiCircuitsProvidersListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNic(nameNic []string) ApiCircuitsProvidersListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNie(nameNie []string) ApiCircuitsProvidersListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNiew(nameNiew []string) ApiCircuitsProvidersListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNire(nameNire []string) ApiCircuitsProvidersListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNisw(nameNisw []string) ApiCircuitsProvidersListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiCircuitsProvidersListRequest) NameNre(nameNre []string) ApiCircuitsProvidersListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiCircuitsProvidersListRequest) NameRe(nameRe []string) ApiCircuitsProvidersListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiCircuitsProvidersListRequest) Offset(offset int32) ApiCircuitsProvidersListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiCircuitsProvidersListRequest) Q(q string) ApiCircuitsProvidersListRequest {
	r.q = &q
	return r
}

// Region (slug)
func (r ApiCircuitsProvidersListRequest) Region(region []string) ApiCircuitsProvidersListRequest {
	r.region = &region
	return r
}

// Region (slug)
func (r ApiCircuitsProvidersListRequest) RegionN(regionN []string) ApiCircuitsProvidersListRequest {
	r.regionN = &regionN
	return r
}

// Region (ID)
func (r ApiCircuitsProvidersListRequest) RegionId(regionId []string) ApiCircuitsProvidersListRequest {
	r.regionId = &regionId
	return r
}

// Region (ID)
func (r ApiCircuitsProvidersListRequest) RegionIdN(regionIdN []string) ApiCircuitsProvidersListRequest {
	r.regionIdN = &regionIdN
	return r
}

// Site (slug)
func (r ApiCircuitsProvidersListRequest) Site(site []string) ApiCircuitsProvidersListRequest {
	r.site = &site
	return r
}

// Site (slug)
func (r ApiCircuitsProvidersListRequest) SiteN(siteN []string) ApiCircuitsProvidersListRequest {
	r.siteN = &siteN
	return r
}

// Site
func (r ApiCircuitsProvidersListRequest) SiteId(siteId []string) ApiCircuitsProvidersListRequest {
	r.siteId = &siteId
	return r
}

// Site
func (r ApiCircuitsProvidersListRequest) SiteIdN(siteIdN []string) ApiCircuitsProvidersListRequest {
	r.siteIdN = &siteIdN
	return r
}

func (r ApiCircuitsProvidersListRequest) Slug(slug []string) ApiCircuitsProvidersListRequest {
	r.slug = &slug
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIc(slugIc []string) ApiCircuitsProvidersListRequest {
	r.slugIc = &slugIc
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIe(slugIe []string) ApiCircuitsProvidersListRequest {
	r.slugIe = &slugIe
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIew(slugIew []string) ApiCircuitsProvidersListRequest {
	r.slugIew = &slugIew
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIre(slugIre []string) ApiCircuitsProvidersListRequest {
	r.slugIre = &slugIre
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugIsw(slugIsw []string) ApiCircuitsProvidersListRequest {
	r.slugIsw = &slugIsw
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugN(slugN []string) ApiCircuitsProvidersListRequest {
	r.slugN = &slugN
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNic(slugNic []string) ApiCircuitsProvidersListRequest {
	r.slugNic = &slugNic
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNie(slugNie []string) ApiCircuitsProvidersListRequest {
	r.slugNie = &slugNie
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNiew(slugNiew []string) ApiCircuitsProvidersListRequest {
	r.slugNiew = &slugNiew
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNire(slugNire []string) ApiCircuitsProvidersListRequest {
	r.slugNire = &slugNire
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNisw(slugNisw []string) ApiCircuitsProvidersListRequest {
	r.slugNisw = &slugNisw
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugNre(slugNre []string) ApiCircuitsProvidersListRequest {
	r.slugNre = &slugNre
	return r
}

func (r ApiCircuitsProvidersListRequest) SlugRe(slugRe []string) ApiCircuitsProvidersListRequest {
	r.slugRe = &slugRe
	return r
}

func (r ApiCircuitsProvidersListRequest) Tag(tag []string) ApiCircuitsProvidersListRequest {
	r.tag = &tag
	return r
}

func (r ApiCircuitsProvidersListRequest) TagN(tagN []string) ApiCircuitsProvidersListRequest {
	r.tagN = &tagN
	return r
}

func (r ApiCircuitsProvidersListRequest) Execute() (*PaginatedProviderList, *http.Response, error) {
	return r.ApiService.CircuitsProvidersListExecute(r)
}

/*
CircuitsProvidersList Method for CircuitsProvidersList

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitsProvidersListRequest
*/
func (a *CircuitsApiService) CircuitsProvidersList(ctx context.Context) ApiCircuitsProvidersListRequest {
	return ApiCircuitsProvidersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedProviderList
func (a *CircuitsApiService) CircuitsProvidersListExecute(r ApiCircuitsProvidersListRequest) (*PaginatedProviderList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedProviderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		t := *r.account
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account", parameterToString(t, "multi"))
		}
	}
	if r.accountIc != nil {
		t := *r.accountIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__ic", parameterToString(t, "multi"))
		}
	}
	if r.accountIe != nil {
		t := *r.accountIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__ie", parameterToString(t, "multi"))
		}
	}
	if r.accountIew != nil {
		t := *r.accountIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__iew", parameterToString(t, "multi"))
		}
	}
	if r.accountIre != nil {
		t := *r.accountIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__ire", parameterToString(t, "multi"))
		}
	}
	if r.accountIsw != nil {
		t := *r.accountIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__isw", parameterToString(t, "multi"))
		}
	}
	if r.accountN != nil {
		t := *r.accountN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__n", parameterToString(t, "multi"))
		}
	}
	if r.accountNic != nil {
		t := *r.accountNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__nic", parameterToString(t, "multi"))
		}
	}
	if r.accountNie != nil {
		t := *r.accountNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__nie", parameterToString(t, "multi"))
		}
	}
	if r.accountNiew != nil {
		t := *r.accountNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__niew", parameterToString(t, "multi"))
		}
	}
	if r.accountNire != nil {
		t := *r.accountNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__nire", parameterToString(t, "multi"))
		}
	}
	if r.accountNisw != nil {
		t := *r.accountNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__nisw", parameterToString(t, "multi"))
		}
	}
	if r.accountNre != nil {
		t := *r.accountNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__nre", parameterToString(t, "multi"))
		}
	}
	if r.accountRe != nil {
		t := *r.accountRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("account__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("account__re", parameterToString(t, "multi"))
		}
	}
	if r.asn != nil {
		t := *r.asn
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("asn", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("asn", parameterToString(t, "multi"))
		}
	}
	if r.asnGt != nil {
		t := *r.asnGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("asn__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("asn__gt", parameterToString(t, "multi"))
		}
	}
	if r.asnGte != nil {
		t := *r.asnGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("asn__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("asn__gte", parameterToString(t, "multi"))
		}
	}
	if r.asnLt != nil {
		t := *r.asnLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("asn__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("asn__lt", parameterToString(t, "multi"))
		}
	}
	if r.asnLte != nil {
		t := *r.asnLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("asn__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("asn__lte", parameterToString(t, "multi"))
		}
	}
	if r.asnN != nil {
		t := *r.asnN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("asn__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("asn__n", parameterToString(t, "multi"))
		}
	}
	if r.created != nil {
		localVarQueryParams.Add("created", parameterToString(*r.created, ""))
	}
	if r.createdGte != nil {
		localVarQueryParams.Add("created__gte", parameterToString(*r.createdGte, ""))
	}
	if r.createdLte != nil {
		localVarQueryParams.Add("created__lte", parameterToString(*r.createdLte, ""))
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.lastUpdated != nil {
		localVarQueryParams.Add("last_updated", parameterToString(*r.lastUpdated, ""))
	}
	if r.lastUpdatedGte != nil {
		localVarQueryParams.Add("last_updated__gte", parameterToString(*r.lastUpdatedGte, ""))
	}
	if r.lastUpdatedLte != nil {
		localVarQueryParams.Add("last_updated__lte", parameterToString(*r.lastUpdatedLte, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.region != nil {
		t := *r.region
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region", parameterToString(t, "multi"))
		}
	}
	if r.regionN != nil {
		t := *r.regionN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region__n", parameterToString(t, "multi"))
		}
	}
	if r.regionId != nil {
		t := *r.regionId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id", parameterToString(t, "multi"))
		}
	}
	if r.regionIdN != nil {
		t := *r.regionIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("region_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("region_id__n", parameterToString(t, "multi"))
		}
	}
	if r.site != nil {
		t := *r.site
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site", parameterToString(t, "multi"))
		}
	}
	if r.siteN != nil {
		t := *r.siteN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site__n", parameterToString(t, "multi"))
		}
	}
	if r.siteId != nil {
		t := *r.siteId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id", parameterToString(t, "multi"))
		}
	}
	if r.siteIdN != nil {
		t := *r.siteIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("site_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("site_id__n", parameterToString(t, "multi"))
		}
	}
	if r.slug != nil {
		t := *r.slug
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug", parameterToString(t, "multi"))
		}
	}
	if r.slugIc != nil {
		t := *r.slugIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ic", parameterToString(t, "multi"))
		}
	}
	if r.slugIe != nil {
		t := *r.slugIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ie", parameterToString(t, "multi"))
		}
	}
	if r.slugIew != nil {
		t := *r.slugIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__iew", parameterToString(t, "multi"))
		}
	}
	if r.slugIre != nil {
		t := *r.slugIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__ire", parameterToString(t, "multi"))
		}
	}
	if r.slugIsw != nil {
		t := *r.slugIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__isw", parameterToString(t, "multi"))
		}
	}
	if r.slugN != nil {
		t := *r.slugN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__n", parameterToString(t, "multi"))
		}
	}
	if r.slugNic != nil {
		t := *r.slugNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nic", parameterToString(t, "multi"))
		}
	}
	if r.slugNie != nil {
		t := *r.slugNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nie", parameterToString(t, "multi"))
		}
	}
	if r.slugNiew != nil {
		t := *r.slugNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__niew", parameterToString(t, "multi"))
		}
	}
	if r.slugNire != nil {
		t := *r.slugNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nire", parameterToString(t, "multi"))
		}
	}
	if r.slugNisw != nil {
		t := *r.slugNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nisw", parameterToString(t, "multi"))
		}
	}
	if r.slugNre != nil {
		t := *r.slugNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__nre", parameterToString(t, "multi"))
		}
	}
	if r.slugRe != nil {
		t := *r.slugRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("slug__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("slug__re", parameterToString(t, "multi"))
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag", parameterToString(t, "multi"))
		}
	}
	if r.tagN != nil {
		t := *r.tagN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tag__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tag__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersPartialUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	patchedProvider *PatchedProvider
}

func (r ApiCircuitsProvidersPartialUpdateRequest) PatchedProvider(patchedProvider PatchedProvider) ApiCircuitsProvidersPartialUpdateRequest {
	r.patchedProvider = &patchedProvider
	return r
}

func (r ApiCircuitsProvidersPartialUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersPartialUpdateExecute(r)
}

/*
CircuitsProvidersPartialUpdate Method for CircuitsProvidersPartialUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider.
 @return ApiCircuitsProvidersPartialUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersPartialUpdate(ctx context.Context, id string) ApiCircuitsProvidersPartialUpdateRequest {
	return ApiCircuitsProvidersPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersPartialUpdateExecute(r ApiCircuitsProvidersPartialUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedProvider
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersRetrieveRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
}

func (r ApiCircuitsProvidersRetrieveRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersRetrieveExecute(r)
}

/*
CircuitsProvidersRetrieve Method for CircuitsProvidersRetrieve

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider.
 @return ApiCircuitsProvidersRetrieveRequest
*/
func (a *CircuitsApiService) CircuitsProvidersRetrieve(ctx context.Context, id string) ApiCircuitsProvidersRetrieveRequest {
	return ApiCircuitsProvidersRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersRetrieveExecute(r ApiCircuitsProvidersRetrieveRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitsProvidersUpdateRequest struct {
	ctx context.Context
	ApiService *CircuitsApiService
	id string
	provider *Provider
}

func (r ApiCircuitsProvidersUpdateRequest) Provider(provider Provider) ApiCircuitsProvidersUpdateRequest {
	r.provider = &provider
	return r
}

func (r ApiCircuitsProvidersUpdateRequest) Execute() (*Provider, *http.Response, error) {
	return r.ApiService.CircuitsProvidersUpdateExecute(r)
}

/*
CircuitsProvidersUpdate Method for CircuitsProvidersUpdate

Include the applicable set of CustomFields in the ModelViewSet context.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this provider.
 @return ApiCircuitsProvidersUpdateRequest
*/
func (a *CircuitsApiService) CircuitsProvidersUpdate(ctx context.Context, id string) ApiCircuitsProvidersUpdateRequest {
	return ApiCircuitsProvidersUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Provider
func (a *CircuitsApiService) CircuitsProvidersUpdateExecute(r ApiCircuitsProvidersUpdateRequest) (*Provider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Provider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CircuitsApiService.CircuitsProvidersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/circuits/providers/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.provider == nil {
		return localVarReturnValue, nil, reportError("provider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.provider
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
