/*
API Documentation

Source of truth and network automation platform

API version: 1.3.7 (1.2)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// UsersApiService UsersApi service
type UsersApiService service

type ApiUsersConfigRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
}

func (r ApiUsersConfigRetrieveRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UsersConfigRetrieveExecute(r)
}

/*
UsersConfigRetrieve Method for UsersConfigRetrieve

Return the config_data for the currently authenticated User.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersConfigRetrieveRequest
*/
func (a *UsersApiService) UsersConfigRetrieve(ctx context.Context) ApiUsersConfigRetrieveRequest {
	return ApiUsersConfigRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UsersApiService) UsersConfigRetrieveExecute(r ApiUsersConfigRetrieveRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersConfigRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/config/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
}

func (r ApiUsersGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsBulkDestroyExecute(r)
}

/*
UsersGroupsBulkDestroy Method for UsersGroupsBulkDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsBulkDestroyRequest
*/
func (a *UsersApiService) UsersGroupsBulkDestroy(ctx context.Context) ApiUsersGroupsBulkDestroyRequest {
	return ApiUsersGroupsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersGroupsBulkDestroyExecute(r ApiUsersGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	patchedGroup *PatchedGroup
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) PatchedGroup(patchedGroup PatchedGroup) ApiUsersGroupsBulkPartialUpdateRequest {
	r.patchedGroup = &patchedGroup
	return r
}

func (r ApiUsersGroupsBulkPartialUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkPartialUpdateExecute(r)
}

/*
UsersGroupsBulkPartialUpdate Method for UsersGroupsBulkPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsBulkPartialUpdateRequest
*/
func (a *UsersApiService) UsersGroupsBulkPartialUpdate(ctx context.Context) ApiUsersGroupsBulkPartialUpdateRequest {
	return ApiUsersGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsBulkPartialUpdateExecute(r ApiUsersGroupsBulkPartialUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsBulkUpdateRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	group      *Group
}

func (r ApiUsersGroupsBulkUpdateRequest) Group(group Group) ApiUsersGroupsBulkUpdateRequest {
	r.group = &group
	return r
}

func (r ApiUsersGroupsBulkUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsBulkUpdateExecute(r)
}

/*
UsersGroupsBulkUpdate Method for UsersGroupsBulkUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsBulkUpdateRequest
*/
func (a *UsersApiService) UsersGroupsBulkUpdate(ctx context.Context) ApiUsersGroupsBulkUpdateRequest {
	return ApiUsersGroupsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsBulkUpdateExecute(r ApiUsersGroupsBulkUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.group == nil {
		return localVarReturnValue, nil, reportError("group is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.group
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsCreateRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	group      *Group
}

func (r ApiUsersGroupsCreateRequest) Group(group Group) ApiUsersGroupsCreateRequest {
	r.group = &group
	return r
}

func (r ApiUsersGroupsCreateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsCreateExecute(r)
}

/*
UsersGroupsCreate Method for UsersGroupsCreate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsCreateRequest
*/
func (a *UsersApiService) UsersGroupsCreate(ctx context.Context) ApiUsersGroupsCreateRequest {
	return ApiUsersGroupsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsCreateExecute(r ApiUsersGroupsCreateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.group == nil {
		return localVarReturnValue, nil, reportError("group is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.group
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         int32
}

func (r ApiUsersGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersGroupsDestroyExecute(r)
}

/*
UsersGroupsDestroy Method for UsersGroupsDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsDestroyRequest
*/
func (a *UsersApiService) UsersGroupsDestroy(ctx context.Context, id int32) ApiUsersGroupsDestroyRequest {
	return ApiUsersGroupsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersGroupsDestroyExecute(r ApiUsersGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersGroupsListRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         *[]int32
	idGt       *[]int32
	idGte      *[]int32
	idLt       *[]int32
	idLte      *[]int32
	idN        *[]int32
	limit      *int32
	name       *[]string
	nameIc     *[]string
	nameIe     *[]string
	nameIew    *[]string
	nameIre    *[]string
	nameIsw    *[]string
	nameN      *[]string
	nameNic    *[]string
	nameNie    *[]string
	nameNiew   *[]string
	nameNire   *[]string
	nameNisw   *[]string
	nameNre    *[]string
	nameRe     *[]string
	offset     *int32
	q          *string
}

func (r ApiUsersGroupsListRequest) Id(id []int32) ApiUsersGroupsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersGroupsListRequest) IdGt(idGt []int32) ApiUsersGroupsListRequest {
	r.idGt = &idGt
	return r
}

func (r ApiUsersGroupsListRequest) IdGte(idGte []int32) ApiUsersGroupsListRequest {
	r.idGte = &idGte
	return r
}

func (r ApiUsersGroupsListRequest) IdLt(idLt []int32) ApiUsersGroupsListRequest {
	r.idLt = &idLt
	return r
}

func (r ApiUsersGroupsListRequest) IdLte(idLte []int32) ApiUsersGroupsListRequest {
	r.idLte = &idLte
	return r
}

func (r ApiUsersGroupsListRequest) IdN(idN []int32) ApiUsersGroupsListRequest {
	r.idN = &idN
	return r
}

// Number of results to return per page.
func (r ApiUsersGroupsListRequest) Limit(limit int32) ApiUsersGroupsListRequest {
	r.limit = &limit
	return r
}

func (r ApiUsersGroupsListRequest) Name(name []string) ApiUsersGroupsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersGroupsListRequest) NameIc(nameIc []string) ApiUsersGroupsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersGroupsListRequest) NameIe(nameIe []string) ApiUsersGroupsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersGroupsListRequest) NameIew(nameIew []string) ApiUsersGroupsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersGroupsListRequest) NameIre(nameIre []string) ApiUsersGroupsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiUsersGroupsListRequest) NameIsw(nameIsw []string) ApiUsersGroupsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersGroupsListRequest) NameN(nameN []string) ApiUsersGroupsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersGroupsListRequest) NameNic(nameNic []string) ApiUsersGroupsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersGroupsListRequest) NameNie(nameNie []string) ApiUsersGroupsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersGroupsListRequest) NameNiew(nameNiew []string) ApiUsersGroupsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersGroupsListRequest) NameNire(nameNire []string) ApiUsersGroupsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiUsersGroupsListRequest) NameNisw(nameNisw []string) ApiUsersGroupsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiUsersGroupsListRequest) NameNre(nameNre []string) ApiUsersGroupsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiUsersGroupsListRequest) NameRe(nameRe []string) ApiUsersGroupsListRequest {
	r.nameRe = &nameRe
	return r
}

// The initial index from which to return the results.
func (r ApiUsersGroupsListRequest) Offset(offset int32) ApiUsersGroupsListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiUsersGroupsListRequest) Q(q string) ApiUsersGroupsListRequest {
	r.q = &q
	return r
}

func (r ApiUsersGroupsListRequest) Execute() (*PaginatedGroupList, *http.Response, error) {
	return r.ApiService.UsersGroupsListExecute(r)
}

/*
UsersGroupsList Method for UsersGroupsList

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersGroupsListRequest
*/
func (a *UsersApiService) UsersGroupsList(ctx context.Context) ApiUsersGroupsListRequest {
	return ApiUsersGroupsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedGroupList
func (a *UsersApiService) UsersGroupsListExecute(r ApiUsersGroupsListRequest) (*PaginatedGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idGt != nil {
		t := *r.idGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__gt", parameterToString(t, "multi"))
		}
	}
	if r.idGte != nil {
		t := *r.idGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__gte", parameterToString(t, "multi"))
		}
	}
	if r.idLt != nil {
		t := *r.idLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__lt", parameterToString(t, "multi"))
		}
	}
	if r.idLte != nil {
		t := *r.idLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__lte", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	id           int32
	patchedGroup *PatchedGroup
}

func (r ApiUsersGroupsPartialUpdateRequest) PatchedGroup(patchedGroup PatchedGroup) ApiUsersGroupsPartialUpdateRequest {
	r.patchedGroup = &patchedGroup
	return r
}

func (r ApiUsersGroupsPartialUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsPartialUpdateExecute(r)
}

/*
UsersGroupsPartialUpdate Method for UsersGroupsPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsPartialUpdateRequest
*/
func (a *UsersApiService) UsersGroupsPartialUpdate(ctx context.Context, id int32) ApiUsersGroupsPartialUpdateRequest {
	return ApiUsersGroupsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsPartialUpdateExecute(r ApiUsersGroupsPartialUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         int32
}

func (r ApiUsersGroupsRetrieveRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsRetrieveExecute(r)
}

/*
UsersGroupsRetrieve Method for UsersGroupsRetrieve

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsRetrieveRequest
*/
func (a *UsersApiService) UsersGroupsRetrieve(ctx context.Context, id int32) ApiUsersGroupsRetrieveRequest {
	return ApiUsersGroupsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsRetrieveExecute(r ApiUsersGroupsRetrieveRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersGroupsUpdateRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         int32
	group      *Group
}

func (r ApiUsersGroupsUpdateRequest) Group(group Group) ApiUsersGroupsUpdateRequest {
	r.group = &group
	return r
}

func (r ApiUsersGroupsUpdateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.UsersGroupsUpdateExecute(r)
}

/*
UsersGroupsUpdate Method for UsersGroupsUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this group.
 @return ApiUsersGroupsUpdateRequest
*/
func (a *UsersApiService) UsersGroupsUpdate(ctx context.Context, id int32) ApiUsersGroupsUpdateRequest {
	return ApiUsersGroupsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Group
func (a *UsersApiService) UsersGroupsUpdateExecute(r ApiUsersGroupsUpdateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.group == nil {
		return localVarReturnValue, nil, reportError("group is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.group
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
}

func (r ApiUsersPermissionsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsBulkDestroyExecute(r)
}

/*
UsersPermissionsBulkDestroy Method for UsersPermissionsBulkDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsBulkDestroyRequest
*/
func (a *UsersApiService) UsersPermissionsBulkDestroy(ctx context.Context) ApiUsersPermissionsBulkDestroyRequest {
	return ApiUsersPermissionsBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersPermissionsBulkDestroyExecute(r ApiUsersPermissionsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkPartialUpdateRequest struct {
	ctx                             context.Context
	ApiService                      *UsersApiService
	patchedWritableObjectPermission *PatchedWritableObjectPermission
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) PatchedWritableObjectPermission(patchedWritableObjectPermission PatchedWritableObjectPermission) ApiUsersPermissionsBulkPartialUpdateRequest {
	r.patchedWritableObjectPermission = &patchedWritableObjectPermission
	return r
}

func (r ApiUsersPermissionsBulkPartialUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkPartialUpdateExecute(r)
}

/*
UsersPermissionsBulkPartialUpdate Method for UsersPermissionsBulkPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsBulkPartialUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsBulkPartialUpdate(ctx context.Context) ApiUsersPermissionsBulkPartialUpdateRequest {
	return ApiUsersPermissionsBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsBulkPartialUpdateExecute(r ApiUsersPermissionsBulkPartialUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableObjectPermission
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsBulkUpdateRequest struct {
	ctx                      context.Context
	ApiService               *UsersApiService
	writableObjectPermission *WritableObjectPermission
}

func (r ApiUsersPermissionsBulkUpdateRequest) WritableObjectPermission(writableObjectPermission WritableObjectPermission) ApiUsersPermissionsBulkUpdateRequest {
	r.writableObjectPermission = &writableObjectPermission
	return r
}

func (r ApiUsersPermissionsBulkUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsBulkUpdateExecute(r)
}

/*
UsersPermissionsBulkUpdate Method for UsersPermissionsBulkUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsBulkUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsBulkUpdate(ctx context.Context) ApiUsersPermissionsBulkUpdateRequest {
	return ApiUsersPermissionsBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsBulkUpdateExecute(r ApiUsersPermissionsBulkUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableObjectPermission == nil {
		return localVarReturnValue, nil, reportError("writableObjectPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableObjectPermission
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsCreateRequest struct {
	ctx                      context.Context
	ApiService               *UsersApiService
	writableObjectPermission *WritableObjectPermission
}

func (r ApiUsersPermissionsCreateRequest) WritableObjectPermission(writableObjectPermission WritableObjectPermission) ApiUsersPermissionsCreateRequest {
	r.writableObjectPermission = &writableObjectPermission
	return r
}

func (r ApiUsersPermissionsCreateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsCreateExecute(r)
}

/*
UsersPermissionsCreate Method for UsersPermissionsCreate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsCreateRequest
*/
func (a *UsersApiService) UsersPermissionsCreate(ctx context.Context) ApiUsersPermissionsCreateRequest {
	return ApiUsersPermissionsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsCreateExecute(r ApiUsersPermissionsCreateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableObjectPermission == nil {
		return localVarReturnValue, nil, reportError("writableObjectPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableObjectPermission
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         string
}

func (r ApiUsersPermissionsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersPermissionsDestroyExecute(r)
}

/*
UsersPermissionsDestroy Method for UsersPermissionsDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this permission.
 @return ApiUsersPermissionsDestroyRequest
*/
func (a *UsersApiService) UsersPermissionsDestroy(ctx context.Context, id string) ApiUsersPermissionsDestroyRequest {
	return ApiUsersPermissionsDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersPermissionsDestroyExecute(r ApiUsersPermissionsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersPermissionsListRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	enabled      *bool
	group        *[]string
	groupN       *[]string
	groupId      *[]int32
	groupIdN     *[]int32
	id           *[]string
	idIc         *[]string
	idIe         *[]string
	idIew        *[]string
	idIre        *[]string
	idIsw        *[]string
	idN          *[]string
	idNic        *[]string
	idNie        *[]string
	idNiew       *[]string
	idNire       *[]string
	idNisw       *[]string
	idNre        *[]string
	idRe         *[]string
	limit        *int32
	name         *[]string
	nameIc       *[]string
	nameIe       *[]string
	nameIew      *[]string
	nameIre      *[]string
	nameIsw      *[]string
	nameN        *[]string
	nameNic      *[]string
	nameNie      *[]string
	nameNiew     *[]string
	nameNire     *[]string
	nameNisw     *[]string
	nameNre      *[]string
	nameRe       *[]string
	objectTypes  *[]int32
	objectTypesN *[]int32
	offset       *int32
	user         *[]string
	userN        *[]string
	userId       *[]string
	userIdN      *[]string
}

func (r ApiUsersPermissionsListRequest) Enabled(enabled bool) ApiUsersPermissionsListRequest {
	r.enabled = &enabled
	return r
}

// Group (name)
func (r ApiUsersPermissionsListRequest) Group(group []string) ApiUsersPermissionsListRequest {
	r.group = &group
	return r
}

// Group (name)
func (r ApiUsersPermissionsListRequest) GroupN(groupN []string) ApiUsersPermissionsListRequest {
	r.groupN = &groupN
	return r
}

// Group
func (r ApiUsersPermissionsListRequest) GroupId(groupId []int32) ApiUsersPermissionsListRequest {
	r.groupId = &groupId
	return r
}

// Group
func (r ApiUsersPermissionsListRequest) GroupIdN(groupIdN []int32) ApiUsersPermissionsListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiUsersPermissionsListRequest) Id(id []string) ApiUsersPermissionsListRequest {
	r.id = &id
	return r
}

func (r ApiUsersPermissionsListRequest) IdIc(idIc []string) ApiUsersPermissionsListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiUsersPermissionsListRequest) IdIe(idIe []string) ApiUsersPermissionsListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiUsersPermissionsListRequest) IdIew(idIew []string) ApiUsersPermissionsListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiUsersPermissionsListRequest) IdIre(idIre []string) ApiUsersPermissionsListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiUsersPermissionsListRequest) IdIsw(idIsw []string) ApiUsersPermissionsListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiUsersPermissionsListRequest) IdN(idN []string) ApiUsersPermissionsListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersPermissionsListRequest) IdNic(idNic []string) ApiUsersPermissionsListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiUsersPermissionsListRequest) IdNie(idNie []string) ApiUsersPermissionsListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiUsersPermissionsListRequest) IdNiew(idNiew []string) ApiUsersPermissionsListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiUsersPermissionsListRequest) IdNire(idNire []string) ApiUsersPermissionsListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiUsersPermissionsListRequest) IdNisw(idNisw []string) ApiUsersPermissionsListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiUsersPermissionsListRequest) IdNre(idNre []string) ApiUsersPermissionsListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiUsersPermissionsListRequest) IdRe(idRe []string) ApiUsersPermissionsListRequest {
	r.idRe = &idRe
	return r
}

// Number of results to return per page.
func (r ApiUsersPermissionsListRequest) Limit(limit int32) ApiUsersPermissionsListRequest {
	r.limit = &limit
	return r
}

func (r ApiUsersPermissionsListRequest) Name(name []string) ApiUsersPermissionsListRequest {
	r.name = &name
	return r
}

func (r ApiUsersPermissionsListRequest) NameIc(nameIc []string) ApiUsersPermissionsListRequest {
	r.nameIc = &nameIc
	return r
}

func (r ApiUsersPermissionsListRequest) NameIe(nameIe []string) ApiUsersPermissionsListRequest {
	r.nameIe = &nameIe
	return r
}

func (r ApiUsersPermissionsListRequest) NameIew(nameIew []string) ApiUsersPermissionsListRequest {
	r.nameIew = &nameIew
	return r
}

func (r ApiUsersPermissionsListRequest) NameIre(nameIre []string) ApiUsersPermissionsListRequest {
	r.nameIre = &nameIre
	return r
}

func (r ApiUsersPermissionsListRequest) NameIsw(nameIsw []string) ApiUsersPermissionsListRequest {
	r.nameIsw = &nameIsw
	return r
}

func (r ApiUsersPermissionsListRequest) NameN(nameN []string) ApiUsersPermissionsListRequest {
	r.nameN = &nameN
	return r
}

func (r ApiUsersPermissionsListRequest) NameNic(nameNic []string) ApiUsersPermissionsListRequest {
	r.nameNic = &nameNic
	return r
}

func (r ApiUsersPermissionsListRequest) NameNie(nameNie []string) ApiUsersPermissionsListRequest {
	r.nameNie = &nameNie
	return r
}

func (r ApiUsersPermissionsListRequest) NameNiew(nameNiew []string) ApiUsersPermissionsListRequest {
	r.nameNiew = &nameNiew
	return r
}

func (r ApiUsersPermissionsListRequest) NameNire(nameNire []string) ApiUsersPermissionsListRequest {
	r.nameNire = &nameNire
	return r
}

func (r ApiUsersPermissionsListRequest) NameNisw(nameNisw []string) ApiUsersPermissionsListRequest {
	r.nameNisw = &nameNisw
	return r
}

func (r ApiUsersPermissionsListRequest) NameNre(nameNre []string) ApiUsersPermissionsListRequest {
	r.nameNre = &nameNre
	return r
}

func (r ApiUsersPermissionsListRequest) NameRe(nameRe []string) ApiUsersPermissionsListRequest {
	r.nameRe = &nameRe
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypes(objectTypes []int32) ApiUsersPermissionsListRequest {
	r.objectTypes = &objectTypes
	return r
}

func (r ApiUsersPermissionsListRequest) ObjectTypesN(objectTypesN []int32) ApiUsersPermissionsListRequest {
	r.objectTypesN = &objectTypesN
	return r
}

// The initial index from which to return the results.
func (r ApiUsersPermissionsListRequest) Offset(offset int32) ApiUsersPermissionsListRequest {
	r.offset = &offset
	return r
}

// User (name)
func (r ApiUsersPermissionsListRequest) User(user []string) ApiUsersPermissionsListRequest {
	r.user = &user
	return r
}

// User (name)
func (r ApiUsersPermissionsListRequest) UserN(userN []string) ApiUsersPermissionsListRequest {
	r.userN = &userN
	return r
}

// User
func (r ApiUsersPermissionsListRequest) UserId(userId []string) ApiUsersPermissionsListRequest {
	r.userId = &userId
	return r
}

// User
func (r ApiUsersPermissionsListRequest) UserIdN(userIdN []string) ApiUsersPermissionsListRequest {
	r.userIdN = &userIdN
	return r
}

func (r ApiUsersPermissionsListRequest) Execute() (*PaginatedObjectPermissionList, *http.Response, error) {
	return r.ApiService.UsersPermissionsListExecute(r)
}

/*
UsersPermissionsList Method for UsersPermissionsList

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersPermissionsListRequest
*/
func (a *UsersApiService) UsersPermissionsList(ctx context.Context) ApiUsersPermissionsListRequest {
	return ApiUsersPermissionsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedObjectPermissionList
func (a *UsersApiService) UsersPermissionsListExecute(r ApiUsersPermissionsListRequest) (*PaginatedObjectPermissionList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedObjectPermissionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enabled != nil {
		localVarQueryParams.Add("enabled", parameterToString(*r.enabled, ""))
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group__n", parameterToString(t, "multi"))
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group_id", parameterToString(t, "multi"))
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		t := *r.name
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name", parameterToString(t, "multi"))
		}
	}
	if r.nameIc != nil {
		t := *r.nameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ic", parameterToString(t, "multi"))
		}
	}
	if r.nameIe != nil {
		t := *r.nameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ie", parameterToString(t, "multi"))
		}
	}
	if r.nameIew != nil {
		t := *r.nameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__iew", parameterToString(t, "multi"))
		}
	}
	if r.nameIre != nil {
		t := *r.nameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__ire", parameterToString(t, "multi"))
		}
	}
	if r.nameIsw != nil {
		t := *r.nameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__isw", parameterToString(t, "multi"))
		}
	}
	if r.nameN != nil {
		t := *r.nameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__n", parameterToString(t, "multi"))
		}
	}
	if r.nameNic != nil {
		t := *r.nameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nic", parameterToString(t, "multi"))
		}
	}
	if r.nameNie != nil {
		t := *r.nameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nie", parameterToString(t, "multi"))
		}
	}
	if r.nameNiew != nil {
		t := *r.nameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__niew", parameterToString(t, "multi"))
		}
	}
	if r.nameNire != nil {
		t := *r.nameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nire", parameterToString(t, "multi"))
		}
	}
	if r.nameNisw != nil {
		t := *r.nameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.nameNre != nil {
		t := *r.nameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__nre", parameterToString(t, "multi"))
		}
	}
	if r.nameRe != nil {
		t := *r.nameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("name__re", parameterToString(t, "multi"))
		}
	}
	if r.objectTypes != nil {
		t := *r.objectTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("object_types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("object_types", parameterToString(t, "multi"))
		}
	}
	if r.objectTypesN != nil {
		t := *r.objectTypesN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("object_types__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("object_types__n", parameterToString(t, "multi"))
		}
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.user != nil {
		t := *r.user
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("user", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("user", parameterToString(t, "multi"))
		}
	}
	if r.userN != nil {
		t := *r.userN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("user__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("user__n", parameterToString(t, "multi"))
		}
	}
	if r.userId != nil {
		t := *r.userId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("user_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("user_id", parameterToString(t, "multi"))
		}
	}
	if r.userIdN != nil {
		t := *r.userIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("user_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("user_id__n", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsPartialUpdateRequest struct {
	ctx                             context.Context
	ApiService                      *UsersApiService
	id                              string
	patchedWritableObjectPermission *PatchedWritableObjectPermission
}

func (r ApiUsersPermissionsPartialUpdateRequest) PatchedWritableObjectPermission(patchedWritableObjectPermission PatchedWritableObjectPermission) ApiUsersPermissionsPartialUpdateRequest {
	r.patchedWritableObjectPermission = &patchedWritableObjectPermission
	return r
}

func (r ApiUsersPermissionsPartialUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsPartialUpdateExecute(r)
}

/*
UsersPermissionsPartialUpdate Method for UsersPermissionsPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this permission.
 @return ApiUsersPermissionsPartialUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsPartialUpdate(ctx context.Context, id string) ApiUsersPermissionsPartialUpdateRequest {
	return ApiUsersPermissionsPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsPartialUpdateExecute(r ApiUsersPermissionsPartialUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableObjectPermission
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         string
}

func (r ApiUsersPermissionsRetrieveRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsRetrieveExecute(r)
}

/*
UsersPermissionsRetrieve Method for UsersPermissionsRetrieve

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this permission.
 @return ApiUsersPermissionsRetrieveRequest
*/
func (a *UsersApiService) UsersPermissionsRetrieve(ctx context.Context, id string) ApiUsersPermissionsRetrieveRequest {
	return ApiUsersPermissionsRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsRetrieveExecute(r ApiUsersPermissionsRetrieveRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersPermissionsUpdateRequest struct {
	ctx                      context.Context
	ApiService               *UsersApiService
	id                       string
	writableObjectPermission *WritableObjectPermission
}

func (r ApiUsersPermissionsUpdateRequest) WritableObjectPermission(writableObjectPermission WritableObjectPermission) ApiUsersPermissionsUpdateRequest {
	r.writableObjectPermission = &writableObjectPermission
	return r
}

func (r ApiUsersPermissionsUpdateRequest) Execute() (*ObjectPermission, *http.Response, error) {
	return r.ApiService.UsersPermissionsUpdateExecute(r)
}

/*
UsersPermissionsUpdate Method for UsersPermissionsUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this permission.
 @return ApiUsersPermissionsUpdateRequest
*/
func (a *UsersApiService) UsersPermissionsUpdate(ctx context.Context, id string) ApiUsersPermissionsUpdateRequest {
	return ApiUsersPermissionsUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return ObjectPermission
func (a *UsersApiService) UsersPermissionsUpdateExecute(r ApiUsersPermissionsUpdateRequest) (*ObjectPermission, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ObjectPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersPermissionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/permissions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableObjectPermission == nil {
		return localVarReturnValue, nil, reportError("writableObjectPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableObjectPermission
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensBulkDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
}

func (r ApiUsersTokensBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersTokensBulkDestroyExecute(r)
}

/*
UsersTokensBulkDestroy Method for UsersTokensBulkDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersTokensBulkDestroyRequest
*/
func (a *UsersApiService) UsersTokensBulkDestroy(ctx context.Context) ApiUsersTokensBulkDestroyRequest {
	return ApiUsersTokensBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersTokensBulkDestroyExecute(r ApiUsersTokensBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTokensBulkPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	patchedToken *PatchedToken
}

func (r ApiUsersTokensBulkPartialUpdateRequest) PatchedToken(patchedToken PatchedToken) ApiUsersTokensBulkPartialUpdateRequest {
	r.patchedToken = &patchedToken
	return r
}

func (r ApiUsersTokensBulkPartialUpdateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensBulkPartialUpdateExecute(r)
}

/*
UsersTokensBulkPartialUpdate Method for UsersTokensBulkPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersTokensBulkPartialUpdateRequest
*/
func (a *UsersApiService) UsersTokensBulkPartialUpdate(ctx context.Context) ApiUsersTokensBulkPartialUpdateRequest {
	return ApiUsersTokensBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Token
func (a *UsersApiService) UsersTokensBulkPartialUpdateExecute(r ApiUsersTokensBulkPartialUpdateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedToken
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensBulkUpdateRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	token      *Token
}

func (r ApiUsersTokensBulkUpdateRequest) Token(token Token) ApiUsersTokensBulkUpdateRequest {
	r.token = &token
	return r
}

func (r ApiUsersTokensBulkUpdateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensBulkUpdateExecute(r)
}

/*
UsersTokensBulkUpdate Method for UsersTokensBulkUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersTokensBulkUpdateRequest
*/
func (a *UsersApiService) UsersTokensBulkUpdate(ctx context.Context) ApiUsersTokensBulkUpdateRequest {
	return ApiUsersTokensBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Token
func (a *UsersApiService) UsersTokensBulkUpdateExecute(r ApiUsersTokensBulkUpdateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.token
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensCreateRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	token      *Token
}

func (r ApiUsersTokensCreateRequest) Token(token Token) ApiUsersTokensCreateRequest {
	r.token = &token
	return r
}

func (r ApiUsersTokensCreateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensCreateExecute(r)
}

/*
UsersTokensCreate Method for UsersTokensCreate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersTokensCreateRequest
*/
func (a *UsersApiService) UsersTokensCreate(ctx context.Context) ApiUsersTokensCreateRequest {
	return ApiUsersTokensCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Token
func (a *UsersApiService) UsersTokensCreateExecute(r ApiUsersTokensCreateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.token
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         string
}

func (r ApiUsersTokensDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersTokensDestroyExecute(r)
}

/*
UsersTokensDestroy Method for UsersTokensDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this token.
 @return ApiUsersTokensDestroyRequest
*/
func (a *UsersApiService) UsersTokensDestroy(ctx context.Context, id string) ApiUsersTokensDestroyRequest {
	return ApiUsersTokensDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersTokensDestroyExecute(r ApiUsersTokensDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersTokensListRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	created      *[]time.Time
	createdGt    *[]time.Time
	createdGte   *[]time.Time
	createdLt    *[]time.Time
	createdLte   *[]time.Time
	createdN     *[]time.Time
	expires      *[]time.Time
	expiresGt    *[]time.Time
	expiresGte   *[]time.Time
	expiresLt    *[]time.Time
	expiresLte   *[]time.Time
	expiresN     *[]time.Time
	id           *[]string
	idIc         *[]string
	idIe         *[]string
	idIew        *[]string
	idIre        *[]string
	idIsw        *[]string
	idN          *[]string
	idNic        *[]string
	idNie        *[]string
	idNiew       *[]string
	idNire       *[]string
	idNisw       *[]string
	idNre        *[]string
	idRe         *[]string
	key          *[]string
	keyIc        *[]string
	keyIe        *[]string
	keyIew       *[]string
	keyIre       *[]string
	keyIsw       *[]string
	keyN         *[]string
	keyNic       *[]string
	keyNie       *[]string
	keyNiew      *[]string
	keyNire      *[]string
	keyNisw      *[]string
	keyNre       *[]string
	keyRe        *[]string
	limit        *int32
	offset       *int32
	q            *string
	writeEnabled *bool
}

func (r ApiUsersTokensListRequest) Created(created []time.Time) ApiUsersTokensListRequest {
	r.created = &created
	return r
}

func (r ApiUsersTokensListRequest) CreatedGt(createdGt []time.Time) ApiUsersTokensListRequest {
	r.createdGt = &createdGt
	return r
}

func (r ApiUsersTokensListRequest) CreatedGte(createdGte []time.Time) ApiUsersTokensListRequest {
	r.createdGte = &createdGte
	return r
}

func (r ApiUsersTokensListRequest) CreatedLt(createdLt []time.Time) ApiUsersTokensListRequest {
	r.createdLt = &createdLt
	return r
}

func (r ApiUsersTokensListRequest) CreatedLte(createdLte []time.Time) ApiUsersTokensListRequest {
	r.createdLte = &createdLte
	return r
}

func (r ApiUsersTokensListRequest) CreatedN(createdN []time.Time) ApiUsersTokensListRequest {
	r.createdN = &createdN
	return r
}

func (r ApiUsersTokensListRequest) Expires(expires []time.Time) ApiUsersTokensListRequest {
	r.expires = &expires
	return r
}

func (r ApiUsersTokensListRequest) ExpiresGt(expiresGt []time.Time) ApiUsersTokensListRequest {
	r.expiresGt = &expiresGt
	return r
}

func (r ApiUsersTokensListRequest) ExpiresGte(expiresGte []time.Time) ApiUsersTokensListRequest {
	r.expiresGte = &expiresGte
	return r
}

func (r ApiUsersTokensListRequest) ExpiresLt(expiresLt []time.Time) ApiUsersTokensListRequest {
	r.expiresLt = &expiresLt
	return r
}

func (r ApiUsersTokensListRequest) ExpiresLte(expiresLte []time.Time) ApiUsersTokensListRequest {
	r.expiresLte = &expiresLte
	return r
}

func (r ApiUsersTokensListRequest) ExpiresN(expiresN []time.Time) ApiUsersTokensListRequest {
	r.expiresN = &expiresN
	return r
}

func (r ApiUsersTokensListRequest) Id(id []string) ApiUsersTokensListRequest {
	r.id = &id
	return r
}

func (r ApiUsersTokensListRequest) IdIc(idIc []string) ApiUsersTokensListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiUsersTokensListRequest) IdIe(idIe []string) ApiUsersTokensListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiUsersTokensListRequest) IdIew(idIew []string) ApiUsersTokensListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiUsersTokensListRequest) IdIre(idIre []string) ApiUsersTokensListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiUsersTokensListRequest) IdIsw(idIsw []string) ApiUsersTokensListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiUsersTokensListRequest) IdN(idN []string) ApiUsersTokensListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersTokensListRequest) IdNic(idNic []string) ApiUsersTokensListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiUsersTokensListRequest) IdNie(idNie []string) ApiUsersTokensListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiUsersTokensListRequest) IdNiew(idNiew []string) ApiUsersTokensListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiUsersTokensListRequest) IdNire(idNire []string) ApiUsersTokensListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiUsersTokensListRequest) IdNisw(idNisw []string) ApiUsersTokensListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiUsersTokensListRequest) IdNre(idNre []string) ApiUsersTokensListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiUsersTokensListRequest) IdRe(idRe []string) ApiUsersTokensListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiUsersTokensListRequest) Key(key []string) ApiUsersTokensListRequest {
	r.key = &key
	return r
}

func (r ApiUsersTokensListRequest) KeyIc(keyIc []string) ApiUsersTokensListRequest {
	r.keyIc = &keyIc
	return r
}

func (r ApiUsersTokensListRequest) KeyIe(keyIe []string) ApiUsersTokensListRequest {
	r.keyIe = &keyIe
	return r
}

func (r ApiUsersTokensListRequest) KeyIew(keyIew []string) ApiUsersTokensListRequest {
	r.keyIew = &keyIew
	return r
}

func (r ApiUsersTokensListRequest) KeyIre(keyIre []string) ApiUsersTokensListRequest {
	r.keyIre = &keyIre
	return r
}

func (r ApiUsersTokensListRequest) KeyIsw(keyIsw []string) ApiUsersTokensListRequest {
	r.keyIsw = &keyIsw
	return r
}

func (r ApiUsersTokensListRequest) KeyN(keyN []string) ApiUsersTokensListRequest {
	r.keyN = &keyN
	return r
}

func (r ApiUsersTokensListRequest) KeyNic(keyNic []string) ApiUsersTokensListRequest {
	r.keyNic = &keyNic
	return r
}

func (r ApiUsersTokensListRequest) KeyNie(keyNie []string) ApiUsersTokensListRequest {
	r.keyNie = &keyNie
	return r
}

func (r ApiUsersTokensListRequest) KeyNiew(keyNiew []string) ApiUsersTokensListRequest {
	r.keyNiew = &keyNiew
	return r
}

func (r ApiUsersTokensListRequest) KeyNire(keyNire []string) ApiUsersTokensListRequest {
	r.keyNire = &keyNire
	return r
}

func (r ApiUsersTokensListRequest) KeyNisw(keyNisw []string) ApiUsersTokensListRequest {
	r.keyNisw = &keyNisw
	return r
}

func (r ApiUsersTokensListRequest) KeyNre(keyNre []string) ApiUsersTokensListRequest {
	r.keyNre = &keyNre
	return r
}

func (r ApiUsersTokensListRequest) KeyRe(keyRe []string) ApiUsersTokensListRequest {
	r.keyRe = &keyRe
	return r
}

// Number of results to return per page.
func (r ApiUsersTokensListRequest) Limit(limit int32) ApiUsersTokensListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiUsersTokensListRequest) Offset(offset int32) ApiUsersTokensListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiUsersTokensListRequest) Q(q string) ApiUsersTokensListRequest {
	r.q = &q
	return r
}

func (r ApiUsersTokensListRequest) WriteEnabled(writeEnabled bool) ApiUsersTokensListRequest {
	r.writeEnabled = &writeEnabled
	return r
}

func (r ApiUsersTokensListRequest) Execute() (*PaginatedTokenList, *http.Response, error) {
	return r.ApiService.UsersTokensListExecute(r)
}

/*
UsersTokensList Method for UsersTokensList

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersTokensListRequest
*/
func (a *UsersApiService) UsersTokensList(ctx context.Context) ApiUsersTokensListRequest {
	return ApiUsersTokensListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedTokenList
func (a *UsersApiService) UsersTokensListExecute(r ApiUsersTokensListRequest) (*PaginatedTokenList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedTokenList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.created != nil {
		t := *r.created
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("created", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("created", parameterToString(t, "multi"))
		}
	}
	if r.createdGt != nil {
		t := *r.createdGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("created__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("created__gt", parameterToString(t, "multi"))
		}
	}
	if r.createdGte != nil {
		t := *r.createdGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("created__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("created__gte", parameterToString(t, "multi"))
		}
	}
	if r.createdLt != nil {
		t := *r.createdLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("created__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("created__lt", parameterToString(t, "multi"))
		}
	}
	if r.createdLte != nil {
		t := *r.createdLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("created__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("created__lte", parameterToString(t, "multi"))
		}
	}
	if r.createdN != nil {
		t := *r.createdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("created__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("created__n", parameterToString(t, "multi"))
		}
	}
	if r.expires != nil {
		t := *r.expires
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("expires", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("expires", parameterToString(t, "multi"))
		}
	}
	if r.expiresGt != nil {
		t := *r.expiresGt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("expires__gt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("expires__gt", parameterToString(t, "multi"))
		}
	}
	if r.expiresGte != nil {
		t := *r.expiresGte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("expires__gte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("expires__gte", parameterToString(t, "multi"))
		}
	}
	if r.expiresLt != nil {
		t := *r.expiresLt
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("expires__lt", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("expires__lt", parameterToString(t, "multi"))
		}
	}
	if r.expiresLte != nil {
		t := *r.expiresLte
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("expires__lte", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("expires__lte", parameterToString(t, "multi"))
		}
	}
	if r.expiresN != nil {
		t := *r.expiresN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("expires__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("expires__n", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.key != nil {
		t := *r.key
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key", parameterToString(t, "multi"))
		}
	}
	if r.keyIc != nil {
		t := *r.keyIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__ic", parameterToString(t, "multi"))
		}
	}
	if r.keyIe != nil {
		t := *r.keyIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__ie", parameterToString(t, "multi"))
		}
	}
	if r.keyIew != nil {
		t := *r.keyIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__iew", parameterToString(t, "multi"))
		}
	}
	if r.keyIre != nil {
		t := *r.keyIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__ire", parameterToString(t, "multi"))
		}
	}
	if r.keyIsw != nil {
		t := *r.keyIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__isw", parameterToString(t, "multi"))
		}
	}
	if r.keyN != nil {
		t := *r.keyN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__n", parameterToString(t, "multi"))
		}
	}
	if r.keyNic != nil {
		t := *r.keyNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__nic", parameterToString(t, "multi"))
		}
	}
	if r.keyNie != nil {
		t := *r.keyNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__nie", parameterToString(t, "multi"))
		}
	}
	if r.keyNiew != nil {
		t := *r.keyNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__niew", parameterToString(t, "multi"))
		}
	}
	if r.keyNire != nil {
		t := *r.keyNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__nire", parameterToString(t, "multi"))
		}
	}
	if r.keyNisw != nil {
		t := *r.keyNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__nisw", parameterToString(t, "multi"))
		}
	}
	if r.keyNre != nil {
		t := *r.keyNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__nre", parameterToString(t, "multi"))
		}
	}
	if r.keyRe != nil {
		t := *r.keyRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("key__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("key__re", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.writeEnabled != nil {
		localVarQueryParams.Add("write_enabled", parameterToString(*r.writeEnabled, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensPartialUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	id           string
	patchedToken *PatchedToken
}

func (r ApiUsersTokensPartialUpdateRequest) PatchedToken(patchedToken PatchedToken) ApiUsersTokensPartialUpdateRequest {
	r.patchedToken = &patchedToken
	return r
}

func (r ApiUsersTokensPartialUpdateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensPartialUpdateExecute(r)
}

/*
UsersTokensPartialUpdate Method for UsersTokensPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this token.
 @return ApiUsersTokensPartialUpdateRequest
*/
func (a *UsersApiService) UsersTokensPartialUpdate(ctx context.Context, id string) ApiUsersTokensPartialUpdateRequest {
	return ApiUsersTokensPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Token
func (a *UsersApiService) UsersTokensPartialUpdateExecute(r ApiUsersTokensPartialUpdateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedToken
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         string
}

func (r ApiUsersTokensRetrieveRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensRetrieveExecute(r)
}

/*
UsersTokensRetrieve Method for UsersTokensRetrieve

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this token.
 @return ApiUsersTokensRetrieveRequest
*/
func (a *UsersApiService) UsersTokensRetrieve(ctx context.Context, id string) ApiUsersTokensRetrieveRequest {
	return ApiUsersTokensRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Token
func (a *UsersApiService) UsersTokensRetrieveExecute(r ApiUsersTokensRetrieveRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersTokensUpdateRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         string
	token      *Token
}

func (r ApiUsersTokensUpdateRequest) Token(token Token) ApiUsersTokensUpdateRequest {
	r.token = &token
	return r
}

func (r ApiUsersTokensUpdateRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.UsersTokensUpdateExecute(r)
}

/*
UsersTokensUpdate Method for UsersTokensUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this token.
 @return ApiUsersTokensUpdateRequest
*/
func (a *UsersApiService) UsersTokensUpdate(ctx context.Context, id string) ApiUsersTokensUpdateRequest {
	return ApiUsersTokensUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return Token
func (a *UsersApiService) UsersTokensUpdateExecute(r ApiUsersTokensUpdateRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersTokensUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/tokens/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.token
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersBulkDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
}

func (r ApiUsersUsersBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersUsersBulkDestroyExecute(r)
}

/*
UsersUsersBulkDestroy Method for UsersUsersBulkDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersBulkDestroyRequest
*/
func (a *UsersApiService) UsersUsersBulkDestroy(ctx context.Context) ApiUsersUsersBulkDestroyRequest {
	return ApiUsersUsersBulkDestroyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersUsersBulkDestroyExecute(r ApiUsersUsersBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUsersBulkPartialUpdateRequest struct {
	ctx                 context.Context
	ApiService          *UsersApiService
	patchedWritableUser *PatchedWritableUser
}

func (r ApiUsersUsersBulkPartialUpdateRequest) PatchedWritableUser(patchedWritableUser PatchedWritableUser) ApiUsersUsersBulkPartialUpdateRequest {
	r.patchedWritableUser = &patchedWritableUser
	return r
}

func (r ApiUsersUsersBulkPartialUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersBulkPartialUpdateExecute(r)
}

/*
UsersUsersBulkPartialUpdate Method for UsersUsersBulkPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersBulkPartialUpdateRequest
*/
func (a *UsersApiService) UsersUsersBulkPartialUpdate(ctx context.Context) ApiUsersUsersBulkPartialUpdateRequest {
	return ApiUsersUsersBulkPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersBulkPartialUpdateExecute(r ApiUsersUsersBulkPartialUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableUser
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersBulkUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	writableUser *WritableUser
}

func (r ApiUsersUsersBulkUpdateRequest) WritableUser(writableUser WritableUser) ApiUsersUsersBulkUpdateRequest {
	r.writableUser = &writableUser
	return r
}

func (r ApiUsersUsersBulkUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersBulkUpdateExecute(r)
}

/*
UsersUsersBulkUpdate Method for UsersUsersBulkUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersBulkUpdateRequest
*/
func (a *UsersApiService) UsersUsersBulkUpdate(ctx context.Context) ApiUsersUsersBulkUpdateRequest {
	return ApiUsersUsersBulkUpdateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersBulkUpdateExecute(r ApiUsersUsersBulkUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableUser == nil {
		return localVarReturnValue, nil, reportError("writableUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableUser
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersCreateRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	writableUser *WritableUser
}

func (r ApiUsersUsersCreateRequest) WritableUser(writableUser WritableUser) ApiUsersUsersCreateRequest {
	r.writableUser = &writableUser
	return r
}

func (r ApiUsersUsersCreateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersCreateExecute(r)
}

/*
UsersUsersCreate Method for UsersUsersCreate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersCreateRequest
*/
func (a *UsersApiService) UsersUsersCreate(ctx context.Context) ApiUsersUsersCreateRequest {
	return ApiUsersUsersCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersCreateExecute(r ApiUsersUsersCreateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableUser == nil {
		return localVarReturnValue, nil, reportError("writableUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableUser
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersDestroyRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         string
}

func (r ApiUsersUsersDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.UsersUsersDestroyExecute(r)
}

/*
UsersUsersDestroy Method for UsersUsersDestroy

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user.
 @return ApiUsersUsersDestroyRequest
*/
func (a *UsersApiService) UsersUsersDestroy(ctx context.Context, id string) ApiUsersUsersDestroyRequest {
	return ApiUsersUsersDestroyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *UsersApiService) UsersUsersDestroyExecute(r ApiUsersUsersDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUsersUsersListRequest struct {
	ctx           context.Context
	ApiService    *UsersApiService
	email         *[]string
	emailIc       *[]string
	emailIe       *[]string
	emailIew      *[]string
	emailIre      *[]string
	emailIsw      *[]string
	emailN        *[]string
	emailNic      *[]string
	emailNie      *[]string
	emailNiew     *[]string
	emailNire     *[]string
	emailNisw     *[]string
	emailNre      *[]string
	emailRe       *[]string
	firstName     *[]string
	firstNameIc   *[]string
	firstNameIe   *[]string
	firstNameIew  *[]string
	firstNameIre  *[]string
	firstNameIsw  *[]string
	firstNameN    *[]string
	firstNameNic  *[]string
	firstNameNie  *[]string
	firstNameNiew *[]string
	firstNameNire *[]string
	firstNameNisw *[]string
	firstNameNre  *[]string
	firstNameRe   *[]string
	group         *[]string
	groupN        *[]string
	groupId       *[]int32
	groupIdN      *[]int32
	id            *[]string
	idIc          *[]string
	idIe          *[]string
	idIew         *[]string
	idIre         *[]string
	idIsw         *[]string
	idN           *[]string
	idNic         *[]string
	idNie         *[]string
	idNiew        *[]string
	idNire        *[]string
	idNisw        *[]string
	idNre         *[]string
	idRe          *[]string
	isActive      *bool
	isStaff       *bool
	lastName      *[]string
	lastNameIc    *[]string
	lastNameIe    *[]string
	lastNameIew   *[]string
	lastNameIre   *[]string
	lastNameIsw   *[]string
	lastNameN     *[]string
	lastNameNic   *[]string
	lastNameNie   *[]string
	lastNameNiew  *[]string
	lastNameNire  *[]string
	lastNameNisw  *[]string
	lastNameNre   *[]string
	lastNameRe    *[]string
	limit         *int32
	offset        *int32
	q             *string
	username      *[]string
	usernameIc    *[]string
	usernameIe    *[]string
	usernameIew   *[]string
	usernameIre   *[]string
	usernameIsw   *[]string
	usernameN     *[]string
	usernameNic   *[]string
	usernameNie   *[]string
	usernameNiew  *[]string
	usernameNire  *[]string
	usernameNisw  *[]string
	usernameNre   *[]string
	usernameRe    *[]string
}

func (r ApiUsersUsersListRequest) Email(email []string) ApiUsersUsersListRequest {
	r.email = &email
	return r
}

func (r ApiUsersUsersListRequest) EmailIc(emailIc []string) ApiUsersUsersListRequest {
	r.emailIc = &emailIc
	return r
}

func (r ApiUsersUsersListRequest) EmailIe(emailIe []string) ApiUsersUsersListRequest {
	r.emailIe = &emailIe
	return r
}

func (r ApiUsersUsersListRequest) EmailIew(emailIew []string) ApiUsersUsersListRequest {
	r.emailIew = &emailIew
	return r
}

func (r ApiUsersUsersListRequest) EmailIre(emailIre []string) ApiUsersUsersListRequest {
	r.emailIre = &emailIre
	return r
}

func (r ApiUsersUsersListRequest) EmailIsw(emailIsw []string) ApiUsersUsersListRequest {
	r.emailIsw = &emailIsw
	return r
}

func (r ApiUsersUsersListRequest) EmailN(emailN []string) ApiUsersUsersListRequest {
	r.emailN = &emailN
	return r
}

func (r ApiUsersUsersListRequest) EmailNic(emailNic []string) ApiUsersUsersListRequest {
	r.emailNic = &emailNic
	return r
}

func (r ApiUsersUsersListRequest) EmailNie(emailNie []string) ApiUsersUsersListRequest {
	r.emailNie = &emailNie
	return r
}

func (r ApiUsersUsersListRequest) EmailNiew(emailNiew []string) ApiUsersUsersListRequest {
	r.emailNiew = &emailNiew
	return r
}

func (r ApiUsersUsersListRequest) EmailNire(emailNire []string) ApiUsersUsersListRequest {
	r.emailNire = &emailNire
	return r
}

func (r ApiUsersUsersListRequest) EmailNisw(emailNisw []string) ApiUsersUsersListRequest {
	r.emailNisw = &emailNisw
	return r
}

func (r ApiUsersUsersListRequest) EmailNre(emailNre []string) ApiUsersUsersListRequest {
	r.emailNre = &emailNre
	return r
}

func (r ApiUsersUsersListRequest) EmailRe(emailRe []string) ApiUsersUsersListRequest {
	r.emailRe = &emailRe
	return r
}

func (r ApiUsersUsersListRequest) FirstName(firstName []string) ApiUsersUsersListRequest {
	r.firstName = &firstName
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIc(firstNameIc []string) ApiUsersUsersListRequest {
	r.firstNameIc = &firstNameIc
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIe(firstNameIe []string) ApiUsersUsersListRequest {
	r.firstNameIe = &firstNameIe
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIew(firstNameIew []string) ApiUsersUsersListRequest {
	r.firstNameIew = &firstNameIew
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIre(firstNameIre []string) ApiUsersUsersListRequest {
	r.firstNameIre = &firstNameIre
	return r
}

func (r ApiUsersUsersListRequest) FirstNameIsw(firstNameIsw []string) ApiUsersUsersListRequest {
	r.firstNameIsw = &firstNameIsw
	return r
}

func (r ApiUsersUsersListRequest) FirstNameN(firstNameN []string) ApiUsersUsersListRequest {
	r.firstNameN = &firstNameN
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNic(firstNameNic []string) ApiUsersUsersListRequest {
	r.firstNameNic = &firstNameNic
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNie(firstNameNie []string) ApiUsersUsersListRequest {
	r.firstNameNie = &firstNameNie
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNiew(firstNameNiew []string) ApiUsersUsersListRequest {
	r.firstNameNiew = &firstNameNiew
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNire(firstNameNire []string) ApiUsersUsersListRequest {
	r.firstNameNire = &firstNameNire
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNisw(firstNameNisw []string) ApiUsersUsersListRequest {
	r.firstNameNisw = &firstNameNisw
	return r
}

func (r ApiUsersUsersListRequest) FirstNameNre(firstNameNre []string) ApiUsersUsersListRequest {
	r.firstNameNre = &firstNameNre
	return r
}

func (r ApiUsersUsersListRequest) FirstNameRe(firstNameRe []string) ApiUsersUsersListRequest {
	r.firstNameRe = &firstNameRe
	return r
}

// Group (name)
func (r ApiUsersUsersListRequest) Group(group []string) ApiUsersUsersListRequest {
	r.group = &group
	return r
}

// Group (name)
func (r ApiUsersUsersListRequest) GroupN(groupN []string) ApiUsersUsersListRequest {
	r.groupN = &groupN
	return r
}

// Group
func (r ApiUsersUsersListRequest) GroupId(groupId []int32) ApiUsersUsersListRequest {
	r.groupId = &groupId
	return r
}

// Group
func (r ApiUsersUsersListRequest) GroupIdN(groupIdN []int32) ApiUsersUsersListRequest {
	r.groupIdN = &groupIdN
	return r
}

func (r ApiUsersUsersListRequest) Id(id []string) ApiUsersUsersListRequest {
	r.id = &id
	return r
}

func (r ApiUsersUsersListRequest) IdIc(idIc []string) ApiUsersUsersListRequest {
	r.idIc = &idIc
	return r
}

func (r ApiUsersUsersListRequest) IdIe(idIe []string) ApiUsersUsersListRequest {
	r.idIe = &idIe
	return r
}

func (r ApiUsersUsersListRequest) IdIew(idIew []string) ApiUsersUsersListRequest {
	r.idIew = &idIew
	return r
}

func (r ApiUsersUsersListRequest) IdIre(idIre []string) ApiUsersUsersListRequest {
	r.idIre = &idIre
	return r
}

func (r ApiUsersUsersListRequest) IdIsw(idIsw []string) ApiUsersUsersListRequest {
	r.idIsw = &idIsw
	return r
}

func (r ApiUsersUsersListRequest) IdN(idN []string) ApiUsersUsersListRequest {
	r.idN = &idN
	return r
}

func (r ApiUsersUsersListRequest) IdNic(idNic []string) ApiUsersUsersListRequest {
	r.idNic = &idNic
	return r
}

func (r ApiUsersUsersListRequest) IdNie(idNie []string) ApiUsersUsersListRequest {
	r.idNie = &idNie
	return r
}

func (r ApiUsersUsersListRequest) IdNiew(idNiew []string) ApiUsersUsersListRequest {
	r.idNiew = &idNiew
	return r
}

func (r ApiUsersUsersListRequest) IdNire(idNire []string) ApiUsersUsersListRequest {
	r.idNire = &idNire
	return r
}

func (r ApiUsersUsersListRequest) IdNisw(idNisw []string) ApiUsersUsersListRequest {
	r.idNisw = &idNisw
	return r
}

func (r ApiUsersUsersListRequest) IdNre(idNre []string) ApiUsersUsersListRequest {
	r.idNre = &idNre
	return r
}

func (r ApiUsersUsersListRequest) IdRe(idRe []string) ApiUsersUsersListRequest {
	r.idRe = &idRe
	return r
}

func (r ApiUsersUsersListRequest) IsActive(isActive bool) ApiUsersUsersListRequest {
	r.isActive = &isActive
	return r
}

func (r ApiUsersUsersListRequest) IsStaff(isStaff bool) ApiUsersUsersListRequest {
	r.isStaff = &isStaff
	return r
}

func (r ApiUsersUsersListRequest) LastName(lastName []string) ApiUsersUsersListRequest {
	r.lastName = &lastName
	return r
}

func (r ApiUsersUsersListRequest) LastNameIc(lastNameIc []string) ApiUsersUsersListRequest {
	r.lastNameIc = &lastNameIc
	return r
}

func (r ApiUsersUsersListRequest) LastNameIe(lastNameIe []string) ApiUsersUsersListRequest {
	r.lastNameIe = &lastNameIe
	return r
}

func (r ApiUsersUsersListRequest) LastNameIew(lastNameIew []string) ApiUsersUsersListRequest {
	r.lastNameIew = &lastNameIew
	return r
}

func (r ApiUsersUsersListRequest) LastNameIre(lastNameIre []string) ApiUsersUsersListRequest {
	r.lastNameIre = &lastNameIre
	return r
}

func (r ApiUsersUsersListRequest) LastNameIsw(lastNameIsw []string) ApiUsersUsersListRequest {
	r.lastNameIsw = &lastNameIsw
	return r
}

func (r ApiUsersUsersListRequest) LastNameN(lastNameN []string) ApiUsersUsersListRequest {
	r.lastNameN = &lastNameN
	return r
}

func (r ApiUsersUsersListRequest) LastNameNic(lastNameNic []string) ApiUsersUsersListRequest {
	r.lastNameNic = &lastNameNic
	return r
}

func (r ApiUsersUsersListRequest) LastNameNie(lastNameNie []string) ApiUsersUsersListRequest {
	r.lastNameNie = &lastNameNie
	return r
}

func (r ApiUsersUsersListRequest) LastNameNiew(lastNameNiew []string) ApiUsersUsersListRequest {
	r.lastNameNiew = &lastNameNiew
	return r
}

func (r ApiUsersUsersListRequest) LastNameNire(lastNameNire []string) ApiUsersUsersListRequest {
	r.lastNameNire = &lastNameNire
	return r
}

func (r ApiUsersUsersListRequest) LastNameNisw(lastNameNisw []string) ApiUsersUsersListRequest {
	r.lastNameNisw = &lastNameNisw
	return r
}

func (r ApiUsersUsersListRequest) LastNameNre(lastNameNre []string) ApiUsersUsersListRequest {
	r.lastNameNre = &lastNameNre
	return r
}

func (r ApiUsersUsersListRequest) LastNameRe(lastNameRe []string) ApiUsersUsersListRequest {
	r.lastNameRe = &lastNameRe
	return r
}

// Number of results to return per page.
func (r ApiUsersUsersListRequest) Limit(limit int32) ApiUsersUsersListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiUsersUsersListRequest) Offset(offset int32) ApiUsersUsersListRequest {
	r.offset = &offset
	return r
}

// Search
func (r ApiUsersUsersListRequest) Q(q string) ApiUsersUsersListRequest {
	r.q = &q
	return r
}

func (r ApiUsersUsersListRequest) Username(username []string) ApiUsersUsersListRequest {
	r.username = &username
	return r
}

func (r ApiUsersUsersListRequest) UsernameIc(usernameIc []string) ApiUsersUsersListRequest {
	r.usernameIc = &usernameIc
	return r
}

func (r ApiUsersUsersListRequest) UsernameIe(usernameIe []string) ApiUsersUsersListRequest {
	r.usernameIe = &usernameIe
	return r
}

func (r ApiUsersUsersListRequest) UsernameIew(usernameIew []string) ApiUsersUsersListRequest {
	r.usernameIew = &usernameIew
	return r
}

func (r ApiUsersUsersListRequest) UsernameIre(usernameIre []string) ApiUsersUsersListRequest {
	r.usernameIre = &usernameIre
	return r
}

func (r ApiUsersUsersListRequest) UsernameIsw(usernameIsw []string) ApiUsersUsersListRequest {
	r.usernameIsw = &usernameIsw
	return r
}

func (r ApiUsersUsersListRequest) UsernameN(usernameN []string) ApiUsersUsersListRequest {
	r.usernameN = &usernameN
	return r
}

func (r ApiUsersUsersListRequest) UsernameNic(usernameNic []string) ApiUsersUsersListRequest {
	r.usernameNic = &usernameNic
	return r
}

func (r ApiUsersUsersListRequest) UsernameNie(usernameNie []string) ApiUsersUsersListRequest {
	r.usernameNie = &usernameNie
	return r
}

func (r ApiUsersUsersListRequest) UsernameNiew(usernameNiew []string) ApiUsersUsersListRequest {
	r.usernameNiew = &usernameNiew
	return r
}

func (r ApiUsersUsersListRequest) UsernameNire(usernameNire []string) ApiUsersUsersListRequest {
	r.usernameNire = &usernameNire
	return r
}

func (r ApiUsersUsersListRequest) UsernameNisw(usernameNisw []string) ApiUsersUsersListRequest {
	r.usernameNisw = &usernameNisw
	return r
}

func (r ApiUsersUsersListRequest) UsernameNre(usernameNre []string) ApiUsersUsersListRequest {
	r.usernameNre = &usernameNre
	return r
}

func (r ApiUsersUsersListRequest) UsernameRe(usernameRe []string) ApiUsersUsersListRequest {
	r.usernameRe = &usernameRe
	return r
}

func (r ApiUsersUsersListRequest) Execute() (*PaginatedUserList, *http.Response, error) {
	return r.ApiService.UsersUsersListExecute(r)
}

/*
UsersUsersList Method for UsersUsersList

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsersUsersListRequest
*/
func (a *UsersApiService) UsersUsersList(ctx context.Context) ApiUsersUsersListRequest {
	return ApiUsersUsersListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PaginatedUserList
func (a *UsersApiService) UsersUsersListExecute(r ApiUsersUsersListRequest) (*PaginatedUserList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PaginatedUserList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.email != nil {
		t := *r.email
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email", parameterToString(t, "multi"))
		}
	}
	if r.emailIc != nil {
		t := *r.emailIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__ic", parameterToString(t, "multi"))
		}
	}
	if r.emailIe != nil {
		t := *r.emailIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__ie", parameterToString(t, "multi"))
		}
	}
	if r.emailIew != nil {
		t := *r.emailIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__iew", parameterToString(t, "multi"))
		}
	}
	if r.emailIre != nil {
		t := *r.emailIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__ire", parameterToString(t, "multi"))
		}
	}
	if r.emailIsw != nil {
		t := *r.emailIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__isw", parameterToString(t, "multi"))
		}
	}
	if r.emailN != nil {
		t := *r.emailN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__n", parameterToString(t, "multi"))
		}
	}
	if r.emailNic != nil {
		t := *r.emailNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__nic", parameterToString(t, "multi"))
		}
	}
	if r.emailNie != nil {
		t := *r.emailNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__nie", parameterToString(t, "multi"))
		}
	}
	if r.emailNiew != nil {
		t := *r.emailNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__niew", parameterToString(t, "multi"))
		}
	}
	if r.emailNire != nil {
		t := *r.emailNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__nire", parameterToString(t, "multi"))
		}
	}
	if r.emailNisw != nil {
		t := *r.emailNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__nisw", parameterToString(t, "multi"))
		}
	}
	if r.emailNre != nil {
		t := *r.emailNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__nre", parameterToString(t, "multi"))
		}
	}
	if r.emailRe != nil {
		t := *r.emailRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("email__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("email__re", parameterToString(t, "multi"))
		}
	}
	if r.firstName != nil {
		t := *r.firstName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name", parameterToString(t, "multi"))
		}
	}
	if r.firstNameIc != nil {
		t := *r.firstNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__ic", parameterToString(t, "multi"))
		}
	}
	if r.firstNameIe != nil {
		t := *r.firstNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__ie", parameterToString(t, "multi"))
		}
	}
	if r.firstNameIew != nil {
		t := *r.firstNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__iew", parameterToString(t, "multi"))
		}
	}
	if r.firstNameIre != nil {
		t := *r.firstNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__ire", parameterToString(t, "multi"))
		}
	}
	if r.firstNameIsw != nil {
		t := *r.firstNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__isw", parameterToString(t, "multi"))
		}
	}
	if r.firstNameN != nil {
		t := *r.firstNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__n", parameterToString(t, "multi"))
		}
	}
	if r.firstNameNic != nil {
		t := *r.firstNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__nic", parameterToString(t, "multi"))
		}
	}
	if r.firstNameNie != nil {
		t := *r.firstNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__nie", parameterToString(t, "multi"))
		}
	}
	if r.firstNameNiew != nil {
		t := *r.firstNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__niew", parameterToString(t, "multi"))
		}
	}
	if r.firstNameNire != nil {
		t := *r.firstNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__nire", parameterToString(t, "multi"))
		}
	}
	if r.firstNameNisw != nil {
		t := *r.firstNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.firstNameNre != nil {
		t := *r.firstNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__nre", parameterToString(t, "multi"))
		}
	}
	if r.firstNameRe != nil {
		t := *r.firstNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("first_name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("first_name__re", parameterToString(t, "multi"))
		}
	}
	if r.group != nil {
		t := *r.group
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group", parameterToString(t, "multi"))
		}
	}
	if r.groupN != nil {
		t := *r.groupN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group__n", parameterToString(t, "multi"))
		}
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group_id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group_id", parameterToString(t, "multi"))
		}
	}
	if r.groupIdN != nil {
		t := *r.groupIdN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("group_id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("group_id__n", parameterToString(t, "multi"))
		}
	}
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id", parameterToString(t, "multi"))
		}
	}
	if r.idIc != nil {
		t := *r.idIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ic", parameterToString(t, "multi"))
		}
	}
	if r.idIe != nil {
		t := *r.idIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ie", parameterToString(t, "multi"))
		}
	}
	if r.idIew != nil {
		t := *r.idIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__iew", parameterToString(t, "multi"))
		}
	}
	if r.idIre != nil {
		t := *r.idIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__ire", parameterToString(t, "multi"))
		}
	}
	if r.idIsw != nil {
		t := *r.idIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__isw", parameterToString(t, "multi"))
		}
	}
	if r.idN != nil {
		t := *r.idN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__n", parameterToString(t, "multi"))
		}
	}
	if r.idNic != nil {
		t := *r.idNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nic", parameterToString(t, "multi"))
		}
	}
	if r.idNie != nil {
		t := *r.idNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nie", parameterToString(t, "multi"))
		}
	}
	if r.idNiew != nil {
		t := *r.idNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__niew", parameterToString(t, "multi"))
		}
	}
	if r.idNire != nil {
		t := *r.idNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nire", parameterToString(t, "multi"))
		}
	}
	if r.idNisw != nil {
		t := *r.idNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nisw", parameterToString(t, "multi"))
		}
	}
	if r.idNre != nil {
		t := *r.idNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__nre", parameterToString(t, "multi"))
		}
	}
	if r.idRe != nil {
		t := *r.idRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("id__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("id__re", parameterToString(t, "multi"))
		}
	}
	if r.isActive != nil {
		localVarQueryParams.Add("is_active", parameterToString(*r.isActive, ""))
	}
	if r.isStaff != nil {
		localVarQueryParams.Add("is_staff", parameterToString(*r.isStaff, ""))
	}
	if r.lastName != nil {
		t := *r.lastName
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name", parameterToString(t, "multi"))
		}
	}
	if r.lastNameIc != nil {
		t := *r.lastNameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__ic", parameterToString(t, "multi"))
		}
	}
	if r.lastNameIe != nil {
		t := *r.lastNameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__ie", parameterToString(t, "multi"))
		}
	}
	if r.lastNameIew != nil {
		t := *r.lastNameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__iew", parameterToString(t, "multi"))
		}
	}
	if r.lastNameIre != nil {
		t := *r.lastNameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__ire", parameterToString(t, "multi"))
		}
	}
	if r.lastNameIsw != nil {
		t := *r.lastNameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__isw", parameterToString(t, "multi"))
		}
	}
	if r.lastNameN != nil {
		t := *r.lastNameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__n", parameterToString(t, "multi"))
		}
	}
	if r.lastNameNic != nil {
		t := *r.lastNameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__nic", parameterToString(t, "multi"))
		}
	}
	if r.lastNameNie != nil {
		t := *r.lastNameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__nie", parameterToString(t, "multi"))
		}
	}
	if r.lastNameNiew != nil {
		t := *r.lastNameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__niew", parameterToString(t, "multi"))
		}
	}
	if r.lastNameNire != nil {
		t := *r.lastNameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__nire", parameterToString(t, "multi"))
		}
	}
	if r.lastNameNisw != nil {
		t := *r.lastNameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__nisw", parameterToString(t, "multi"))
		}
	}
	if r.lastNameNre != nil {
		t := *r.lastNameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__nre", parameterToString(t, "multi"))
		}
	}
	if r.lastNameRe != nil {
		t := *r.lastNameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("last_name__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("last_name__re", parameterToString(t, "multi"))
		}
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.username != nil {
		t := *r.username
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username", parameterToString(t, "multi"))
		}
	}
	if r.usernameIc != nil {
		t := *r.usernameIc
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__ic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__ic", parameterToString(t, "multi"))
		}
	}
	if r.usernameIe != nil {
		t := *r.usernameIe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__ie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__ie", parameterToString(t, "multi"))
		}
	}
	if r.usernameIew != nil {
		t := *r.usernameIew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__iew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__iew", parameterToString(t, "multi"))
		}
	}
	if r.usernameIre != nil {
		t := *r.usernameIre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__ire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__ire", parameterToString(t, "multi"))
		}
	}
	if r.usernameIsw != nil {
		t := *r.usernameIsw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__isw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__isw", parameterToString(t, "multi"))
		}
	}
	if r.usernameN != nil {
		t := *r.usernameN
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__n", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__n", parameterToString(t, "multi"))
		}
	}
	if r.usernameNic != nil {
		t := *r.usernameNic
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__nic", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__nic", parameterToString(t, "multi"))
		}
	}
	if r.usernameNie != nil {
		t := *r.usernameNie
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__nie", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__nie", parameterToString(t, "multi"))
		}
	}
	if r.usernameNiew != nil {
		t := *r.usernameNiew
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__niew", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__niew", parameterToString(t, "multi"))
		}
	}
	if r.usernameNire != nil {
		t := *r.usernameNire
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__nire", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__nire", parameterToString(t, "multi"))
		}
	}
	if r.usernameNisw != nil {
		t := *r.usernameNisw
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__nisw", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__nisw", parameterToString(t, "multi"))
		}
	}
	if r.usernameNre != nil {
		t := *r.usernameNre
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__nre", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__nre", parameterToString(t, "multi"))
		}
	}
	if r.usernameRe != nil {
		t := *r.usernameRe
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("username__re", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("username__re", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersPartialUpdateRequest struct {
	ctx                 context.Context
	ApiService          *UsersApiService
	id                  string
	patchedWritableUser *PatchedWritableUser
}

func (r ApiUsersUsersPartialUpdateRequest) PatchedWritableUser(patchedWritableUser PatchedWritableUser) ApiUsersUsersPartialUpdateRequest {
	r.patchedWritableUser = &patchedWritableUser
	return r
}

func (r ApiUsersUsersPartialUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersPartialUpdateExecute(r)
}

/*
UsersUsersPartialUpdate Method for UsersUsersPartialUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user.
 @return ApiUsersUsersPartialUpdateRequest
*/
func (a *UsersApiService) UsersUsersPartialUpdate(ctx context.Context, id string) ApiUsersUsersPartialUpdateRequest {
	return ApiUsersUsersPartialUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersPartialUpdateExecute(r ApiUsersUsersPartialUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedWritableUser
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersRetrieveRequest struct {
	ctx        context.Context
	ApiService *UsersApiService
	id         string
}

func (r ApiUsersUsersRetrieveRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersRetrieveExecute(r)
}

/*
UsersUsersRetrieve Method for UsersUsersRetrieve

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user.
 @return ApiUsersUsersRetrieveRequest
*/
func (a *UsersApiService) UsersUsersRetrieve(ctx context.Context, id string) ApiUsersUsersRetrieveRequest {
	return ApiUsersUsersRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersRetrieveExecute(r ApiUsersUsersRetrieveRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsersUsersUpdateRequest struct {
	ctx          context.Context
	ApiService   *UsersApiService
	id           string
	writableUser *WritableUser
}

func (r ApiUsersUsersUpdateRequest) WritableUser(writableUser WritableUser) ApiUsersUsersUpdateRequest {
	r.writableUser = &writableUser
	return r
}

func (r ApiUsersUsersUpdateRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.UsersUsersUpdateExecute(r)
}

/*
UsersUsersUpdate Method for UsersUsersUpdate

Extend DRF's ModelViewSet to support bulk update and delete functions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user.
 @return ApiUsersUsersUpdateRequest
*/
func (a *UsersApiService) UsersUsersUpdate(ctx context.Context, id string) ApiUsersUsersUpdateRequest {
	return ApiUsersUsersUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return User
func (a *UsersApiService) UsersUsersUpdateExecute(r ApiUsersUsersUpdateRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UsersUsersUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/users/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.writableUser == nil {
		return localVarReturnValue, nil, reportError("writableUser is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.writableUser
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
